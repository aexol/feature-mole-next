/* tslint:disable */
/* eslint-disable */

export type ValueTypes = {
  /** Autogenerated input type of AcceptTopicSuggestion */
  ["AcceptTopicSuggestionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the suggested topic. */
    name: string;
    /** The Node ID of the repository. */
    repositoryId: string;
  };
  /** Autogenerated return type of AcceptTopicSuggestion */
  ["AcceptTopicSuggestionPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The accepted topic.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `topic` will change from `Topic!` to `Topic`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    topic?: ValueTypes["Topic"];
    __typename?: true;
  }>;
  /** Represents an object which can take actions on GitHub. Typically a User or Bot. */
  ["Actor"]: AliasType<{
    /** The username of the actor. */
    login?: true;
    /** The HTTP path for this actor. */
    resourcePath?: true;
    /** The HTTP URL for this actor. */
    url?: true;
    avatarUrl?: [{ size?: number }, true];
    ["...on Bot"]: ValueTypes["Bot"];
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Autogenerated input type of AddComment */
  ["AddCommentInput"]: {
    /** The Node ID of the subject to modify. */
    subjectId: string;
    /** The contents of the comment. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of AddComment */
  ["AddCommentPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The edge from the subject's comment connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `commentEdge` will change from `IssueCommentEdge!` to `IssueCommentEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    commentEdge?: ValueTypes["IssueCommentEdge"];
    /** 														The subject
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Node!` to `Node`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subject?: ValueTypes["Node"];
    /** 														The edge from the subject's timeline connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `timelineEdge` will change from `IssueTimelineItemEdge!` to `IssueTimelineItemEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    timelineEdge?: ValueTypes["IssueTimelineItemEdge"];
    __typename?: true;
  }>;
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  ["AddedToProjectEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    __typename?: true;
  }>;
  /** Autogenerated input type of AddProjectCard */
  ["AddProjectCardInput"]: {
    /** The content of the card. Must be a member of the ProjectCardItem union */
    contentId?: string;
    /** The note on the card. */
    note?: string;
    /** The Node ID of the ProjectColumn. */
    projectColumnId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of AddProjectCard */
  ["AddProjectCardPayload"]: AliasType<{
    /** 														The edge from the ProjectColumn's card connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `cardEdge` will change from `ProjectCardEdge!` to `ProjectCardEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    cardEdge?: ValueTypes["ProjectCardEdge"];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The ProjectColumn
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectColumn` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    projectColumn?: ValueTypes["Project"];
    __typename?: true;
  }>;
  /** Autogenerated input type of AddProjectColumn */
  ["AddProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the column. */
    name: string;
    /** The Node ID of the project. */
    projectId: string;
  };
  /** Autogenerated return type of AddProjectColumn */
  ["AddProjectColumnPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The edge from the project's column connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `columnEdge` will change from `ProjectColumnEdge!` to `ProjectColumnEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    columnEdge?: ValueTypes["ProjectColumnEdge"];
    /** 														The project
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: ValueTypes["Project"];
    __typename?: true;
  }>;
  /** Autogenerated input type of AddPullRequestReviewComment */
  ["AddPullRequestReviewCommentInput"]: {
    /** The comment id to reply to. */
    inReplyTo?: string;
    /** The relative path of the file to comment on. */
    path?: string;
    /** The line index in the diff to comment on. */
    position?: number;
    /** The Node ID of the review to modify. */
    pullRequestReviewId: string;
    /** The text of the comment. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The SHA of the commit to comment on. */
    commitOID?: ValueTypes["GitObjectID"];
  };
  /** Autogenerated return type of AddPullRequestReviewComment */
  ["AddPullRequestReviewCommentPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The newly created comment.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `comment` will change from `PullRequestReviewComment!` to `PullRequestReviewComment`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    comment?: ValueTypes["PullRequestReviewComment"];
    /** 														The edge from the review's comment connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `commentEdge` will change from
  `PullRequestReviewCommentEdge!` to `PullRequestReviewCommentEdge`.
  **Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    commentEdge?: ValueTypes["PullRequestReviewCommentEdge"];
    __typename?: true;
  }>;
  /** Autogenerated input type of AddPullRequestReview */
  ["AddPullRequestReviewInput"]: {
    /** The Node ID of the pull request to modify. */
    pullRequestId: string;
    /** The contents of the review body comment. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The review line comments. */
    comments?: (ValueTypes["DraftPullRequestReviewComment"] | undefined)[];
    /** The commit OID the review pertains to. */
    commitOID?: ValueTypes["GitObjectID"];
    /** The event to perform on the pull request review. */
    event?: ValueTypes["PullRequestReviewEvent"];
  };
  /** Autogenerated return type of AddPullRequestReview */
  ["AddPullRequestReviewPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The newly created pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: ValueTypes["PullRequestReview"];
    /** 														The edge from the pull request's review connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reviewEdge` will change from `PullRequestReviewEdge!` to `PullRequestReviewEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    reviewEdge?: ValueTypes["PullRequestReviewEdge"];
    __typename?: true;
  }>;
  /** Autogenerated input type of AddReaction */
  ["AddReactionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the emoji to react with. */
    content: ValueTypes["ReactionContent"];
    /** The Node ID of the subject to modify. */
    subjectId: string;
  };
  /** Autogenerated return type of AddReaction */
  ["AddReactionPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The reaction object.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reaction` will change from `Reaction!` to `Reaction`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    reaction?: ValueTypes["Reaction"];
    /** 														The reactable subject.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Reactable!` to `Reactable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subject?: ValueTypes["Reactable"];
    __typename?: true;
  }>;
  /** Autogenerated input type of AddStar */
  ["AddStarInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Starrable ID to star. */
    starrableId: string;
  };
  /** Autogenerated return type of AddStar */
  ["AddStarPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The starrable.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `starrable` will change from `Starrable!` to `Starrable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    starrable?: ValueTypes["Starrable"];
    __typename?: true;
  }>;
  /** A GitHub App. */
  ["App"]: AliasType<{
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The description of the app. */
    description?: true;
    id?: true;
    /** The hex color code, without the leading '#', for the logo background. */
    logoBackgroundColor?: true;
    logoUrl?: [{ size?: number }, true];
    /** The name of the app. */
    name?: true;
    /** A slug based on the name of the app for use in URLs. */
    slug?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The URL to the app's homepage. */
    url?: true;
    __typename?: true;
  }>;
  /** An object that can have users assigned to it. */
  ["Assignable"]: AliasType<{
    assignees?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserConnection"]
    ];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Represents an 'assigned' event on any assignable object. */
  ["AssignedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the assignable associated with the event. */
    assignable?: ValueTypes["Assignable"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Identifies the user who was assigned. */
    user?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  ["BaseRefChangedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    __typename?: true;
  }>;
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  ["BaseRefForcePushedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
    afterCommit?: ValueTypes["Commit"];
    /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
    beforeCommit?: ValueTypes["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
    ref?: ValueTypes["Ref"];
    __typename?: true;
  }>;
  /** Represents a Git blame. */
  ["Blame"]: AliasType<{
    /** The list of ranges from a Git blame. */
    ranges?: ValueTypes["BlameRange"];
    __typename?: true;
  }>;
  /** Represents a range of information from a Git blame. */
  ["BlameRange"]: AliasType<{
    /** 																Identifies the recency of the change, from 1 (new) to 10 (old). This is
calculated as a 2-quantile and determines the length of distance between the
median age of all the changes in the file and the recency of the current
range's change. */
    age?: true;
    /** Identifies the line author */
    commit?: ValueTypes["Commit"];
    /** The ending line for the range */
    endingLine?: true;
    /** The starting line for the range */
    startingLine?: true;
    __typename?: true;
  }>;
  /** Represents a Git blob. */
  ["Blob"]: AliasType<{
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: true;
    /** Byte size of Blob object */
    byteSize?: true;
    /** The HTTP path for this Git object */
    commitResourcePath?: true;
    /** The HTTP URL for this Git object */
    commitUrl?: true;
    id?: true;
    /** Indicates whether the Blob is binary or text */
    isBinary?: true;
    /** Indicates whether the contents is truncated */
    isTruncated?: true;
    /** The Git object ID */
    oid?: true;
    /** The Repository the Git object belongs to */
    repository?: ValueTypes["Repository"];
    /** UTF8 text data or null if the Blob is binary */
    text?: true;
    __typename?: true;
  }>;
  /** A special type of user which takes actions on behalf of GitHub Apps. */
  ["Bot"]: AliasType<{
    avatarUrl?: [{ size?: number }, true];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    /** The username of the actor. */
    login?: true;
    /** The HTTP path for this bot */
    resourcePath?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this bot */
    url?: true;
    __typename?: true;
  }>;
  /** An object that can be closed */
  ["Closable"]: AliasType<{
    /** Identifies the date and time when the object was closed. */
    closedAt?: true;
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: true;
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on Milestone"]: ValueTypes["Milestone"];
    ["...on Project"]: ValueTypes["Project"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Represents a 'closed' event on any `Closable`. */
  ["ClosedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Object that was closed. */
    closable?: ValueTypes["Closable"];
    /** Object which triggered the creation of this event. */
    closer?: ValueTypes["Closer"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** The HTTP path for this closed event. */
    resourcePath?: true;
    /** The HTTP URL for this closed event. */
    url?: true;
    __typename?: true;
  }>;
  /** The object which triggered a `ClosedEvent`. */
  ["Closer"]: AliasType<{
    ["...on Commit"]: ValueTypes["Commit"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** The Code of Conduct for a repository */
  ["CodeOfConduct"]: AliasType<{
    /** The body of the CoC */
    body?: true;
    /** The key for the CoC */
    key?: true;
    /** The formal name of the CoC */
    name?: true;
    /** The path to the CoC */
    url?: true;
    __typename?: true;
  }>;
  /** Collaborators affiliation level with a subject. */
  ["CollaboratorAffiliation"]: CollaboratorAffiliation;
  /** Represents a comment. */
  ["Comment"]: AliasType<{
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The body rendered to HTML. */
    bodyHTML?: true;
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** The body as Markdown. */
    body?: true;
    id?: true;
    /** The body rendered to text. */
    bodyText?: true;
    /** The actor who edited the comment. */
    editor?: ValueTypes["Actor"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    userContentEdits?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    /** Author's association with the subject of the comment. */
    authorAssociation?: true;
    ["...on CommitComment"]: ValueTypes["CommitComment"];
    ["...on GistComment"]: ValueTypes["GistComment"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on PullRequestReview"]: ValueTypes["PullRequestReview"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** A comment author association with repository. */
  ["CommentAuthorAssociation"]: CommentAuthorAssociation;
  /** The possible errors that will prevent a user from updating a comment. */
  ["CommentCannotUpdateReason"]: CommentCannotUpdateReason;
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  ["CommentDeletedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    __typename?: true;
  }>;
  /** Represents a Git commit. */
  ["Commit"]: AliasType<{
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: true;
    /** The number of additions in this commit. */
    additions?: true;
    /** Authorship details of the commit. */
    author?: ValueTypes["GitActor"];
    /** Check if the committer and the author match. */
    authoredByCommitter?: true;
    /** The datetime when this commit was authored. */
    authoredDate?: true;
    blame?: [{ path: string }, ValueTypes["Blame"]];
    /** The number of changed files in this commit. */
    changedFiles?: true;
    comments?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["CommitCommentConnection"]
    ];
    /** The HTTP path for this Git object */
    commitResourcePath?: true;
    /** The HTTP URL for this Git object */
    commitUrl?: true;
    /** The datetime when this commit was committed. */
    committedDate?: true;
    /** Check if commited via GitHub web UI. */
    committedViaWeb?: true;
    /** Committership details of the commit. */
    committer?: ValueTypes["GitActor"];
    /** The number of deletions in this commit. */
    deletions?: true;
    history?: [
      {
        author?: ValueTypes["CommitAuthor"];
        before?: string;
        first?: number;
        last?: number;
        path?: string;
        since?: ValueTypes["GitTimestamp"];
        until?: ValueTypes["GitTimestamp"];
        after?: string;
      },
      ValueTypes["CommitHistoryConnection"]
    ];
    id?: true;
    /** The Git commit message */
    message?: true;
    /** The Git commit message body */
    messageBody?: true;
    /** The commit message body rendered to HTML. */
    messageBodyHTML?: true;
    /** The Git commit message headline */
    messageHeadline?: true;
    /** The commit message headline rendered to HTML. */
    messageHeadlineHTML?: true;
    /** The Git object ID */
    oid?: true;
    parents?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["CommitConnection"]
    ];
    /** The datetime when this commit was pushed. */
    pushedDate?: true;
    /** The Repository this commit belongs to */
    repository?: ValueTypes["Repository"];
    /** The HTTP path for this commit */
    resourcePath?: true;
    /** Commit signing information, if present. */
    signature?: ValueTypes["GitSignature"];
    /** Status information for this commit */
    status?: ValueTypes["Status"];
    /** 																Returns a URL to download a tarball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes. */
    tarballUrl?: true;
    /** Commit's root Tree */
    tree?: ValueTypes["Tree"];
    /** The HTTP path for the tree of this commit */
    treeResourcePath?: true;
    /** The HTTP URL for the tree of this commit */
    treeUrl?: true;
    /** The HTTP URL for this commit */
    url?: true;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: true;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: true;
    /** 																Returns a URL to download a zipball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes. */
    zipballUrl?: true;
    __typename?: true;
  }>;
  /** Specifies an author for filtering Git commits. */
  ["CommitAuthor"]: {
    /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
    emails?: string[];
    /** 																ID of a User to filter by. If non-null, only commits authored by this user
will be returned. This field takes precedence over emails. */
    id?: string;
  };
  /** Represents a comment on a given Commit. */
  ["CommitComment"]: AliasType<{
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: true;
    /** Identifies the comment body. */
    body?: true;
    /** Identifies the comment body rendered to HTML. */
    bodyHTML?: true;
    /** The body rendered to text. */
    bodyText?: true;
    /** Identifies the commit associated with the comment, if the commit exists. */
    commit?: ValueTypes["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The actor who edited the comment. */
    editor?: ValueTypes["Actor"];
    id?: true;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** Identifies the file path associated with the comment. */
    path?: true;
    /** Identifies the line position associated with the comment. */
    position?: true;
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: ValueTypes["ReactionGroup"];
    reactions?: [
      {
        orderBy?: ValueTypes["ReactionOrder"];
        after?: string;
        before?: string;
        content?: ValueTypes["ReactionContent"];
        first?: number;
        last?: number;
      },
      ValueTypes["ReactionConnection"]
    ];
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path permalink for this commit comment. */
    resourcePath?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL permalink for this commit comment. */
    url?: true;
    userContentEdits?: [
      { first?: number; last?: number; after?: string; before?: string },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: true;
    /** Can user react to this subject */
    viewerCanReact?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    __typename?: true;
  }>;
  /** The connection type for CommitComment. */
  ["CommitCommentConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["CommitCommentEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["CommitComment"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["CommitCommentEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["CommitComment"];
    __typename?: true;
  }>;
  /** A thread of comments on a commit. */
  ["CommitCommentThread"]: AliasType<{
    comments?: [
      { first?: number; last?: number; after?: string; before?: string },
      ValueTypes["CommitCommentConnection"]
    ];
    /** The commit the comments were made on. */
    commit?: ValueTypes["Commit"];
    id?: true;
    /** The file the comments were made on. */
    path?: true;
    /** The position in the diff for the commit that the comment was made on. */
    position?: true;
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** The connection type for Commit. */
  ["CommitConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["CommitEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Commit"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["CommitEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Commit"];
    __typename?: true;
  }>;
  /** The connection type for Commit. */
  ["CommitHistoryConnection"]: AliasType<{
    edges?: ValueTypes["CommitEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Commit"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ["ConvertedNoteToIssueEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    __typename?: true;
  }>;
  /** Autogenerated input type of CreateProject */
  ["CreateProjectInput"]: {
    /** The description of project. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of project. */
    name: string;
    /** The owner ID to create the project under. */
    ownerId: string;
  };
  /** Autogenerated return type of CreateProject */
  ["CreateProjectPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The new project.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: ValueTypes["Project"];
    __typename?: true;
  }>;
  /** Represents a mention made by one issue or pull request to another. */
  ["CrossReferencedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Reference originated in a different repository. */
    isCrossRepository?: true;
    /** Identifies when the reference was made. */
    referencedAt?: true;
    /** The HTTP path for this pull request. */
    resourcePath?: true;
    /** Issue or pull request that made the reference. */
    source?: ValueTypes["ReferencedSubject"];
    /** Issue or pull request to which the reference was made. */
    target?: ValueTypes["ReferencedSubject"];
    /** The HTTP URL for this pull request. */
    url?: true;
    /** Checks if the target will be closed when the source is merged. */
    willCloseTarget?: true;
    __typename?: true;
  }>;
  /** An ISO-8601 encoded UTC date string. */
  ["DateTime"]: unknown;
  /** Autogenerated input type of DeclineTopicSuggestion */
  ["DeclineTopicSuggestionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the suggested topic. */
    name: string;
    /** The reason why the suggested topic is declined. */
    reason: ValueTypes["TopicSuggestionDeclineReason"];
    /** The Node ID of the repository. */
    repositoryId: string;
  };
  /** Autogenerated return type of DeclineTopicSuggestion */
  ["DeclineTopicSuggestionPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The declined topic.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `topic` will change from `Topic!` to `Topic`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    topic?: ValueTypes["Topic"];
    __typename?: true;
  }>;
  /** Entities that can be deleted. */
  ["Deletable"]: AliasType<{
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: true;
    ["...on CommitComment"]: ValueTypes["CommitComment"];
    ["...on GistComment"]: ValueTypes["GistComment"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on PullRequestReview"]: ValueTypes["PullRequestReview"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** Autogenerated input type of DeleteProjectCard */
  ["DeleteProjectCardInput"]: {
    /** The id of the card to delete. */
    cardId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of DeleteProjectCard */
  ["DeleteProjectCardPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The column the deleted card was in.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `column` will change from `ProjectColumn!` to `ProjectColumn`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    column?: ValueTypes["ProjectColumn"];
    /** 														The deleted card ID.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `deletedCardId` will change from `ID!` to `ID`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    deletedCardId?: true;
    __typename?: true;
  }>;
  /** Autogenerated input type of DeleteProjectColumn */
  ["DeleteProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The id of the column to delete. */
    columnId: string;
  };
  /** Autogenerated return type of DeleteProjectColumn */
  ["DeleteProjectColumnPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The deleted column ID.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `deletedColumnId` will change from `ID!` to `ID`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    deletedColumnId?: true;
    /** 														The project the deleted column was in.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: ValueTypes["Project"];
    __typename?: true;
  }>;
  /** Autogenerated input type of DeleteProject */
  ["DeleteProjectInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Project ID to update. */
    projectId: string;
  };
  /** Autogenerated return type of DeleteProject */
  ["DeleteProjectPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The repository or organization the project was removed from.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `owner` will change from `ProjectOwner!` to `ProjectOwner`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    owner?: ValueTypes["ProjectOwner"];
    __typename?: true;
  }>;
  /** Autogenerated input type of DeletePullRequestReview */
  ["DeletePullRequestReviewInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the pull request review to delete. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of DeletePullRequestReview */
  ["DeletePullRequestReviewPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The deleted pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: ValueTypes["PullRequestReview"];
    __typename?: true;
  }>;
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  ["DemilestonedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Identifies the milestone title associated with the 'demilestoned' event. */
    milestoneTitle?: true;
    /** Object referenced by event. */
    subject?: ValueTypes["MilestoneItem"];
    __typename?: true;
  }>;
  /** Represents a 'deployed' event on a given pull request. */
  ["DeployedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The deployment associated with the 'deployed' event. */
    deployment?: ValueTypes["Deployment"];
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    /** The ref associated with the 'deployed' event. */
    ref?: ValueTypes["Ref"];
    __typename?: true;
  }>;
  /** A repository deploy key. */
  ["DeployKey"]: AliasType<{
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** The deploy key. */
    key?: true;
    /** Whether or not the deploy key is read only. */
    readOnly?: true;
    /** The deploy key title. */
    title?: true;
    /** Whether or not the deploy key has been verified. */
    verified?: true;
    __typename?: true;
  }>;
  /** The connection type for DeployKey. */
  ["DeployKeyConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["DeployKeyEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["DeployKey"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["DeployKeyEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["DeployKey"];
    __typename?: true;
  }>;
  /** Represents triggered deployment instance. */
  ["Deployment"]: AliasType<{
    /** Identifies the commit sha of the deployment. */
    commit?: ValueTypes["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the actor who triggered the deployment. */
    creator?: ValueTypes["Actor"];
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The deployment description. */
    description?: true;
    /** The environment to which this deployment was made. */
    environment?: true;
    id?: true;
    /** The latest status of this deployment. */
    latestStatus?: ValueTypes["DeploymentStatus"];
    /** Extra information that a deployment system might need. */
    payload?: true;
    /** Identifies the Ref of the deployment, if the deployment was created by ref. */
    ref?: ValueTypes["Ref"];
    /** Identifies the repository associated with the deployment. */
    repository?: ValueTypes["Repository"];
    /** The current state of the deployment. */
    state?: true;
    statuses?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["DeploymentStatusConnection"]
    ];
    /** The deployment task. */
    task?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    __typename?: true;
  }>;
  /** The connection type for Deployment. */
  ["DeploymentConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["DeploymentEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Deployment"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["DeploymentEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Deployment"];
    __typename?: true;
  }>;
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  ["DeploymentEnvironmentChangedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The deployment status that updated the deployment environment. */
    deploymentStatus?: ValueTypes["DeploymentStatus"];
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** The possible states in which a deployment can be. */
  ["DeploymentState"]: DeploymentState;
  /** Describes the status of a given deployment attempt. */
  ["DeploymentStatus"]: AliasType<{
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the actor who triggered the deployment. */
    creator?: ValueTypes["Actor"];
    /** Identifies the deployment associated with status. */
    deployment?: ValueTypes["Deployment"];
    /** Identifies the description of the deployment. */
    description?: true;
    /** Identifies the environment URL of the deployment. */
    environmentUrl?: true;
    id?: true;
    /** Identifies the log URL of the deployment. */
    logUrl?: true;
    /** Identifies the current state of the deployment. */
    state?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    __typename?: true;
  }>;
  /** The connection type for DeploymentStatus. */
  ["DeploymentStatusConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["DeploymentStatusEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["DeploymentStatus"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["DeploymentStatusEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["DeploymentStatus"];
    __typename?: true;
  }>;
  /** The possible states for a deployment status. */
  ["DeploymentStatusState"]: DeploymentStatusState;
  /** Autogenerated input type of DismissPullRequestReview */
  ["DismissPullRequestReviewInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The contents of the pull request review dismissal message. */
    message: string;
    /** The Node ID of the pull request review to modify. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of DismissPullRequestReview */
  ["DismissPullRequestReviewPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The dismissed pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: ValueTypes["PullRequestReview"];
    __typename?: true;
  }>;
  /** Specifies a review comment to be left with a Pull Request Review. */
  ["DraftPullRequestReviewComment"]: {
    /** Path to the file being commented on. */
    path: string;
    /** Position in the file to leave a comment on. */
    position: number;
    /** Body of the comment to leave. */
    body: string;
  };
  /** An external identity provisioned by SAML SSO or SCIM. */
  ["ExternalIdentity"]: AliasType<{
    /** The GUID for this identity */
    guid?: true;
    id?: true;
    /** Organization invitation for this SCIM-provisioned external identity */
    organizationInvitation?: ValueTypes["OrganizationInvitation"];
    /** SAML Identity attributes */
    samlIdentity?: ValueTypes["ExternalIdentitySamlAttributes"];
    /** SCIM Identity attributes */
    scimIdentity?: ValueTypes["ExternalIdentityScimAttributes"];
    /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
    user?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** The connection type for ExternalIdentity. */
  ["ExternalIdentityConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ExternalIdentityEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["ExternalIdentity"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ExternalIdentityEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["ExternalIdentity"];
    __typename?: true;
  }>;
  /** SAML attributes for the External Identity */
  ["ExternalIdentitySamlAttributes"]: AliasType<{
    /** The NameID of the SAML identity */
    nameId?: true;
    __typename?: true;
  }>;
  /** SCIM attributes for the External Identity */
  ["ExternalIdentityScimAttributes"]: AliasType<{
    /** The userName of the SCIM identity */
    username?: true;
    __typename?: true;
  }>;
  /** The connection type for User. */
  ["FollowerConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["UserEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["User"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** The connection type for User. */
  ["FollowingConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["UserEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["User"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** A Gist. */
  ["Gist"]: AliasType<{
    comments?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["GistCommentConnection"]
    ];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The gist description. */
    description?: true;
    id?: true;
    /** Whether the gist is public or not. */
    isPublic?: true;
    /** The gist name. */
    name?: true;
    /** The gist owner. */
    owner?: ValueTypes["RepositoryOwner"];
    /** Identifies when the gist was last pushed to. */
    pushedAt?: true;
    stargazers?: [
      {
        last?: number;
        orderBy?: ValueTypes["StarOrder"];
        after?: string;
        before?: string;
        first?: number;
      },
      ValueTypes["StargazerConnection"]
    ];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred?: true;
    __typename?: true;
  }>;
  /** Represents a comment on an Gist. */
  ["GistComment"]: AliasType<{
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** Author's association with the gist. */
    authorAssociation?: true;
    /** Identifies the comment body. */
    body?: true;
    /** The comment body rendered to HTML. */
    bodyHTML?: true;
    /** The body rendered to text. */
    bodyText?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The actor who edited the comment. */
    editor?: ValueTypes["Actor"];
    /** The associated gist. */
    gist?: ValueTypes["Gist"];
    id?: true;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    userContentEdits?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    __typename?: true;
  }>;
  /** The connection type for GistComment. */
  ["GistCommentConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["GistCommentEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["GistComment"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["GistCommentEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["GistComment"];
    __typename?: true;
  }>;
  /** The connection type for Gist. */
  ["GistConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["GistEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Gist"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["GistEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Gist"];
    __typename?: true;
  }>;
  /** Ordering options for gist connections */
  ["GistOrder"]: {
    /** The ordering direction. */
    direction: ValueTypes["OrderDirection"];
    /** The field to order repositories by. */
    field: ValueTypes["GistOrderField"];
  };
  /** Properties by which gist connections can be ordered. */
  ["GistOrderField"]: GistOrderField;
  /** The privacy of a Gist */
  ["GistPrivacy"]: GistPrivacy;
  /** Represents an actor in a Git commit (ie. an author or committer). */
  ["GitActor"]: AliasType<{
    avatarUrl?: [{ size?: number }, true];
    /** The timestamp of the Git action (authoring or committing). */
    date?: true;
    /** The email in the Git commit. */
    email?: true;
    /** The name in the Git commit. */
    name?: true;
    /** The GitHub user corresponding to the email field. Null if no such user exists. */
    user?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Represents information about the GitHub instance. */
  ["GitHubMetadata"]: AliasType<{
    /** Returns a String that's a SHA of `github-services` */
    gitHubServicesSha?: true;
    /** IP addresses that users connect to for git operations */
    gitIpAddresses?: true;
    /** IP addresses that service hooks are sent from */
    hookIpAddresses?: true;
    /** IP addresses that the importer connects from */
    importerIpAddresses?: true;
    /** Whether or not users are verified */
    isPasswordAuthenticationVerifiable?: true;
    /** IP addresses for GitHub Pages' A records */
    pagesIpAddresses?: true;
    __typename?: true;
  }>;
  /** Represents a Git object. */
  ["GitObject"]: AliasType<{
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: true;
    /** The HTTP path for this Git object */
    commitResourcePath?: true;
    /** The HTTP URL for this Git object */
    commitUrl?: true;
    id?: true;
    /** The Git object ID */
    oid?: true;
    /** The Repository the Git object belongs to */
    repository?: ValueTypes["Repository"];
    ["...on Blob"]: ValueTypes["Blob"];
    ["...on Commit"]: ValueTypes["Commit"];
    ["...on Tag"]: ValueTypes["Tag"];
    ["...on Tree"]: ValueTypes["Tree"];
    __typename?: true;
  }>;
  /** A Git object ID. */
  ["GitObjectID"]: unknown;
  /** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
  ["GitSignature"]: AliasType<{
    /** GitHub user corresponding to the email signing this commit. */
    signer?: ValueTypes["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: true;
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: true;
    /** Email used to sign this object. */
    email?: true;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: true;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: true;
    /** ASCII-armored signature header from object. */
    signature?: true;
    ["...on GpgSignature"]: ValueTypes["GpgSignature"];
    ["...on SmimeSignature"]: ValueTypes["SmimeSignature"];
    ["...on UnknownSignature"]: ValueTypes["UnknownSignature"];
    __typename?: true;
  }>;
  /** The state of a Git signature. */
  ["GitSignatureState"]: GitSignatureState;
  /** Git SSH string */
  ["GitSSHRemote"]: unknown;
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  ["GitTimestamp"]: unknown;
  /** Represents a GPG signature on a Commit or Tag. */
  ["GpgSignature"]: AliasType<{
    /** Email used to sign this object. */
    email?: true;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: true;
    /** Hex-encoded ID of the key that signed this object. */
    keyId?: true;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: true;
    /** ASCII-armored signature header from object. */
    signature?: true;
    /** GitHub user corresponding to the email signing this commit. */
    signer?: ValueTypes["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: true;
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: true;
    __typename?: true;
  }>;
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  ["HeadRefDeletedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the Ref associated with the `head_ref_deleted` event. */
    headRef?: ValueTypes["Ref"];
    /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
    headRefName?: true;
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  ["HeadRefForcePushedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
    afterCommit?: ValueTypes["Commit"];
    /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
    beforeCommit?: ValueTypes["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
    ref?: ValueTypes["Ref"];
    __typename?: true;
  }>;
  /** Represents a 'head_ref_restored' event on a given pull request. */
  ["HeadRefRestoredEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** A string containing HTML code. */
  ["HTML"]: unknown;
  /** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
  ["Issue"]: AliasType<{
    /** Reason that the conversation was locked. */
    activeLockReason?: true;
    assignees?: [
      { last?: number; after?: string; before?: string; first?: number },
      ValueTypes["UserConnection"]
    ];
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: true;
    /** Identifies the body of the issue. */
    body?: true;
    /** Identifies the body of the issue rendered to HTML. */
    bodyHTML?: true;
    /** Identifies the body of the issue rendered to text. */
    bodyText?: true;
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: true;
    /** Identifies the date and time when the object was closed. */
    closedAt?: true;
    comments?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["IssueCommentConnection"]
    ];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The actor who edited the comment. */
    editor?: ValueTypes["Actor"];
    id?: true;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    labels?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["LabelConnection"]
    ];
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** `true` if the object is locked */
    locked?: true;
    /** Identifies the milestone associated with the issue. */
    milestone?: ValueTypes["Milestone"];
    /** Identifies the issue number. */
    number?: true;
    participants?: [
      { last?: number; after?: string; before?: string; first?: number },
      ValueTypes["UserConnection"]
    ];
    projectCards?: [
      {
        after?: string;
        archivedStates?: (ValueTypes["ProjectCardArchivedState"] | undefined)[];
        before?: string;
        first?: number;
        last?: number;
      },
      ValueTypes["ProjectCardConnection"]
    ];
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: ValueTypes["ReactionGroup"];
    reactions?: [
      {
        before?: string;
        content?: ValueTypes["ReactionContent"];
        first?: number;
        last?: number;
        orderBy?: ValueTypes["ReactionOrder"];
        after?: string;
      },
      ValueTypes["ReactionConnection"]
    ];
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path for this issue */
    resourcePath?: true;
    /** Identifies the state of the issue. */
    state?: true;
    timeline?: [
      {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        since?: ValueTypes["DateTime"];
      },
      ValueTypes["IssueTimelineConnection"]
    ];
    /** Identifies the issue title. */
    title?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this issue */
    url?: true;
    userContentEdits?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Can user react to this subject */
    viewerCanReact?: true;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: true;
    __typename?: true;
  }>;
  /** Represents a comment on an Issue. */
  ["IssueComment"]: AliasType<{
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: true;
    /** The body as Markdown. */
    body?: true;
    /** The body rendered to HTML. */
    bodyHTML?: true;
    /** The body rendered to text. */
    bodyText?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The actor who edited the comment. */
    editor?: ValueTypes["Actor"];
    id?: true;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    /** Identifies the issue associated with the comment. */
    issue?: ValueTypes["Issue"];
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** 																Returns the pull request associated with the comment, if this comment was made on a
pull request. */
    pullRequest?: ValueTypes["PullRequest"];
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: ValueTypes["ReactionGroup"];
    reactions?: [
      {
        orderBy?: ValueTypes["ReactionOrder"];
        after?: string;
        before?: string;
        content?: ValueTypes["ReactionContent"];
        first?: number;
        last?: number;
      },
      ValueTypes["ReactionConnection"]
    ];
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path for this issue comment */
    resourcePath?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this issue comment */
    url?: true;
    userContentEdits?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: true;
    /** Can user react to this subject */
    viewerCanReact?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    __typename?: true;
  }>;
  /** The connection type for IssueComment. */
  ["IssueCommentConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["IssueCommentEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["IssueComment"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["IssueCommentEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["IssueComment"];
    __typename?: true;
  }>;
  /** The connection type for Issue. */
  ["IssueConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["IssueEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Issue"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["IssueEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Issue"];
    __typename?: true;
  }>;
  /** Ways in which lists of issues can be ordered upon return. */
  ["IssueOrder"]: {
    /** The direction in which to order issues by the specified field. */
    direction: ValueTypes["OrderDirection"];
    /** The field in which to order issues by. */
    field: ValueTypes["IssueOrderField"];
  };
  /** Properties by which issue connections can be ordered. */
  ["IssueOrderField"]: IssueOrderField;
  /** Used for return value of Repository.issueOrPullRequest. */
  ["IssueOrPullRequest"]: AliasType<{
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** The possible states of an issue. */
  ["IssueState"]: IssueState;
  /** The connection type for IssueTimelineItem. */
  ["IssueTimelineConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["IssueTimelineItemEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["IssueTimelineItem"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An item in an issue timeline */
  ["IssueTimelineItem"]: AliasType<{
    ["...on AssignedEvent"]: ValueTypes["AssignedEvent"];
    ["...on ClosedEvent"]: ValueTypes["ClosedEvent"];
    ["...on Commit"]: ValueTypes["Commit"];
    ["...on CrossReferencedEvent"]: ValueTypes["CrossReferencedEvent"];
    ["...on DemilestonedEvent"]: ValueTypes["DemilestonedEvent"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on LabeledEvent"]: ValueTypes["LabeledEvent"];
    ["...on LockedEvent"]: ValueTypes["LockedEvent"];
    ["...on MilestonedEvent"]: ValueTypes["MilestonedEvent"];
    ["...on ReferencedEvent"]: ValueTypes["ReferencedEvent"];
    ["...on RenamedTitleEvent"]: ValueTypes["RenamedTitleEvent"];
    ["...on ReopenedEvent"]: ValueTypes["ReopenedEvent"];
    ["...on SubscribedEvent"]: ValueTypes["SubscribedEvent"];
    ["...on UnassignedEvent"]: ValueTypes["UnassignedEvent"];
    ["...on UnlabeledEvent"]: ValueTypes["UnlabeledEvent"];
    ["...on UnlockedEvent"]: ValueTypes["UnlockedEvent"];
    ["...on UnsubscribedEvent"]: ValueTypes["UnsubscribedEvent"];
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["IssueTimelineItemEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["IssueTimelineItem"];
    __typename?: true;
  }>;
  /** A label for categorizing Issues or Milestones with a given Repository. */
  ["Label"]: AliasType<{
    /** Identifies the label color. */
    color?: true;
    /** Identifies the date and time when the label was created. */
    createdAt?: true;
    /** A brief description of this label. */
    description?: true;
    id?: true;
    /** Indicates whether or not this is a default label. */
    isDefault?: true;
    issues?: [
      {
        orderBy?: ValueTypes["IssueOrder"];
        states?: ValueTypes["IssueState"][];
        after?: string;
        before?: string;
        first?: number;
        labels?: string[];
        last?: number;
      },
      ValueTypes["IssueConnection"]
    ];
    /** Identifies the label name. */
    name?: true;
    pullRequests?: [
      {
        after?: string;
        before?: string;
        first?: number;
        baseRefName?: string;
        headRefName?: string;
        labels?: string[];
        last?: number;
        orderBy?: ValueTypes["IssueOrder"];
        states?: ValueTypes["PullRequestState"][];
      },
      ValueTypes["PullRequestConnection"]
    ];
    /** The repository associated with this label. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path for this label. */
    resourcePath?: true;
    /** Identifies the date and time when the label was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this label. */
    url?: true;
    __typename?: true;
  }>;
  /** An object that can have labels assigned to it. */
  ["Labelable"]: AliasType<{
    labels?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["LabelConnection"]
    ];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** The connection type for Label. */
  ["LabelConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["LabelEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Label"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a 'labeled' event on a given issue or pull request. */
  ["LabeledEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Identifies the label associated with the 'labeled' event. */
    label?: ValueTypes["Label"];
    /** Identifies the `Labelable` associated with the event. */
    labelable?: ValueTypes["Labelable"];
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["LabelEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Label"];
    __typename?: true;
  }>;
  /** Represents a given language found in repositories. */
  ["Language"]: AliasType<{
    /** The color defined for the current language. */
    color?: true;
    id?: true;
    /** The name of the current language. */
    name?: true;
    __typename?: true;
  }>;
  /** A list of languages associated with the parent. */
  ["LanguageConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["LanguageEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Language"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    /** The total size in bytes of files written in that language. */
    totalSize?: true;
    __typename?: true;
  }>;
  /** Represents the language of a repository. */
  ["LanguageEdge"]: AliasType<{
    cursor?: true;
    node?: ValueTypes["Language"];
    /** The number of bytes of code written in the language. */
    size?: true;
    __typename?: true;
  }>;
  /** Ordering options for language connections. */
  ["LanguageOrder"]: {
    /** The ordering direction. */
    direction: ValueTypes["OrderDirection"];
    /** The field to order languages by. */
    field: ValueTypes["LanguageOrderField"];
  };
  /** Properties by which language connections can be ordered. */
  ["LanguageOrderField"]: LanguageOrderField;
  /** A repository's open source license */
  ["License"]: AliasType<{
    /** The full text of the license */
    body?: true;
    /** The conditions set by the license */
    conditions?: ValueTypes["LicenseRule"];
    /** A human-readable description of the license */
    description?: true;
    /** Whether the license should be featured */
    featured?: true;
    /** Whether the license should be displayed in license pickers */
    hidden?: true;
    id?: true;
    /** Instructions on how to implement the license */
    implementation?: true;
    /** The lowercased SPDX ID of the license */
    key?: true;
    /** The limitations set by the license */
    limitations?: ValueTypes["LicenseRule"];
    /** The license full name specified by <https: spdx.org="" licenses=""></https:> */
    name?: true;
    /** Customary short name if applicable (e.g, GPLv3) */
    nickname?: true;
    /** The permissions set by the license */
    permissions?: ValueTypes["LicenseRule"];
    /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
    pseudoLicense?: true;
    /** Short identifier specified by <https://spdx.org/licenses> */
    spdxId?: true;
    /** URL to the license on <https://choosealicense.com> */
    url?: true;
    __typename?: true;
  }>;
  /** Describes a License's conditions, permissions, and limitations */
  ["LicenseRule"]: AliasType<{
    /** A description of the rule */
    description?: true;
    /** The machine-readable rule key */
    key?: true;
    /** The human-readable rule label */
    label?: true;
    __typename?: true;
  }>;
  /** An object that can be locked. */
  ["Lockable"]: AliasType<{
    /** Reason that the conversation was locked. */
    activeLockReason?: true;
    /** `true` if the object is locked */
    locked?: true;
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Represents a 'locked' event on a given issue or pull request. */
  ["LockedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Reason that the conversation was locked (optional). */
    lockReason?: true;
    /** Object that was locked. */
    lockable?: ValueTypes["Lockable"];
    __typename?: true;
  }>;
  /** Autogenerated input type of LockLockable */
  ["LockLockableInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** A reason for why the issue or pull request will be locked. */
    lockReason?: ValueTypes["LockReason"];
    /** ID of the issue or pull request to be locked. */
    lockableId: string;
  };
  /** Autogenerated return type of LockLockable */
  ["LockLockablePayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** The item that was locked. */
    lockedRecord?: ValueTypes["Lockable"];
    __typename?: true;
  }>;
  /** The possible reasons that an issue or pull request was locked. */
  ["LockReason"]: LockReason;
  /** A public description of a Marketplace category. */
  ["MarketplaceCategory"]: AliasType<{
    /** The category's description. */
    description?: true;
    /** The technical description of how apps listed in this category work with GitHub. */
    howItWorks?: true;
    id?: true;
    /** The category's name. */
    name?: true;
    /** How many Marketplace listings have this as their primary category. */
    primaryListingCount?: true;
    /** The HTTP path for this Marketplace category. */
    resourcePath?: true;
    /** How many Marketplace listings have this as their secondary category. */
    secondaryListingCount?: true;
    /** The short name of the category used in its URL. */
    slug?: true;
    /** The HTTP URL for this Marketplace category. */
    url?: true;
    __typename?: true;
  }>;
  /** A listing in the GitHub integration marketplace. */
  ["MarketplaceListing"]: AliasType<{
    /** The GitHub App this listing represents. */
    app?: ValueTypes["App"];
    /** URL to the listing owner's company site. */
    companyUrl?: true;
    /** The HTTP path for configuring access to the listing's integration or OAuth app */
    configurationResourcePath?: true;
    /** The HTTP URL for configuring access to the listing's integration or OAuth app */
    configurationUrl?: true;
    /** URL to the listing's documentation. */
    documentationUrl?: true;
    /** The listing's detailed description. */
    extendedDescription?: true;
    /** The listing's detailed description rendered to HTML. */
    extendedDescriptionHTML?: true;
    /** The listing's introductory description. */
    fullDescription?: true;
    /** The listing's introductory description rendered to HTML. */
    fullDescriptionHTML?: true;
    /** Whether this listing has been submitted for review from GitHub for approval to be displayed in the Marketplace. */
    hasApprovalBeenRequested?: true;
    /** Does this listing have any plans with a free trial? */
    hasPublishedFreeTrialPlans?: true;
    /** Does this listing have a terms of service link? */
    hasTermsOfService?: true;
    /** A technical description of how this app works with GitHub. */
    howItWorks?: true;
    /** The listing's technical description rendered to HTML. */
    howItWorksHTML?: true;
    id?: true;
    /** URL to install the product to the viewer's account or organization. */
    installationUrl?: true;
    /** Whether this listing's app has been installed for the current viewer */
    installedForViewer?: true;
    /** Whether this listing has been approved for display in the Marketplace. */
    isApproved?: true;
    /** Whether this listing has been removed from the Marketplace. */
    isDelisted?: true;
    /** 																Whether this listing is still an editable draft that has not been submitted
for review and is not publicly visible in the Marketplace. */
    isDraft?: true;
    /** Whether the product this listing represents is available as part of a paid plan. */
    isPaid?: true;
    /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
    isRejected?: true;
    /** The hex color code, without the leading '#', for the logo background. */
    logoBackgroundColor?: true;
    logoUrl?: [{ size?: number }, true];
    /** The listing's full name. */
    name?: true;
    /** The listing's very short description without a trailing period or ampersands. */
    normalizedShortDescription?: true;
    /** URL to the listing's detailed pricing. */
    pricingUrl?: true;
    /** The category that best describes the listing. */
    primaryCategory?: ValueTypes["MarketplaceCategory"];
    /** URL to the listing's privacy policy. */
    privacyPolicyUrl?: true;
    /** The HTTP path for the Marketplace listing. */
    resourcePath?: true;
    /** The URLs for the listing's screenshots. */
    screenshotUrls?: true;
    /** An alternate category that describes the listing. */
    secondaryCategory?: ValueTypes["MarketplaceCategory"];
    /** The listing's very short description. */
    shortDescription?: true;
    /** The short name of the listing used in its URL. */
    slug?: true;
    /** URL to the listing's status page. */
    statusUrl?: true;
    /** An email address for support for this listing's app. */
    supportEmail?: true;
    /** Either a URL or an email address for support for this listing's app. */
    supportUrl?: true;
    /** URL to the listing's terms of service. */
    termsOfServiceUrl?: true;
    /** The HTTP URL for the Marketplace listing. */
    url?: true;
    /** Can the current viewer add plans for this Marketplace listing. */
    viewerCanAddPlans?: true;
    /** Can the current viewer approve this Marketplace listing. */
    viewerCanApprove?: true;
    /** Can the current viewer delist this Marketplace listing. */
    viewerCanDelist?: true;
    /** Can the current viewer edit this Marketplace listing. */
    viewerCanEdit?: true;
    /** 																Can the current viewer edit the primary and secondary category of this
Marketplace listing. */
    viewerCanEditCategories?: true;
    /** Can the current viewer edit the plans for this Marketplace listing. */
    viewerCanEditPlans?: true;
    /** 																Can the current viewer return this Marketplace listing to draft state
so it becomes editable again. */
    viewerCanRedraft?: true;
    /** 																Can the current viewer reject this Marketplace listing by returning it to
an editable draft state or rejecting it entirely. */
    viewerCanReject?: true;
    /** 																Can the current viewer request this listing be reviewed for display in
the Marketplace. */
    viewerCanRequestApproval?: true;
    /** Indicates whether the current user has an active subscription to this Marketplace listing. */
    viewerHasPurchased?: true;
    /** 																Indicates if the current user has purchased a subscription to this Marketplace listing
for all of the organizations the user owns. */
    viewerHasPurchasedForAllOrganizations?: true;
    /** Does the current viewer role allow them to administer this Marketplace listing. */
    viewerIsListingAdmin?: true;
    __typename?: true;
  }>;
  /** Look up Marketplace Listings */
  ["MarketplaceListingConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["MarketplaceListingEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["MarketplaceListing"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["MarketplaceListingEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["MarketplaceListing"];
    __typename?: true;
  }>;
  /** Represents a 'mentioned' event on a given issue or pull request. */
  ["MentionedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    __typename?: true;
  }>;
  /** Whether or not a PullRequest can be merged. */
  ["MergeableState"]: MergeableState;
  /** Represents a 'merged' event on a given pull request. */
  ["MergedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the commit associated with the `merge` event. */
    commit?: ValueTypes["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Identifies the Ref associated with the `merge` event. */
    mergeRef?: ValueTypes["Ref"];
    /** Identifies the name of the Ref associated with the `merge` event. */
    mergeRefName?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    /** The HTTP path for this merged event. */
    resourcePath?: true;
    /** The HTTP URL for this merged event. */
    url?: true;
    __typename?: true;
  }>;
  /** Represents a Milestone object on a given repository. */
  ["Milestone"]: AliasType<{
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: true;
    /** Identifies the date and time when the object was closed. */
    closedAt?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the actor who created the milestone. */
    creator?: ValueTypes["Actor"];
    /** Identifies the description of the milestone. */
    description?: true;
    /** Identifies the due date of the milestone. */
    dueOn?: true;
    id?: true;
    issues?: [
      {
        after?: string;
        before?: string;
        first?: number;
        labels?: string[];
        last?: number;
        orderBy?: ValueTypes["IssueOrder"];
        states?: ValueTypes["IssueState"][];
      },
      ValueTypes["IssueConnection"]
    ];
    /** Identifies the number of the milestone. */
    number?: true;
    pullRequests?: [
      {
        first?: number;
        labels?: string[];
        last?: number;
        orderBy?: ValueTypes["IssueOrder"];
        after?: string;
        baseRefName?: string;
        before?: string;
        headRefName?: string;
        states?: ValueTypes["PullRequestState"][];
      },
      ValueTypes["PullRequestConnection"]
    ];
    /** The repository associated with this milestone. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path for this milestone */
    resourcePath?: true;
    /** Identifies the state of the milestone. */
    state?: true;
    /** Identifies the title of the milestone. */
    title?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this milestone */
    url?: true;
    __typename?: true;
  }>;
  /** The connection type for Milestone. */
  ["MilestoneConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["MilestoneEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Milestone"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a 'milestoned' event on a given issue or pull request. */
  ["MilestonedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Identifies the milestone title associated with the 'milestoned' event. */
    milestoneTitle?: true;
    /** Object referenced by event. */
    subject?: ValueTypes["MilestoneItem"];
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["MilestoneEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Milestone"];
    __typename?: true;
  }>;
  /** Types that can be inside a Milestone. */
  ["MilestoneItem"]: AliasType<{
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Ordering options for milestone connections. */
  ["MilestoneOrder"]: {
    /** The ordering direction. */
    direction: ValueTypes["OrderDirection"];
    /** The field to order milestones by. */
    field: ValueTypes["MilestoneOrderField"];
  };
  /** Properties by which milestone connections can be ordered. */
  ["MilestoneOrderField"]: MilestoneOrderField;
  /** The possible states of a milestone. */
  ["MilestoneState"]: MilestoneState;
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  ["MovedColumnsInProjectEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    __typename?: true;
  }>;
  /** Autogenerated input type of MoveProjectCard */
  ["MoveProjectCardInput"]: {
    /** Place the new card after the card with this id. Pass null to place it at the top. */
    afterCardId?: string;
    /** The id of the card to move. */
    cardId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The id of the column to move it into. */
    columnId: string;
  };
  /** Autogenerated return type of MoveProjectCard */
  ["MoveProjectCardPayload"]: AliasType<{
    /** 														The new edge of the moved card.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `cardEdge` will change from `ProjectCardEdge!` to `ProjectCardEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    cardEdge?: ValueTypes["ProjectCardEdge"];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    __typename?: true;
  }>;
  /** Autogenerated input type of MoveProjectColumn */
  ["MoveProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The id of the column to move. */
    columnId: string;
    /** Place the new column after the column with this id. Pass null to place it at the front. */
    afterColumnId?: string;
  };
  /** Autogenerated return type of MoveProjectColumn */
  ["MoveProjectColumnPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The new edge of the moved column.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `columnEdge` will change from `ProjectColumnEdge!` to `ProjectColumnEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    columnEdge?: ValueTypes["ProjectColumnEdge"];
    __typename?: true;
  }>;
  /** The root query for implementing GraphQL mutations. */
  ["Mutation"]: AliasType<{
    acceptTopicSuggestion?: [
      { input: ValueTypes["AcceptTopicSuggestionInput"] },
      ValueTypes["AcceptTopicSuggestionPayload"]
    ];
    addComment?: [
      { input: ValueTypes["AddCommentInput"] },
      ValueTypes["AddCommentPayload"]
    ];
    addProjectCard?: [
      { input: ValueTypes["AddProjectCardInput"] },
      ValueTypes["AddProjectCardPayload"]
    ];
    addProjectColumn?: [
      { input: ValueTypes["AddProjectColumnInput"] },
      ValueTypes["AddProjectColumnPayload"]
    ];
    addPullRequestReview?: [
      { input: ValueTypes["AddPullRequestReviewInput"] },
      ValueTypes["AddPullRequestReviewPayload"]
    ];
    addPullRequestReviewComment?: [
      { input: ValueTypes["AddPullRequestReviewCommentInput"] },
      ValueTypes["AddPullRequestReviewCommentPayload"]
    ];
    addReaction?: [
      { input: ValueTypes["AddReactionInput"] },
      ValueTypes["AddReactionPayload"]
    ];
    addStar?: [
      { input: ValueTypes["AddStarInput"] },
      ValueTypes["AddStarPayload"]
    ];
    createProject?: [
      { input: ValueTypes["CreateProjectInput"] },
      ValueTypes["CreateProjectPayload"]
    ];
    declineTopicSuggestion?: [
      { input: ValueTypes["DeclineTopicSuggestionInput"] },
      ValueTypes["DeclineTopicSuggestionPayload"]
    ];
    deleteProject?: [
      { input: ValueTypes["DeleteProjectInput"] },
      ValueTypes["DeleteProjectPayload"]
    ];
    deleteProjectCard?: [
      { input: ValueTypes["DeleteProjectCardInput"] },
      ValueTypes["DeleteProjectCardPayload"]
    ];
    deleteProjectColumn?: [
      { input: ValueTypes["DeleteProjectColumnInput"] },
      ValueTypes["DeleteProjectColumnPayload"]
    ];
    deletePullRequestReview?: [
      { input: ValueTypes["DeletePullRequestReviewInput"] },
      ValueTypes["DeletePullRequestReviewPayload"]
    ];
    dismissPullRequestReview?: [
      { input: ValueTypes["DismissPullRequestReviewInput"] },
      ValueTypes["DismissPullRequestReviewPayload"]
    ];
    lockLockable?: [
      { input: ValueTypes["LockLockableInput"] },
      ValueTypes["LockLockablePayload"]
    ];
    moveProjectCard?: [
      { input: ValueTypes["MoveProjectCardInput"] },
      ValueTypes["MoveProjectCardPayload"]
    ];
    moveProjectColumn?: [
      { input: ValueTypes["MoveProjectColumnInput"] },
      ValueTypes["MoveProjectColumnPayload"]
    ];
    removeOutsideCollaborator?: [
      { input: ValueTypes["RemoveOutsideCollaboratorInput"] },
      ValueTypes["RemoveOutsideCollaboratorPayload"]
    ];
    removeReaction?: [
      { input: ValueTypes["RemoveReactionInput"] },
      ValueTypes["RemoveReactionPayload"]
    ];
    removeStar?: [
      { input: ValueTypes["RemoveStarInput"] },
      ValueTypes["RemoveStarPayload"]
    ];
    requestReviews?: [
      { input: ValueTypes["RequestReviewsInput"] },
      ValueTypes["RequestReviewsPayload"]
    ];
    submitPullRequestReview?: [
      { input: ValueTypes["SubmitPullRequestReviewInput"] },
      ValueTypes["SubmitPullRequestReviewPayload"]
    ];
    unlockLockable?: [
      { input: ValueTypes["UnlockLockableInput"] },
      ValueTypes["UnlockLockablePayload"]
    ];
    updateProject?: [
      { input: ValueTypes["UpdateProjectInput"] },
      ValueTypes["UpdateProjectPayload"]
    ];
    updateProjectCard?: [
      { input: ValueTypes["UpdateProjectCardInput"] },
      ValueTypes["UpdateProjectCardPayload"]
    ];
    updateProjectColumn?: [
      { input: ValueTypes["UpdateProjectColumnInput"] },
      ValueTypes["UpdateProjectColumnPayload"]
    ];
    updatePullRequestReview?: [
      { input: ValueTypes["UpdatePullRequestReviewInput"] },
      ValueTypes["UpdatePullRequestReviewPayload"]
    ];
    updatePullRequestReviewComment?: [
      { input: ValueTypes["UpdatePullRequestReviewCommentInput"] },
      ValueTypes["UpdatePullRequestReviewCommentPayload"]
    ];
    updateSubscription?: [
      { input: ValueTypes["UpdateSubscriptionInput"] },
      ValueTypes["UpdateSubscriptionPayload"]
    ];
    updateTopics?: [
      { input: ValueTypes["UpdateTopicsInput"] },
      ValueTypes["UpdateTopicsPayload"]
    ];
    __typename?: true;
  }>;
  /** An object with an ID. */
  ["Node"]: AliasType<{
    /** ID of the object. */
    id?: true;
    ["...on AddedToProjectEvent"]: ValueTypes["AddedToProjectEvent"];
    ["...on App"]: ValueTypes["App"];
    ["...on AssignedEvent"]: ValueTypes["AssignedEvent"];
    ["...on BaseRefChangedEvent"]: ValueTypes["BaseRefChangedEvent"];
    ["...on BaseRefForcePushedEvent"]: ValueTypes["BaseRefForcePushedEvent"];
    ["...on Blob"]: ValueTypes["Blob"];
    ["...on Bot"]: ValueTypes["Bot"];
    ["...on ClosedEvent"]: ValueTypes["ClosedEvent"];
    ["...on CommentDeletedEvent"]: ValueTypes["CommentDeletedEvent"];
    ["...on Commit"]: ValueTypes["Commit"];
    ["...on CommitComment"]: ValueTypes["CommitComment"];
    ["...on CommitCommentThread"]: ValueTypes["CommitCommentThread"];
    ["...on ConvertedNoteToIssueEvent"]: ValueTypes["ConvertedNoteToIssueEvent"];
    ["...on CrossReferencedEvent"]: ValueTypes["CrossReferencedEvent"];
    ["...on DemilestonedEvent"]: ValueTypes["DemilestonedEvent"];
    ["...on DeployedEvent"]: ValueTypes["DeployedEvent"];
    ["...on DeployKey"]: ValueTypes["DeployKey"];
    ["...on Deployment"]: ValueTypes["Deployment"];
    ["...on DeploymentEnvironmentChangedEvent"]: ValueTypes["DeploymentEnvironmentChangedEvent"];
    ["...on DeploymentStatus"]: ValueTypes["DeploymentStatus"];
    ["...on ExternalIdentity"]: ValueTypes["ExternalIdentity"];
    ["...on Gist"]: ValueTypes["Gist"];
    ["...on GistComment"]: ValueTypes["GistComment"];
    ["...on HeadRefDeletedEvent"]: ValueTypes["HeadRefDeletedEvent"];
    ["...on HeadRefForcePushedEvent"]: ValueTypes["HeadRefForcePushedEvent"];
    ["...on HeadRefRestoredEvent"]: ValueTypes["HeadRefRestoredEvent"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on Label"]: ValueTypes["Label"];
    ["...on LabeledEvent"]: ValueTypes["LabeledEvent"];
    ["...on Language"]: ValueTypes["Language"];
    ["...on License"]: ValueTypes["License"];
    ["...on LockedEvent"]: ValueTypes["LockedEvent"];
    ["...on MarketplaceCategory"]: ValueTypes["MarketplaceCategory"];
    ["...on MarketplaceListing"]: ValueTypes["MarketplaceListing"];
    ["...on MentionedEvent"]: ValueTypes["MentionedEvent"];
    ["...on MergedEvent"]: ValueTypes["MergedEvent"];
    ["...on Milestone"]: ValueTypes["Milestone"];
    ["...on MilestonedEvent"]: ValueTypes["MilestonedEvent"];
    ["...on MovedColumnsInProjectEvent"]: ValueTypes["MovedColumnsInProjectEvent"];
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on OrganizationIdentityProvider"]: ValueTypes["OrganizationIdentityProvider"];
    ["...on OrganizationInvitation"]: ValueTypes["OrganizationInvitation"];
    ["...on Project"]: ValueTypes["Project"];
    ["...on ProjectCard"]: ValueTypes["ProjectCard"];
    ["...on ProjectColumn"]: ValueTypes["ProjectColumn"];
    ["...on ProtectedBranch"]: ValueTypes["ProtectedBranch"];
    ["...on PublicKey"]: ValueTypes["PublicKey"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on PullRequestCommit"]: ValueTypes["PullRequestCommit"];
    ["...on PullRequestReview"]: ValueTypes["PullRequestReview"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    ["...on PullRequestReviewThread"]: ValueTypes["PullRequestReviewThread"];
    ["...on PushAllowance"]: ValueTypes["PushAllowance"];
    ["...on Reaction"]: ValueTypes["Reaction"];
    ["...on Ref"]: ValueTypes["Ref"];
    ["...on ReferencedEvent"]: ValueTypes["ReferencedEvent"];
    ["...on Release"]: ValueTypes["Release"];
    ["...on ReleaseAsset"]: ValueTypes["ReleaseAsset"];
    ["...on RemovedFromProjectEvent"]: ValueTypes["RemovedFromProjectEvent"];
    ["...on RenamedTitleEvent"]: ValueTypes["RenamedTitleEvent"];
    ["...on ReopenedEvent"]: ValueTypes["ReopenedEvent"];
    ["...on Repository"]: ValueTypes["Repository"];
    ["...on RepositoryInvitation"]: ValueTypes["RepositoryInvitation"];
    ["...on RepositoryTopic"]: ValueTypes["RepositoryTopic"];
    ["...on ReviewDismissalAllowance"]: ValueTypes["ReviewDismissalAllowance"];
    ["...on ReviewDismissedEvent"]: ValueTypes["ReviewDismissedEvent"];
    ["...on ReviewRequest"]: ValueTypes["ReviewRequest"];
    ["...on ReviewRequestedEvent"]: ValueTypes["ReviewRequestedEvent"];
    ["...on ReviewRequestRemovedEvent"]: ValueTypes["ReviewRequestRemovedEvent"];
    ["...on Status"]: ValueTypes["Status"];
    ["...on StatusContext"]: ValueTypes["StatusContext"];
    ["...on SubscribedEvent"]: ValueTypes["SubscribedEvent"];
    ["...on Tag"]: ValueTypes["Tag"];
    ["...on Team"]: ValueTypes["Team"];
    ["...on Topic"]: ValueTypes["Topic"];
    ["...on Tree"]: ValueTypes["Tree"];
    ["...on UnassignedEvent"]: ValueTypes["UnassignedEvent"];
    ["...on UnlabeledEvent"]: ValueTypes["UnlabeledEvent"];
    ["...on UnlockedEvent"]: ValueTypes["UnlockedEvent"];
    ["...on UnsubscribedEvent"]: ValueTypes["UnsubscribedEvent"];
    ["...on User"]: ValueTypes["User"];
    ["...on UserContentEdit"]: ValueTypes["UserContentEdit"];
    __typename?: true;
  }>;
  /** Possible directions in which to order a list of items when provided an `orderBy` argument. */
  ["OrderDirection"]: OrderDirection;
  /** An account on GitHub, with one or more owners, that has repositories, members and teams. */
  ["Organization"]: AliasType<{
    avatarUrl?: [{ size?: number }, true];
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The organization's public profile description. */
    description?: true;
    /** The organization's public email. */
    email?: true;
    id?: true;
    /** Whether the organization has verified its profile email and website. */
    isVerified?: true;
    /** The organization's public profile location. */
    location?: true;
    /** The organization's login name. */
    login?: true;
    members?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserConnection"]
    ];
    /** The organization's public profile name. */
    name?: true;
    /** The HTTP path creating a new team */
    newTeamResourcePath?: true;
    /** The HTTP URL creating a new team */
    newTeamUrl?: true;
    /** The billing email for the organization. */
    organizationBillingEmail?: true;
    pinnedRepositories?: [
      {
        before?: string;
        first?: number;
        isLocked?: boolean;
        last?: number;
        orderBy?: ValueTypes["RepositoryOrder"];
        privacy?: ValueTypes["RepositoryPrivacy"];
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        after?: string;
      },
      ValueTypes["RepositoryConnection"]
    ];
    project?: [{ number: number }, ValueTypes["Project"]];
    projects?: [
      {
        search?: string;
        states?: ValueTypes["ProjectState"][];
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        orderBy?: ValueTypes["ProjectOrder"];
      },
      ValueTypes["ProjectConnection"]
    ];
    /** The HTTP path listing organization's projects */
    projectsResourcePath?: true;
    /** The HTTP URL listing organization's projects */
    projectsUrl?: true;
    repositories?: [
      {
        first?: number;
        isFork?: boolean;
        isLocked?: boolean;
        last?: number;
        privacy?: ValueTypes["RepositoryPrivacy"];
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        before?: string;
        after?: string;
        orderBy?: ValueTypes["RepositoryOrder"];
      },
      ValueTypes["RepositoryConnection"]
    ];
    repository?: [{ name: string }, ValueTypes["Repository"]];
    /** 																When true the organization requires all members, billing managers, and outside
collaborators to enable two-factor authentication. */
    requiresTwoFactorAuthentication?: true;
    /** The HTTP path for this organization. */
    resourcePath?: true;
    /** The Organization's SAML Identity Providers */
    samlIdentityProvider?: ValueTypes["OrganizationIdentityProvider"];
    team?: [{ slug: string }, ValueTypes["Team"]];
    teams?: [
      {
        ldapMapped?: boolean;
        orderBy?: ValueTypes["TeamOrder"];
        privacy?: ValueTypes["TeamPrivacy"];
        role?: ValueTypes["TeamRole"];
        userLogins?: string[];
        before?: string;
        first?: number;
        last?: number;
        after?: string;
        query?: string;
        rootTeamsOnly?: boolean;
      },
      ValueTypes["TeamConnection"]
    ];
    /** The HTTP path listing organization's teams */
    teamsResourcePath?: true;
    /** The HTTP URL listing organization's teams */
    teamsUrl?: true;
    /** The HTTP URL for this organization. */
    url?: true;
    /** Organization is adminable by the viewer. */
    viewerCanAdminister?: true;
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects?: true;
    /** Viewer can create repositories on this organization */
    viewerCanCreateRepositories?: true;
    /** Viewer can create teams on this organization. */
    viewerCanCreateTeams?: true;
    /** Viewer is an active member of this organization. */
    viewerIsAMember?: true;
    /** The organization's public profile URL. */
    websiteUrl?: true;
    __typename?: true;
  }>;
  /** The connection type for Organization. */
  ["OrganizationConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["OrganizationEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Organization"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["OrganizationEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Organization"];
    __typename?: true;
  }>;
  /** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
  ["OrganizationIdentityProvider"]: AliasType<{
    /** The digest algorithm used to sign SAML requests for the Identity Provider. */
    digestMethod?: true;
    externalIdentities?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["ExternalIdentityConnection"]
    ];
    id?: true;
    /** The x509 certificate used by the Identity Provder to sign assertions and responses. */
    idpCertificate?: true;
    /** The Issuer Entity ID for the SAML Identity Provider */
    issuer?: true;
    /** Organization this Identity Provider belongs to */
    organization?: ValueTypes["Organization"];
    /** The signature algorithm used to sign SAML requests for the Identity Provider. */
    signatureMethod?: true;
    /** The URL endpoint for the Identity Provider's SAML SSO. */
    ssoUrl?: true;
    __typename?: true;
  }>;
  /** An Invitation for a user to an organization. */
  ["OrganizationInvitation"]: AliasType<{
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The email address of the user invited to the organization. */
    email?: true;
    id?: true;
    /** The type of invitation that was sent (e.g. email, user). */
    invitationType?: true;
    /** The user who was invited to the organization. */
    invitee?: ValueTypes["User"];
    /** The user who created the invitation. */
    inviter?: ValueTypes["User"];
    /** The organization the invite is for */
    organization?: ValueTypes["Organization"];
    /** The user's pending role in the organization (e.g. member, owner). */
    role?: true;
    __typename?: true;
  }>;
  /** The connection type for OrganizationInvitation. */
  ["OrganizationInvitationConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["OrganizationInvitationEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["OrganizationInvitation"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["OrganizationInvitationEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["OrganizationInvitation"];
    __typename?: true;
  }>;
  /** The possible organization invitation roles. */
  ["OrganizationInvitationRole"]: OrganizationInvitationRole;
  /** The possible organization invitation types. */
  ["OrganizationInvitationType"]: OrganizationInvitationType;
  /** Information about pagination in a connection. */
  ["PageInfo"]: AliasType<{
    /** When paginating forwards, the cursor to continue. */
    endCursor?: true;
    /** When paginating forwards, are there more items? */
    hasNextPage?: true;
    /** When paginating backwards, are there more items? */
    hasPreviousPage?: true;
    /** When paginating backwards, the cursor to continue. */
    startCursor?: true;
    __typename?: true;
  }>;
  /** Projects manage issues, pull requests and notes within a project owner. */
  ["Project"]: AliasType<{
    /** The project's description body. */
    body?: true;
    /** The projects description body rendered to HTML. */
    bodyHTML?: true;
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: true;
    /** Identifies the date and time when the object was closed. */
    closedAt?: true;
    columns?: [
      { last?: number; after?: string; before?: string; first?: number },
      ValueTypes["ProjectColumnConnection"]
    ];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The actor who originally created the project. */
    creator?: ValueTypes["Actor"];
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    /** The project's name. */
    name?: true;
    /** The project's number. */
    number?: true;
    /** The project's owner. Currently limited to repositories and organizations. */
    owner?: ValueTypes["ProjectOwner"];
    pendingCards?: [
      {
        archivedStates?: (ValueTypes["ProjectCardArchivedState"] | undefined)[];
        before?: string;
        first?: number;
        last?: number;
        after?: string;
      },
      ValueTypes["ProjectCardConnection"]
    ];
    /** The HTTP path for this project */
    resourcePath?: true;
    /** Whether the project is open or closed. */
    state?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this project */
    url?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    __typename?: true;
  }>;
  /** A card in a project. */
  ["ProjectCard"]: AliasType<{
    /** 																The project column this card is associated under. A card may only belong to one
project column at a time. The column field will be null if the card is created
in a pending state and has yet to be associated with a column. Once cards are
associated with a column, they will not become pending in the future. */
    column?: ValueTypes["ProjectColumn"];
    /** The card content item */
    content?: ValueTypes["ProjectCardItem"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The actor who created this card */
    creator?: ValueTypes["Actor"];
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    /** Whether the card is archived */
    isArchived?: true;
    /** The card note */
    note?: true;
    /** The project that contains this card. */
    project?: ValueTypes["Project"];
    /** The HTTP path for this card */
    resourcePath?: true;
    /** The state of ProjectCard */
    state?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this card */
    url?: true;
    __typename?: true;
  }>;
  /** The possible archived states of a project card. */
  ["ProjectCardArchivedState"]: ProjectCardArchivedState;
  /** The connection type for ProjectCard. */
  ["ProjectCardConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ProjectCardEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["ProjectCard"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ProjectCardEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["ProjectCard"];
    __typename?: true;
  }>;
  /** Types that can be inside Project Cards. */
  ["ProjectCardItem"]: AliasType<{
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Various content states of a ProjectCard */
  ["ProjectCardState"]: ProjectCardState;
  /** A column inside a project. */
  ["ProjectColumn"]: AliasType<{
    cards?: [
      {
        archivedStates?: (ValueTypes["ProjectCardArchivedState"] | undefined)[];
        before?: string;
        first?: number;
        last?: number;
        after?: string;
      },
      ValueTypes["ProjectCardConnection"]
    ];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    /** The project column's name. */
    name?: true;
    /** The project that contains this column. */
    project?: ValueTypes["Project"];
    /** The semantic purpose of the column */
    purpose?: true;
    /** The HTTP path for this project column */
    resourcePath?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this project column */
    url?: true;
    __typename?: true;
  }>;
  /** The connection type for ProjectColumn. */
  ["ProjectColumnConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ProjectColumnEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["ProjectColumn"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ProjectColumnEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["ProjectColumn"];
    __typename?: true;
  }>;
  /** The semantic purpose of the column - todo, in progress, or done. */
  ["ProjectColumnPurpose"]: ProjectColumnPurpose;
  /** A list of projects associated with the owner. */
  ["ProjectConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ProjectEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Project"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ProjectEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Project"];
    __typename?: true;
  }>;
  /** Ways in which lists of projects can be ordered upon return. */
  ["ProjectOrder"]: {
    /** The direction in which to order projects by the specified field. */
    direction: ValueTypes["OrderDirection"];
    /** The field in which to order projects by. */
    field: ValueTypes["ProjectOrderField"];
  };
  /** Properties by which project connections can be ordered. */
  ["ProjectOrderField"]: ProjectOrderField;
  /** Represents an owner of a Project. */
  ["ProjectOwner"]: AliasType<{
    projects?: [
      {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        orderBy?: ValueTypes["ProjectOrder"];
        search?: string;
        states?: ValueTypes["ProjectState"][];
      },
      ValueTypes["ProjectConnection"]
    ];
    /** The HTTP path listing owners projects */
    projectsResourcePath?: true;
    /** The HTTP URL listing owners projects */
    projectsUrl?: true;
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects?: true;
    id?: true;
    project?: [{ number: number }, ValueTypes["Project"]];
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on Repository"]: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** State of the project; either 'open' or 'closed' */
  ["ProjectState"]: ProjectState;
  /** A repository protected branch. */
  ["ProtectedBranch"]: AliasType<{
    /** The actor who created this protected branch. */
    creator?: ValueTypes["Actor"];
    /** Will new commits pushed to this branch dismiss pull request review approvals. */
    hasDismissableStaleReviews?: true;
    /** Are reviews required to update this branch. */
    hasRequiredReviews?: true;
    /** Are status checks required to update this branch. */
    hasRequiredStatusChecks?: true;
    /** Is pushing to this branch restricted. */
    hasRestrictedPushes?: true;
    /** Is dismissal of pull request reviews restricted. */
    hasRestrictedReviewDismissals?: true;
    /** Are branches required to be up to date before merging. */
    hasStrictRequiredStatusChecks?: true;
    id?: true;
    /** Can admins overwrite branch protection. */
    isAdminEnforced?: true;
    /** The name of the protected branch rule. */
    name?: true;
    pushAllowances?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["PushAllowanceConnection"]
    ];
    /** The repository associated with this protected branch. */
    repository?: ValueTypes["Repository"];
    /** List of required status check contexts that must pass for commits to be accepted to this branch. */
    requiredStatusCheckContexts?: true;
    reviewDismissalAllowances?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["ReviewDismissalAllowanceConnection"]
    ];
    __typename?: true;
  }>;
  /** The connection type for ProtectedBranch. */
  ["ProtectedBranchConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ProtectedBranchEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["ProtectedBranch"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ProtectedBranchEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["ProtectedBranch"];
    __typename?: true;
  }>;
  /** A user's public key. */
  ["PublicKey"]: AliasType<{
    id?: true;
    /** The public key string */
    key?: true;
    __typename?: true;
  }>;
  /** The connection type for PublicKey. */
  ["PublicKeyConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["PublicKeyEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["PublicKey"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["PublicKeyEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["PublicKey"];
    __typename?: true;
  }>;
  /** A repository pull request. */
  ["PullRequest"]: AliasType<{
    /** Reason that the conversation was locked. */
    activeLockReason?: true;
    /** The number of additions in this pull request. */
    additions?: true;
    assignees?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["UserConnection"]
    ];
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: true;
    /** Identifies the base Ref associated with the pull request. */
    baseRef?: ValueTypes["Ref"];
    /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
    baseRefName?: true;
    /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
    baseRefOid?: true;
    /** The body as Markdown. */
    body?: true;
    /** The body rendered to HTML. */
    bodyHTML?: true;
    /** The body rendered to text. */
    bodyText?: true;
    /** The number of changed files in this pull request. */
    changedFiles?: true;
    /** `true` if the pull request is closed */
    closed?: true;
    /** Identifies the date and time when the object was closed. */
    closedAt?: true;
    comments?: [
      { first?: number; last?: number; after?: string; before?: string },
      ValueTypes["IssueCommentConnection"]
    ];
    commits?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["PullRequestCommitConnection"]
    ];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The number of deletions in this pull request. */
    deletions?: true;
    /** The actor who edited this pull request's body. */
    editor?: ValueTypes["Actor"];
    /** Identifies the head Ref associated with the pull request. */
    headRef?: ValueTypes["Ref"];
    /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
    headRefName?: true;
    /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
    headRefOid?: true;
    /** The repository associated with this pull request's head Ref. */
    headRepository?: ValueTypes["Repository"];
    /** The owner of the repository associated with this pull request's head Ref. */
    headRepositoryOwner?: ValueTypes["RepositoryOwner"];
    id?: true;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    /** The head and base repositories are different. */
    isCrossRepository?: true;
    labels?: [
      { last?: number; after?: string; before?: string; first?: number },
      ValueTypes["LabelConnection"]
    ];
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** `true` if the pull request is locked */
    locked?: true;
    /** Indicates whether maintainers can modify the pull request. */
    maintainerCanModify?: true;
    /** The commit that was created when this pull request was merged. */
    mergeCommit?: ValueTypes["Commit"];
    /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
    mergeable?: true;
    /** Whether or not the pull request was merged. */
    merged?: true;
    /** The date and time that the pull request was merged. */
    mergedAt?: true;
    /** The actor who merged the pull request. */
    mergedBy?: ValueTypes["Actor"];
    /** Identifies the milestone associated with the pull request. */
    milestone?: ValueTypes["Milestone"];
    /** Identifies the pull request number. */
    number?: true;
    participants?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserConnection"]
    ];
    /** The permalink to the pull request. */
    permalink?: true;
    /** 																The commit that GitHub automatically generated to test if this pull request
could be merged. This field will not return a value if the pull request is
merged, or if the test merge commit is still being generated. See the
`mergeable` field for more details on the mergeability of the pull request. */
    potentialMergeCommit?: ValueTypes["Commit"];
    projectCards?: [
      {
        archivedStates?: (ValueTypes["ProjectCardArchivedState"] | undefined)[];
        before?: string;
        first?: number;
        last?: number;
        after?: string;
      },
      ValueTypes["ProjectCardConnection"]
    ];
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: ValueTypes["ReactionGroup"];
    reactions?: [
      {
        last?: number;
        orderBy?: ValueTypes["ReactionOrder"];
        after?: string;
        before?: string;
        content?: ValueTypes["ReactionContent"];
        first?: number;
      },
      ValueTypes["ReactionConnection"]
    ];
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path for this pull request. */
    resourcePath?: true;
    /** The HTTP path for reverting this pull request. */
    revertResourcePath?: true;
    /** The HTTP URL for reverting this pull request. */
    revertUrl?: true;
    reviewRequests?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["ReviewRequestConnection"]
    ];
    reviews?: [
      {
        after?: string;
        author?: string;
        before?: string;
        first?: number;
        last?: number;
        states?: ValueTypes["PullRequestReviewState"][];
      },
      ValueTypes["PullRequestReviewConnection"]
    ];
    /** Identifies the state of the pull request. */
    state?: true;
    /** A list of reviewer suggestions based on commit history and past review comments. */
    suggestedReviewers?: ValueTypes["SuggestedReviewer"];
    timeline?: [
      {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        since?: ValueTypes["DateTime"];
      },
      ValueTypes["PullRequestTimelineConnection"]
    ];
    /** Identifies the pull request title. */
    title?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this pull request. */
    url?: true;
    userContentEdits?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Whether or not the viewer can apply suggestion. */
    viewerCanApplySuggestion?: true;
    /** Can user react to this subject */
    viewerCanReact?: true;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: true;
    __typename?: true;
  }>;
  /** Represents a Git commit part of a pull request. */
  ["PullRequestCommit"]: AliasType<{
    /** The Git commit object */
    commit?: ValueTypes["Commit"];
    id?: true;
    /** The pull request this commit belongs to */
    pullRequest?: ValueTypes["PullRequest"];
    /** The HTTP path for this pull request commit */
    resourcePath?: true;
    /** The HTTP URL for this pull request commit */
    url?: true;
    __typename?: true;
  }>;
  /** The connection type for PullRequestCommit. */
  ["PullRequestCommitConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["PullRequestCommitEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["PullRequestCommit"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["PullRequestCommitEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["PullRequestCommit"];
    __typename?: true;
  }>;
  /** The connection type for PullRequest. */
  ["PullRequestConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["PullRequestEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["PullRequest"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["PullRequestEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** A review object for a given pull request. */
  ["PullRequestReview"]: AliasType<{
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: true;
    /** Identifies the pull request review body. */
    body?: true;
    /** The body of this review rendered to HTML. */
    bodyHTML?: true;
    /** The body of this review rendered as plain text. */
    bodyText?: true;
    comments?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["PullRequestReviewCommentConnection"]
    ];
    /** Identifies the commit associated with this pull request review. */
    commit?: ValueTypes["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The actor who edited the comment. */
    editor?: ValueTypes["Actor"];
    id?: true;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** Identifies the pull request associated with this pull request review. */
    pullRequest?: ValueTypes["PullRequest"];
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path permalink for this PullRequestReview. */
    resourcePath?: true;
    /** Identifies the current state of the pull request review. */
    state?: true;
    /** Identifies when the Pull Request Review was submitted */
    submittedAt?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL permalink for this PullRequestReview. */
    url?: true;
    userContentEdits?: [
      { first?: number; last?: number; after?: string; before?: string },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    __typename?: true;
  }>;
  /** A review comment associated with a given repository pull request. */
  ["PullRequestReviewComment"]: AliasType<{
    /** The actor who authored the comment. */
    author?: ValueTypes["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: true;
    /** The comment body of this review comment. */
    body?: true;
    /** The comment body of this review comment rendered to HTML. */
    bodyHTML?: true;
    /** The comment body of this review comment rendered as plain text. */
    bodyText?: true;
    /** Identifies the commit associated with the comment. */
    commit?: ValueTypes["Commit"];
    /** Identifies when the comment was created. */
    createdAt?: true;
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The diff hunk to which the comment applies. */
    diffHunk?: true;
    /** Identifies when the comment was created in a draft state. */
    draftedAt?: true;
    /** The actor who edited the comment. */
    editor?: ValueTypes["Actor"];
    id?: true;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: true;
    /** The moment the editor made the last edit */
    lastEditedAt?: true;
    /** Identifies the original commit associated with the comment. */
    originalCommit?: ValueTypes["Commit"];
    /** The original line index in the diff to which the comment applies. */
    originalPosition?: true;
    /** The path to which the comment applies. */
    path?: true;
    /** The line index in the diff to which the comment applies. */
    position?: true;
    /** Identifies when the comment was published at. */
    publishedAt?: true;
    /** The pull request associated with this review comment. */
    pullRequest?: ValueTypes["PullRequest"];
    /** The pull request review associated with this review comment. */
    pullRequestReview?: ValueTypes["PullRequestReview"];
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: ValueTypes["ReactionGroup"];
    reactions?: [
      {
        before?: string;
        content?: ValueTypes["ReactionContent"];
        first?: number;
        last?: number;
        orderBy?: ValueTypes["ReactionOrder"];
        after?: string;
      },
      ValueTypes["ReactionConnection"]
    ];
    /** The comment this is a reply to. */
    replyTo?: ValueTypes["PullRequestReviewComment"];
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    /** The HTTP path permalink for this review comment. */
    resourcePath?: true;
    /** Identifies when the comment was last updated. */
    updatedAt?: true;
    /** The HTTP URL permalink for this review comment. */
    url?: true;
    userContentEdits?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserContentEditConnection"]
    ];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: true;
    /** Can user react to this subject */
    viewerCanReact?: true;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    /** Did the viewer author this comment. */
    viewerDidAuthor?: true;
    __typename?: true;
  }>;
  /** The connection type for PullRequestReviewComment. */
  ["PullRequestReviewCommentConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["PullRequestReviewCommentEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["PullRequestReviewComment"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["PullRequestReviewCommentEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** The connection type for PullRequestReview. */
  ["PullRequestReviewConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["PullRequestReviewEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["PullRequestReview"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["PullRequestReviewEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["PullRequestReview"];
    __typename?: true;
  }>;
  /** The possible events to perform on a pull request review. */
  ["PullRequestReviewEvent"]: PullRequestReviewEvent;
  /** The possible states of a pull request review. */
  ["PullRequestReviewState"]: PullRequestReviewState;
  /** A threaded list of comments for a given pull request. */
  ["PullRequestReviewThread"]: AliasType<{
    comments?: [
      { first?: number; last?: number; after?: string; before?: string },
      ValueTypes["PullRequestReviewCommentConnection"]
    ];
    id?: true;
    /** Identifies the pull request associated with this thread. */
    pullRequest?: ValueTypes["PullRequest"];
    /** Identifies the repository associated with this thread. */
    repository?: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** The possible states of a pull request. */
  ["PullRequestState"]: PullRequestState;
  /** The connection type for PullRequestTimelineItem. */
  ["PullRequestTimelineConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["PullRequestTimelineItemEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["PullRequestTimelineItem"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An item in an pull request timeline */
  ["PullRequestTimelineItem"]: AliasType<{
    ["...on AssignedEvent"]: ValueTypes["AssignedEvent"];
    ["...on BaseRefForcePushedEvent"]: ValueTypes["BaseRefForcePushedEvent"];
    ["...on ClosedEvent"]: ValueTypes["ClosedEvent"];
    ["...on Commit"]: ValueTypes["Commit"];
    ["...on CommitCommentThread"]: ValueTypes["CommitCommentThread"];
    ["...on CrossReferencedEvent"]: ValueTypes["CrossReferencedEvent"];
    ["...on DemilestonedEvent"]: ValueTypes["DemilestonedEvent"];
    ["...on DeployedEvent"]: ValueTypes["DeployedEvent"];
    ["...on DeploymentEnvironmentChangedEvent"]: ValueTypes["DeploymentEnvironmentChangedEvent"];
    ["...on HeadRefDeletedEvent"]: ValueTypes["HeadRefDeletedEvent"];
    ["...on HeadRefForcePushedEvent"]: ValueTypes["HeadRefForcePushedEvent"];
    ["...on HeadRefRestoredEvent"]: ValueTypes["HeadRefRestoredEvent"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on LabeledEvent"]: ValueTypes["LabeledEvent"];
    ["...on LockedEvent"]: ValueTypes["LockedEvent"];
    ["...on MergedEvent"]: ValueTypes["MergedEvent"];
    ["...on MilestonedEvent"]: ValueTypes["MilestonedEvent"];
    ["...on PullRequestReview"]: ValueTypes["PullRequestReview"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    ["...on PullRequestReviewThread"]: ValueTypes["PullRequestReviewThread"];
    ["...on ReferencedEvent"]: ValueTypes["ReferencedEvent"];
    ["...on RenamedTitleEvent"]: ValueTypes["RenamedTitleEvent"];
    ["...on ReopenedEvent"]: ValueTypes["ReopenedEvent"];
    ["...on ReviewDismissedEvent"]: ValueTypes["ReviewDismissedEvent"];
    ["...on ReviewRequestRemovedEvent"]: ValueTypes["ReviewRequestRemovedEvent"];
    ["...on ReviewRequestedEvent"]: ValueTypes["ReviewRequestedEvent"];
    ["...on SubscribedEvent"]: ValueTypes["SubscribedEvent"];
    ["...on UnassignedEvent"]: ValueTypes["UnassignedEvent"];
    ["...on UnlabeledEvent"]: ValueTypes["UnlabeledEvent"];
    ["...on UnlockedEvent"]: ValueTypes["UnlockedEvent"];
    ["...on UnsubscribedEvent"]: ValueTypes["UnsubscribedEvent"];
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["PullRequestTimelineItemEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["PullRequestTimelineItem"];
    __typename?: true;
  }>;
  /** A team or user who has the ability to push to a protected branch. */
  ["PushAllowance"]: AliasType<{
    /** The actor that can push. */
    actor?: ValueTypes["PushAllowanceActor"];
    id?: true;
    /** Identifies the protected branch associated with the allowed user or team. */
    protectedBranch?: ValueTypes["ProtectedBranch"];
    __typename?: true;
  }>;
  /** Types that can be an actor. */
  ["PushAllowanceActor"]: AliasType<{
    ["...on Team"]: ValueTypes["Team"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** The connection type for PushAllowance. */
  ["PushAllowanceConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["PushAllowanceEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["PushAllowance"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["PushAllowanceEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["PushAllowance"];
    __typename?: true;
  }>;
  /** The query root of GitHub's GraphQL interface. */
  ["Query"]: AliasType<{
    codeOfConduct?: [{ key: string }, ValueTypes["CodeOfConduct"]];
    /** Look up a code of conduct by its key */
    codesOfConduct?: ValueTypes["CodeOfConduct"];
    license?: [{ key: string }, ValueTypes["License"]];
    /** Return a list of known open source licenses */
    licenses?: ValueTypes["License"];
    marketplaceCategories?: [
      {
        excludeEmpty?: boolean;
        excludeSubcategories?: boolean;
        includeCategories?: string[];
      },
      ValueTypes["MarketplaceCategory"]
    ];
    marketplaceCategory?: [
      { slug: string; useTopicAliases?: boolean },
      ValueTypes["MarketplaceCategory"]
    ];
    marketplaceListing?: [{ slug: string }, ValueTypes["MarketplaceListing"]];
    marketplaceListings?: [
      {
        before?: string;
        categorySlug?: string;
        first?: number;
        last?: number;
        organizationId?: string;
        primaryCategoryOnly?: boolean;
        adminId?: string;
        after?: string;
        withFreeTrialsOnly?: boolean;
        slugs?: (string | undefined)[];
        useTopicAliases?: boolean;
        allStates?: boolean;
        viewerCanAdmin?: boolean;
      },
      ValueTypes["MarketplaceListingConnection"]
    ];
    /** Return information about the GitHub instance */
    meta?: ValueTypes["GitHubMetadata"];
    node?: [{ id: string }, ValueTypes["Node"]];
    nodes?: [{ ids: string[] }, ValueTypes["Node"]];
    organization?: [{ login: string }, ValueTypes["Organization"]];
    rateLimit?: [{ dryRun?: boolean }, ValueTypes["RateLimit"]];
    /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */
    relay?: ValueTypes["Query"];
    repository?: [{ name: string; owner: string }, ValueTypes["Repository"]];
    repositoryOwner?: [{ login: string }, ValueTypes["RepositoryOwner"]];
    resource?: [
      { url: ValueTypes["URI"] },
      ValueTypes["UniformResourceLocatable"]
    ];
    search?: [
      {
        query: string;
        type: ValueTypes["SearchType"];
        after?: string;
        before?: string;
        first?: number;
        last?: number;
      },
      ValueTypes["SearchResultItemConnection"]
    ];
    topic?: [{ name: string }, ValueTypes["Topic"]];
    user?: [{ login: string }, ValueTypes["User"]];
    /** The currently authenticated user. */
    viewer?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Represents the client's rate limit. */
  ["RateLimit"]: AliasType<{
    /** The point cost for the current query counting against the rate limit. */
    cost?: true;
    /** The maximum number of points the client is permitted to consume in a 60 minute window. */
    limit?: true;
    /** The maximum number of nodes this query may return */
    nodeCount?: true;
    /** The number of points remaining in the current rate limit window. */
    remaining?: true;
    /** The time at which the current rate limit window resets in UTC epoch seconds. */
    resetAt?: true;
    __typename?: true;
  }>;
  /** Represents a subject that can be reacted on. */
  ["Reactable"]: AliasType<{
    id?: true;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: ValueTypes["ReactionGroup"];
    reactions?: [
      {
        orderBy?: ValueTypes["ReactionOrder"];
        after?: string;
        before?: string;
        content?: ValueTypes["ReactionContent"];
        first?: number;
        last?: number;
      },
      ValueTypes["ReactionConnection"]
    ];
    /** Can user react to this subject */
    viewerCanReact?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    ["...on CommitComment"]: ValueTypes["CommitComment"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** The connection type for User. */
  ["ReactingUserConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ReactingUserEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["User"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a user that's made a reaction. */
  ["ReactingUserEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    node?: ValueTypes["User"];
    /** The moment when the user made the reaction. */
    reactedAt?: true;
    __typename?: true;
  }>;
  /** An emoji reaction to a particular piece of content. */
  ["Reaction"]: AliasType<{
    /** Identifies the emoji reaction. */
    content?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    /** The reactable piece of content */
    reactable?: ValueTypes["Reactable"];
    /** Identifies the user who created this reaction. */
    user?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** A list of reactions that have been left on the subject. */
  ["ReactionConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ReactionEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Reaction"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    /** Whether or not the authenticated user has left a reaction on the subject. */
    viewerHasReacted?: true;
    __typename?: true;
  }>;
  /** Emojis that can be attached to Issues, Pull Requests and Comments. */
  ["ReactionContent"]: ReactionContent;
  /** An edge in a connection. */
  ["ReactionEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Reaction"];
    __typename?: true;
  }>;
  /** A group of emoji reactions to a particular piece of content. */
  ["ReactionGroup"]: AliasType<{
    /** Identifies the emoji reaction. */
    content?: true;
    /** Identifies when the reaction was created. */
    createdAt?: true;
    /** The subject that was reacted to. */
    subject?: ValueTypes["Reactable"];
    users?: [
      { first?: number; last?: number; after?: string; before?: string },
      ValueTypes["ReactingUserConnection"]
    ];
    /** Whether or not the authenticated user has left a reaction on the subject. */
    viewerHasReacted?: true;
    __typename?: true;
  }>;
  /** Ways in which lists of reactions can be ordered upon return. */
  ["ReactionOrder"]: {
    /** The direction in which to order reactions by the specified field. */
    direction: ValueTypes["OrderDirection"];
    /** The field in which to order reactions by. */
    field: ValueTypes["ReactionOrderField"];
  };
  /** A list of fields that reactions can be ordered by. */
  ["ReactionOrderField"]: ReactionOrderField;
  /** Represents a Git reference. */
  ["Ref"]: AliasType<{
    associatedPullRequests?: [
      {
        first?: number;
        headRefName?: string;
        labels?: string[];
        last?: number;
        orderBy?: ValueTypes["IssueOrder"];
        after?: string;
        baseRefName?: string;
        before?: string;
        states?: ValueTypes["PullRequestState"][];
      },
      ValueTypes["PullRequestConnection"]
    ];
    id?: true;
    /** The ref name. */
    name?: true;
    /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
    prefix?: true;
    /** The repository the ref belongs to. */
    repository?: ValueTypes["Repository"];
    /** The object the ref points to. */
    target?: ValueTypes["GitObject"];
    __typename?: true;
  }>;
  /** The connection type for Ref. */
  ["RefConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["RefEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Ref"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["RefEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Ref"];
    __typename?: true;
  }>;
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ["ReferencedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the commit associated with the 'referenced' event. */
    commit?: ValueTypes["Commit"];
    /** Identifies the repository associated with the 'referenced' event. */
    commitRepository?: ValueTypes["Repository"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Reference originated in a different repository. */
    isCrossRepository?: true;
    /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
    isDirectReference?: true;
    /** Object referenced by event. */
    subject?: ValueTypes["ReferencedSubject"];
    __typename?: true;
  }>;
  /** Any referencable object */
  ["ReferencedSubject"]: AliasType<{
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Ways in which lists of git refs can be ordered upon return. */
  ["RefOrder"]: {
    /** The direction in which to order refs by the specified field. */
    direction: ValueTypes["OrderDirection"];
    /** The field in which to order refs by. */
    field: ValueTypes["RefOrderField"];
  };
  /** Properties by which ref connections can be ordered. */
  ["RefOrderField"]: RefOrderField;
  /** Represents an owner of a registry package. */
  ["RegistryPackageOwner"]: AliasType<{
    id?: true;
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on Repository"]: ValueTypes["Repository"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Represents an interface to search packages on an object. */
  ["RegistryPackageSearch"]: AliasType<{
    id?: true;
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** A release contains the content for a release. */
  ["Release"]: AliasType<{
    /** The author of the release */
    author?: ValueTypes["User"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the description of the release. */
    description?: true;
    id?: true;
    /** Whether or not the release is a draft */
    isDraft?: true;
    /** Whether or not the release is a prerelease */
    isPrerelease?: true;
    /** Identifies the title of the release. */
    name?: true;
    /** Identifies the date and time when the release was created. */
    publishedAt?: true;
    releaseAssets?: [
      {
        last?: number;
        name?: string;
        after?: string;
        before?: string;
        first?: number;
      },
      ValueTypes["ReleaseAssetConnection"]
    ];
    /** The HTTP path for this issue */
    resourcePath?: true;
    /** The Git tag the release points to */
    tag?: ValueTypes["Ref"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this issue */
    url?: true;
    __typename?: true;
  }>;
  /** A release asset contains the content for a release asset. */
  ["ReleaseAsset"]: AliasType<{
    /** The asset's content-type */
    contentType?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The number of times this asset was downloaded */
    downloadCount?: true;
    /** Identifies the URL where you can download the release asset via the browser. */
    downloadUrl?: true;
    id?: true;
    /** Identifies the title of the release asset. */
    name?: true;
    /** Release that the asset is associated with */
    release?: ValueTypes["Release"];
    /** The size (in bytes) of the asset */
    size?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The user that performed the upload */
    uploadedBy?: ValueTypes["User"];
    /** Identifies the URL of the release asset. */
    url?: true;
    __typename?: true;
  }>;
  /** The connection type for ReleaseAsset. */
  ["ReleaseAssetConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ReleaseAssetEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["ReleaseAsset"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ReleaseAssetEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["ReleaseAsset"];
    __typename?: true;
  }>;
  /** The connection type for Release. */
  ["ReleaseConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ReleaseEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Release"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ReleaseEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Release"];
    __typename?: true;
  }>;
  /** Ways in which lists of releases can be ordered upon return. */
  ["ReleaseOrder"]: {
    /** The direction in which to order releases by the specified field. */
    direction: ValueTypes["OrderDirection"];
    /** The field in which to order releases by. */
    field: ValueTypes["ReleaseOrderField"];
  };
  /** Properties by which release connections can be ordered. */
  ["ReleaseOrderField"]: ReleaseOrderField;
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  ["RemovedFromProjectEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    __typename?: true;
  }>;
  /** Autogenerated input type of RemoveOutsideCollaborator */
  ["RemoveOutsideCollaboratorInput"]: {
    /** The ID of the outside collaborator to remove. */
    userId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The ID of the organization to remove the outside collaborator from. */
    organizationId: string;
  };
  /** Autogenerated return type of RemoveOutsideCollaborator */
  ["RemoveOutsideCollaboratorPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The user that was removed as an outside collaborator.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `removedUser` will change from `User!` to `User`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    removedUser?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Autogenerated input type of RemoveReaction */
  ["RemoveReactionInput"]: {
    /** The Node ID of the subject to modify. */
    subjectId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the emoji reaction to remove. */
    content: ValueTypes["ReactionContent"];
  };
  /** Autogenerated return type of RemoveReaction */
  ["RemoveReactionPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The reaction object.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reaction` will change from `Reaction!` to `Reaction`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    reaction?: ValueTypes["Reaction"];
    /** 														The reactable subject.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Reactable!` to `Reactable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subject?: ValueTypes["Reactable"];
    __typename?: true;
  }>;
  /** Autogenerated input type of RemoveStar */
  ["RemoveStarInput"]: {
    /** The Starrable ID to unstar. */
    starrableId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of RemoveStar */
  ["RemoveStarPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The starrable.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `starrable` will change from `Starrable!` to `Starrable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    starrable?: ValueTypes["Starrable"];
    __typename?: true;
  }>;
  /** Represents a 'renamed' event on a given issue or pull request */
  ["RenamedTitleEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the current title of the issue or pull request. */
    currentTitle?: true;
    id?: true;
    /** Identifies the previous title of the issue or pull request. */
    previousTitle?: true;
    /** Subject that was renamed. */
    subject?: ValueTypes["RenamedTitleSubject"];
    __typename?: true;
  }>;
  /** An object which has a renamable title */
  ["RenamedTitleSubject"]: AliasType<{
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    __typename?: true;
  }>;
  /** Represents a 'reopened' event on any `Closable`. */
  ["ReopenedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Object that was reopened. */
    closable?: ValueTypes["Closable"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    __typename?: true;
  }>;
  /** A repository contains the content for a project. */
  ["Repository"]: AliasType<{
    assignableUsers?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserConnection"]
    ];
    /** Returns the code of conduct for this repository */
    codeOfConduct?: ValueTypes["CodeOfConduct"];
    collaborators?: [
      {
        affiliation?: ValueTypes["CollaboratorAffiliation"];
        after?: string;
        before?: string;
        first?: number;
        last?: number;
      },
      ValueTypes["RepositoryCollaboratorConnection"]
    ];
    commitComments?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["CommitCommentConnection"]
    ];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The Ref associated with the repository's default branch. */
    defaultBranchRef?: ValueTypes["Ref"];
    deployKeys?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["DeployKeyConnection"]
    ];
    deployments?: [
      {
        last?: number;
        after?: string;
        before?: string;
        environments?: string[];
        first?: number;
      },
      ValueTypes["DeploymentConnection"]
    ];
    /** The description of the repository. */
    description?: true;
    /** The description of the repository rendered to HTML. */
    descriptionHTML?: true;
    /** The number of kilobytes this repository occupies on disk. */
    diskUsage?: true;
    /** Returns how many forks there are of this repository in the whole network. */
    forkCount?: true;
    forks?: [
      {
        before?: string;
        first?: number;
        isLocked?: boolean;
        last?: number;
        orderBy?: ValueTypes["RepositoryOrder"];
        privacy?: ValueTypes["RepositoryPrivacy"];
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        after?: string;
      },
      ValueTypes["RepositoryConnection"]
    ];
    /** Indicates if the repository has issues feature enabled. */
    hasIssuesEnabled?: true;
    /** Indicates if the repository has wiki feature enabled. */
    hasWikiEnabled?: true;
    /** The repository's URL. */
    homepageUrl?: true;
    id?: true;
    /** Indicates if the repository is unmaintained. */
    isArchived?: true;
    /** Identifies if the repository is a fork. */
    isFork?: true;
    /** Indicates if the repository has been locked or not. */
    isLocked?: true;
    /** Identifies if the repository is a mirror. */
    isMirror?: true;
    /** Identifies if the repository is private. */
    isPrivate?: true;
    issue?: [{ number: number }, ValueTypes["Issue"]];
    issueOrPullRequest?: [{ number: number }, ValueTypes["IssueOrPullRequest"]];
    issues?: [
      {
        before?: string;
        first?: number;
        labels?: string[];
        last?: number;
        orderBy?: ValueTypes["IssueOrder"];
        states?: ValueTypes["IssueState"][];
        after?: string;
      },
      ValueTypes["IssueConnection"]
    ];
    label?: [{ name: string }, ValueTypes["Label"]];
    labels?: [
      {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        query?: string;
      },
      ValueTypes["LabelConnection"]
    ];
    languages?: [
      {
        orderBy?: ValueTypes["LanguageOrder"];
        after?: string;
        before?: string;
        first?: number;
        last?: number;
      },
      ValueTypes["LanguageConnection"]
    ];
    /** The license associated with the repository */
    licenseInfo?: ValueTypes["License"];
    /** The reason the repository has been locked. */
    lockReason?: true;
    mentionableUsers?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["UserConnection"]
    ];
    /** Whether or not PRs are merged with a merge commit on this repository. */
    mergeCommitAllowed?: true;
    milestone?: [{ number: number }, ValueTypes["Milestone"]];
    milestones?: [
      {
        last?: number;
        orderBy?: ValueTypes["MilestoneOrder"];
        states?: ValueTypes["MilestoneState"][];
        after?: string;
        before?: string;
        first?: number;
      },
      ValueTypes["MilestoneConnection"]
    ];
    /** The repository's original mirror URL. */
    mirrorUrl?: true;
    /** The name of the repository. */
    name?: true;
    /** The repository's name with owner. */
    nameWithOwner?: true;
    object?: [
      { expression?: string; oid?: ValueTypes["GitObjectID"] },
      ValueTypes["GitObject"]
    ];
    /** The User owner of the repository. */
    owner?: ValueTypes["RepositoryOwner"];
    /** The repository parent, if this is a fork. */
    parent?: ValueTypes["Repository"];
    /** The primary language of the repository's code. */
    primaryLanguage?: ValueTypes["Language"];
    project?: [{ number: number }, ValueTypes["Project"]];
    projects?: [
      {
        before?: string;
        first?: number;
        last?: number;
        orderBy?: ValueTypes["ProjectOrder"];
        search?: string;
        states?: ValueTypes["ProjectState"][];
        after?: string;
      },
      ValueTypes["ProjectConnection"]
    ];
    /** The HTTP path listing the repository's projects */
    projectsResourcePath?: true;
    /** The HTTP URL listing the repository's projects */
    projectsUrl?: true;
    protectedBranches?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["ProtectedBranchConnection"]
    ];
    pullRequest?: [{ number: number }, ValueTypes["PullRequest"]];
    pullRequests?: [
      {
        after?: string;
        baseRefName?: string;
        headRefName?: string;
        before?: string;
        first?: number;
        labels?: string[];
        last?: number;
        orderBy?: ValueTypes["IssueOrder"];
        states?: ValueTypes["PullRequestState"][];
      },
      ValueTypes["PullRequestConnection"]
    ];
    /** Identifies when the repository was last pushed to. */
    pushedAt?: true;
    /** Whether or not rebase-merging is enabled on this repository. */
    rebaseMergeAllowed?: true;
    ref?: [{ qualifiedName: string }, ValueTypes["Ref"]];
    refs?: [
      {
        direction?: ValueTypes["OrderDirection"];
        first?: number;
        last?: number;
        orderBy?: ValueTypes["RefOrder"];
        refPrefix: string;
        after?: string;
        before?: string;
      },
      ValueTypes["RefConnection"]
    ];
    release?: [{ tagName: string }, ValueTypes["Release"]];
    releases?: [
      {
        last?: number;
        orderBy?: ValueTypes["ReleaseOrder"];
        after?: string;
        before?: string;
        first?: number;
      },
      ValueTypes["ReleaseConnection"]
    ];
    repositoryTopics?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["RepositoryTopicConnection"]
    ];
    /** The HTTP path for this repository */
    resourcePath?: true;
    shortDescriptionHTML?: [{ limit?: number }, true];
    /** Whether or not squash-merging is enabled on this repository. */
    squashMergeAllowed?: true;
    /** The SSH URL to clone this repository */
    sshUrl?: true;
    stargazers?: [
      {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        orderBy?: ValueTypes["StarOrder"];
      },
      ValueTypes["StargazerConnection"]
    ];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this repository */
    url?: true;
    /** Indicates whether the viewer has admin permissions on this repository. */
    viewerCanAdminister?: true;
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects?: true;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: true;
    /** Indicates whether the viewer can update the topics of this repository. */
    viewerCanUpdateTopics?: true;
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred?: true;
    /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
    viewerPermission?: true;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: true;
    watchers?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["UserConnection"]
    ];
    __typename?: true;
  }>;
  /** The affiliation of a user to a repository */
  ["RepositoryAffiliation"]: RepositoryAffiliation;
  /** The connection type for User. */
  ["RepositoryCollaboratorConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["RepositoryCollaboratorEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["User"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a user who is a collaborator of a repository. */
  ["RepositoryCollaboratorEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    node?: ValueTypes["User"];
    /** The permission the user has on the repository. */
    permission?: true;
    __typename?: true;
  }>;
  /** A list of repositories owned by the subject. */
  ["RepositoryConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["RepositoryEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Repository"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    /** The total size in kilobytes of all repositories in the connection. */
    totalDiskUsage?: true;
    __typename?: true;
  }>;
  /** The reason a repository is listed as 'contributed'. */
  ["RepositoryContributionType"]: RepositoryContributionType;
  /** An edge in a connection. */
  ["RepositoryEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** A subset of repository info. */
  ["RepositoryInfo"]: AliasType<{
    /** Indicates if the repository has issues feature enabled. */
    hasIssuesEnabled?: true;
    /** The HTTP path for this repository */
    resourcePath?: true;
    /** The HTTP URL for this repository */
    url?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Indicates if the repository has been locked or not. */
    isLocked?: true;
    /** The description of the repository. */
    description?: true;
    shortDescriptionHTML?: [{ limit?: number }, true];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** Identifies if the repository is a mirror. */
    isMirror?: true;
    /** Identifies if the repository is a fork. */
    isFork?: true;
    /** Identifies when the repository was last pushed to. */
    pushedAt?: true;
    /** The name of the repository. */
    name?: true;
    /** The repository's name with owner. */
    nameWithOwner?: true;
    /** The description of the repository rendered to HTML. */
    descriptionHTML?: true;
    /** Indicates if the repository has wiki feature enabled. */
    hasWikiEnabled?: true;
    /** The repository's URL. */
    homepageUrl?: true;
    /** The User owner of the repository. */
    owner?: ValueTypes["RepositoryOwner"];
    /** The reason the repository has been locked. */
    lockReason?: true;
    /** Identifies if the repository is private. */
    isPrivate?: true;
    /** The repository's original mirror URL. */
    mirrorUrl?: true;
    /** Returns how many forks there are of this repository in the whole network. */
    forkCount?: true;
    /** Indicates if the repository is unmaintained. */
    isArchived?: true;
    /** The license associated with the repository */
    licenseInfo?: ValueTypes["License"];
    ["...on Repository"]: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** An invitation for a user to be added to a repository. */
  ["RepositoryInvitation"]: AliasType<{
    id?: true;
    /** The user who received the invitation. */
    invitee?: ValueTypes["User"];
    /** The user who created the invitation. */
    inviter?: ValueTypes["User"];
    /** The permission granted on this repository by this invitation. */
    permission?: true;
    /** The Repository the user is invited to. */
    repository?: ValueTypes["RepositoryInfo"];
    __typename?: true;
  }>;
  /** The possible reasons a given repository could be in a locked state. */
  ["RepositoryLockReason"]: RepositoryLockReason;
  /** Represents a object that belongs to a repository. */
  ["RepositoryNode"]: AliasType<{
    /** The repository associated with this node. */
    repository?: ValueTypes["Repository"];
    ["...on CommitComment"]: ValueTypes["CommitComment"];
    ["...on CommitCommentThread"]: ValueTypes["CommitCommentThread"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on PullRequestReview"]: ValueTypes["PullRequestReview"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** Ordering options for repository connections */
  ["RepositoryOrder"]: {
    /** The ordering direction. */
    direction: ValueTypes["OrderDirection"];
    /** The field to order repositories by. */
    field: ValueTypes["RepositoryOrderField"];
  };
  /** Properties by which repository connections can be ordered. */
  ["RepositoryOrderField"]: RepositoryOrderField;
  /** Represents an owner of a Repository. */
  ["RepositoryOwner"]: AliasType<{
    /** The username used to login. */
    login?: true;
    pinnedRepositories?: [
      {
        last?: number;
        orderBy?: ValueTypes["RepositoryOrder"];
        privacy?: ValueTypes["RepositoryPrivacy"];
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        after?: string;
        before?: string;
        first?: number;
        isLocked?: boolean;
      },
      ValueTypes["RepositoryConnection"]
    ];
    repositories?: [
      {
        isFork?: boolean;
        orderBy?: ValueTypes["RepositoryOrder"];
        after?: string;
        before?: string;
        isLocked?: boolean;
        last?: number;
        privacy?: ValueTypes["RepositoryPrivacy"];
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        first?: number;
      },
      ValueTypes["RepositoryConnection"]
    ];
    repository?: [{ name: string }, ValueTypes["Repository"]];
    /** The HTTP URL for the owner. */
    resourcePath?: true;
    /** The HTTP URL for the owner. */
    url?: true;
    avatarUrl?: [{ size?: number }, true];
    id?: true;
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** The access level to a repository */
  ["RepositoryPermission"]: RepositoryPermission;
  /** The privacy of a repository */
  ["RepositoryPrivacy"]: RepositoryPrivacy;
  /** A repository-topic connects a repository to a topic. */
  ["RepositoryTopic"]: AliasType<{
    id?: true;
    /** The HTTP path for this repository-topic. */
    resourcePath?: true;
    /** The topic. */
    topic?: ValueTypes["Topic"];
    /** The HTTP URL for this repository-topic. */
    url?: true;
    __typename?: true;
  }>;
  /** The connection type for RepositoryTopic. */
  ["RepositoryTopicConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["RepositoryTopicEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["RepositoryTopic"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["RepositoryTopicEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["RepositoryTopic"];
    __typename?: true;
  }>;
  /** Types that can be requested reviewers. */
  ["RequestedReviewer"]: AliasType<{
    ["...on Team"]: ValueTypes["Team"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Autogenerated input type of RequestReviews */
  ["RequestReviewsInput"]: {
    /** The Node IDs of the team to request. */
    teamIds?: string[];
    /** Add users to the set rather than replace. */
    union?: boolean;
    /** The Node IDs of the user to request. */
    userIds?: string[];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the pull request to modify. */
    pullRequestId: string;
  };
  /** Autogenerated return type of RequestReviews */
  ["RequestReviewsPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The pull request that is getting requests.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequest` will change from `PullRequest!` to `PullRequest`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequest?: ValueTypes["PullRequest"];
    /** 														The edge from the pull request to the requested reviewers.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `requestedReviewersEdge` will change from `UserEdge!` to `UserEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    requestedReviewersEdge?: ValueTypes["UserEdge"];
    __typename?: true;
  }>;
  /** A team or user who has the ability to dismiss a review on a protected branch. */
  ["ReviewDismissalAllowance"]: AliasType<{
    /** The actor that can dismiss. */
    actor?: ValueTypes["ReviewDismissalAllowanceActor"];
    id?: true;
    /** Identifies the protected branch associated with the allowed user or team. */
    protectedBranch?: ValueTypes["ProtectedBranch"];
    __typename?: true;
  }>;
  /** Types that can be an actor. */
  ["ReviewDismissalAllowanceActor"]: AliasType<{
    ["...on Team"]: ValueTypes["Team"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** The connection type for ReviewDismissalAllowance. */
  ["ReviewDismissalAllowanceConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ReviewDismissalAllowanceEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["ReviewDismissalAllowance"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ReviewDismissalAllowanceEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["ReviewDismissalAllowance"];
    __typename?: true;
  }>;
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ["ReviewDismissedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    /** Identifies the message associated with the 'review_dismissed' event. */
    message?: true;
    /** The message associated with the event, rendered to HTML. */
    messageHtml?: true;
    /** Identifies the previous state of the review with the 'review_dismissed' event. */
    previousReviewState?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    /** Identifies the commit which caused the review to become stale. */
    pullRequestCommit?: ValueTypes["PullRequestCommit"];
    /** The HTTP path for this review dismissed event. */
    resourcePath?: true;
    /** Identifies the review associated with the 'review_dismissed' event. */
    review?: ValueTypes["PullRequestReview"];
    /** The HTTP URL for this review dismissed event. */
    url?: true;
    __typename?: true;
  }>;
  /** A request for a user to review a pull request. */
  ["ReviewRequest"]: AliasType<{
    /** Identifies the primary key from the database. */
    databaseId?: true;
    id?: true;
    /** Identifies the pull request associated with this review request. */
    pullRequest?: ValueTypes["PullRequest"];
    /** The reviewer that is requested. */
    requestedReviewer?: ValueTypes["RequestedReviewer"];
    __typename?: true;
  }>;
  /** The connection type for ReviewRequest. */
  ["ReviewRequestConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["ReviewRequestEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["ReviewRequest"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents an 'review_requested' event on a given pull request. */
  ["ReviewRequestedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    /** Identifies the reviewer whose review was requested. */
    requestedReviewer?: ValueTypes["RequestedReviewer"];
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["ReviewRequestEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["ReviewRequest"];
    __typename?: true;
  }>;
  /** Represents an 'review_request_removed' event on a given pull request. */
  ["ReviewRequestRemovedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** PullRequest referenced by event. */
    pullRequest?: ValueTypes["PullRequest"];
    /** Identifies the reviewer whose review request was removed. */
    requestedReviewer?: ValueTypes["RequestedReviewer"];
    __typename?: true;
  }>;
  /** The results of a search. */
  ["SearchResultItem"]: AliasType<{
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on MarketplaceListing"]: ValueTypes["MarketplaceListing"];
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on Repository"]: ValueTypes["Repository"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** A list of results that matched against a search query. */
  ["SearchResultItemConnection"]: AliasType<{
    /** The number of pieces of code that matched the search query. */
    codeCount?: true;
    /** A list of edges. */
    edges?: ValueTypes["SearchResultItemEdge"];
    /** The number of issues that matched the search query. */
    issueCount?: true;
    /** A list of nodes. */
    nodes?: ValueTypes["SearchResultItem"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** The number of repositories that matched the search query. */
    repositoryCount?: true;
    /** The number of users that matched the search query. */
    userCount?: true;
    /** The number of wiki pages that matched the search query. */
    wikiCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["SearchResultItemEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["SearchResultItem"];
    /** Text matches on the result found. */
    textMatches?: ValueTypes["TextMatch"];
    __typename?: true;
  }>;
  /** Represents the individual results of a search. */
  ["SearchType"]: SearchType;
  /** Represents an S/MIME signature on a Commit or Tag. */
  ["SmimeSignature"]: AliasType<{
    /** Email used to sign this object. */
    email?: true;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: true;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: true;
    /** ASCII-armored signature header from object. */
    signature?: true;
    /** GitHub user corresponding to the email signing this commit. */
    signer?: ValueTypes["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: true;
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: true;
    __typename?: true;
  }>;
  /** The connection type for User. */
  ["StargazerConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["StargazerEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["User"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a user that's starred a repository. */
  ["StargazerEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    node?: ValueTypes["User"];
    /** Identifies when the item was starred. */
    starredAt?: true;
    __typename?: true;
  }>;
  /** Ways in which star connections can be ordered. */
  ["StarOrder"]: {
    /** The direction in which to order nodes. */
    direction: ValueTypes["OrderDirection"];
    /** The field in which to order nodes by. */
    field: ValueTypes["StarOrderField"];
  };
  /** Properties by which star connections can be ordered. */
  ["StarOrderField"]: StarOrderField;
  /** Things that can be starred. */
  ["Starrable"]: AliasType<{
    id?: true;
    stargazers?: [
      {
        before?: string;
        first?: number;
        last?: number;
        orderBy?: ValueTypes["StarOrder"];
        after?: string;
      },
      ValueTypes["StargazerConnection"]
    ];
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred?: true;
    ["...on Gist"]: ValueTypes["Gist"];
    ["...on Repository"]: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** The connection type for Repository. */
  ["StarredRepositoryConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["StarredRepositoryEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Repository"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a starred repository. */
  ["StarredRepositoryEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    node?: ValueTypes["Repository"];
    /** Identifies when the item was starred. */
    starredAt?: true;
    __typename?: true;
  }>;
  /** Represents a commit status. */
  ["Status"]: AliasType<{
    /** The commit this status is attached to. */
    commit?: ValueTypes["Commit"];
    context?: [{ name: string }, ValueTypes["StatusContext"]];
    /** The individual status contexts for this commit. */
    contexts?: ValueTypes["StatusContext"];
    id?: true;
    /** The combined commit status. */
    state?: true;
    __typename?: true;
  }>;
  /** Represents an individual commit status context */
  ["StatusContext"]: AliasType<{
    /** This commit this status context is attached to. */
    commit?: ValueTypes["Commit"];
    /** The name of this status context. */
    context?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The actor who created this status context. */
    creator?: ValueTypes["Actor"];
    /** The description for this status context. */
    description?: true;
    id?: true;
    /** The state of this status context. */
    state?: true;
    /** The URL for this status context. */
    targetUrl?: true;
    __typename?: true;
  }>;
  /** The possible commit status states. */
  ["StatusState"]: StatusState;
  /** Autogenerated input type of SubmitPullRequestReview */
  ["SubmitPullRequestReviewInput"]: {
    /** The text field to set on the Pull Request Review. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The event to send to the Pull Request Review. */
    event: ValueTypes["PullRequestReviewEvent"];
    /** The Pull Request Review ID to submit. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of SubmitPullRequestReview */
  ["SubmitPullRequestReviewPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The submitted pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: ValueTypes["PullRequestReview"];
    __typename?: true;
  }>;
  /** Entities that can be subscribed to for web and email notifications. */
  ["Subscribable"]: AliasType<{
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: true;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: true;
    id?: true;
    ["...on Commit"]: ValueTypes["Commit"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on Repository"]: ValueTypes["Repository"];
    ["...on Team"]: ValueTypes["Team"];
    __typename?: true;
  }>;
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  ["SubscribedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Object referenced by event. */
    subscribable?: ValueTypes["Subscribable"];
    __typename?: true;
  }>;
  /** The possible states of a subscription. */
  ["SubscriptionState"]: SubscriptionState;
  /** A suggestion to review a pull request based on a user's commit history and review comments. */
  ["SuggestedReviewer"]: AliasType<{
    /** Is this suggestion based on past commits? */
    isAuthor?: true;
    /** Is this suggestion based on past review comments? */
    isCommenter?: true;
    /** Identifies the user suggested to review the pull request. */
    reviewer?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Represents a Git tag. */
  ["Tag"]: AliasType<{
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: true;
    /** The HTTP path for this Git object */
    commitResourcePath?: true;
    /** The HTTP URL for this Git object */
    commitUrl?: true;
    id?: true;
    /** The Git tag message. */
    message?: true;
    /** The Git tag name. */
    name?: true;
    /** The Git object ID */
    oid?: true;
    /** The Repository the Git object belongs to */
    repository?: ValueTypes["Repository"];
    /** Details about the tag author. */
    tagger?: ValueTypes["GitActor"];
    /** The Git object the tag points to. */
    target?: ValueTypes["GitObject"];
    __typename?: true;
  }>;
  /** A team of users in an organization. */
  ["Team"]: AliasType<{
    ancestors?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["TeamConnection"]
    ];
    avatarUrl?: [{ size?: number }, true];
    childTeams?: [
      {
        after?: string;
        before?: string;
        first?: number;
        immediateOnly?: boolean;
        last?: number;
        orderBy?: ValueTypes["TeamOrder"];
        userLogins?: string[];
      },
      ValueTypes["TeamConnection"]
    ];
    /** The slug corresponding to the organization and team. */
    combinedSlug?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** The description of the team. */
    description?: true;
    /** The HTTP path for editing this team */
    editTeamResourcePath?: true;
    /** The HTTP URL for editing this team */
    editTeamUrl?: true;
    id?: true;
    invitations?: [
      { last?: number; after?: string; before?: string; first?: number },
      ValueTypes["OrganizationInvitationConnection"]
    ];
    members?: [
      {
        membership?: ValueTypes["TeamMembershipType"];
        orderBy?: ValueTypes["TeamMemberOrder"];
        query?: string;
        role?: ValueTypes["TeamMemberRole"];
        after?: string;
        before?: string;
        first?: number;
        last?: number;
      },
      ValueTypes["TeamMemberConnection"]
    ];
    /** The HTTP path for the team' members */
    membersResourcePath?: true;
    /** The HTTP URL for the team' members */
    membersUrl?: true;
    /** The name of the team. */
    name?: true;
    /** The HTTP path creating a new team */
    newTeamResourcePath?: true;
    /** The HTTP URL creating a new team */
    newTeamUrl?: true;
    /** The organization that owns this team. */
    organization?: ValueTypes["Organization"];
    /** The parent team of the team. */
    parentTeam?: ValueTypes["Team"];
    /** The level of privacy the team has. */
    privacy?: true;
    repositories?: [
      {
        orderBy?: ValueTypes["TeamRepositoryOrder"];
        query?: string;
        after?: string;
        before?: string;
        first?: number;
        last?: number;
      },
      ValueTypes["TeamRepositoryConnection"]
    ];
    /** The HTTP path for this team's repositories */
    repositoriesResourcePath?: true;
    /** The HTTP URL for this team's repositories */
    repositoriesUrl?: true;
    /** The HTTP path for this team */
    resourcePath?: true;
    /** The slug corresponding to the team. */
    slug?: true;
    /** The HTTP path for this team's teams */
    teamsResourcePath?: true;
    /** The HTTP URL for this team's teams */
    teamsUrl?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this team */
    url?: true;
    /** Team is adminable by the viewer. */
    viewerCanAdminister?: true;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: true;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: true;
    __typename?: true;
  }>;
  /** The connection type for Team. */
  ["TeamConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["TeamEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Team"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["TeamEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["Team"];
    __typename?: true;
  }>;
  /** The connection type for User. */
  ["TeamMemberConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["TeamMemberEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["User"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a user who is a member of a team. */
  ["TeamMemberEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The HTTP path to the organization's member access page. */
    memberAccessResourcePath?: true;
    /** The HTTP URL to the organization's member access page. */
    memberAccessUrl?: true;
    node?: ValueTypes["User"];
    /** The role the member has on the team. */
    role?: true;
    __typename?: true;
  }>;
  /** Ordering options for team member connections */
  ["TeamMemberOrder"]: {
    /** The field to order team members by. */
    field: ValueTypes["TeamMemberOrderField"];
    /** The ordering direction. */
    direction: ValueTypes["OrderDirection"];
  };
  /** Properties by which team member connections can be ordered. */
  ["TeamMemberOrderField"]: TeamMemberOrderField;
  /** The possible team member roles; either 'maintainer' or 'member'. */
  ["TeamMemberRole"]: TeamMemberRole;
  /** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
  ["TeamMembershipType"]: TeamMembershipType;
  /** Ways in which team connections can be ordered. */
  ["TeamOrder"]: {
    /** The direction in which to order nodes. */
    direction: ValueTypes["OrderDirection"];
    /** The field in which to order nodes by. */
    field: ValueTypes["TeamOrderField"];
  };
  /** Properties by which team connections can be ordered. */
  ["TeamOrderField"]: TeamOrderField;
  /** The possible team privacy values. */
  ["TeamPrivacy"]: TeamPrivacy;
  /** The connection type for Repository. */
  ["TeamRepositoryConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["TeamRepositoryEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["Repository"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** Represents a team repository. */
  ["TeamRepositoryEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    node?: ValueTypes["Repository"];
    /** The permission level the team has on the repository */
    permission?: true;
    __typename?: true;
  }>;
  /** Ordering options for team repository connections */
  ["TeamRepositoryOrder"]: {
    /** The ordering direction. */
    direction: ValueTypes["OrderDirection"];
    /** The field to order repositories by. */
    field: ValueTypes["TeamRepositoryOrderField"];
  };
  /** Properties by which team repository connections can be ordered. */
  ["TeamRepositoryOrderField"]: TeamRepositoryOrderField;
  /** The role of a user on a team. */
  ["TeamRole"]: TeamRole;
  /** A text match within a search result. */
  ["TextMatch"]: AliasType<{
    /** The specific text fragment within the property matched on. */
    fragment?: true;
    /** Highlights within the matched fragment. */
    highlights?: ValueTypes["TextMatchHighlight"];
    /** The property matched on. */
    property?: true;
    __typename?: true;
  }>;
  /** Represents a single highlight in a search result match. */
  ["TextMatchHighlight"]: AliasType<{
    /** The indice in the fragment where the matched text begins. */
    beginIndice?: true;
    /** The indice in the fragment where the matched text ends. */
    endIndice?: true;
    /** The text matched. */
    text?: true;
    __typename?: true;
  }>;
  /** A topic aggregates entities that are related to a subject. */
  ["Topic"]: AliasType<{
    id?: true;
    /** The topic's name. */
    name?: true;
    /** 																A list of related topics, including aliases of this topic, sorted with the most relevant
first. */
    relatedTopics?: ValueTypes["Topic"];
    __typename?: true;
  }>;
  /** Reason that the suggested topic is declined. */
  ["TopicSuggestionDeclineReason"]: TopicSuggestionDeclineReason;
  /** Represents a Git tree. */
  ["Tree"]: AliasType<{
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: true;
    /** The HTTP path for this Git object */
    commitResourcePath?: true;
    /** The HTTP URL for this Git object */
    commitUrl?: true;
    /** A list of tree entries. */
    entries?: ValueTypes["TreeEntry"];
    id?: true;
    /** The Git object ID */
    oid?: true;
    /** The Repository the Git object belongs to */
    repository?: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** Represents a Git tree entry. */
  ["TreeEntry"]: AliasType<{
    /** Entry file mode. */
    mode?: true;
    /** Entry file name. */
    name?: true;
    /** Entry file object. */
    object?: ValueTypes["GitObject"];
    /** Entry file Git object ID. */
    oid?: true;
    /** The Repository the tree entry belongs to */
    repository?: ValueTypes["Repository"];
    /** Entry file type. */
    type?: true;
    __typename?: true;
  }>;
  /** Represents an 'unassigned' event on any assignable object. */
  ["UnassignedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the assignable associated with the event. */
    assignable?: ValueTypes["Assignable"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Identifies the subject (user) who was unassigned. */
    user?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Represents a type that can be retrieved by a URL. */
  ["UniformResourceLocatable"]: AliasType<{
    /** The HTML path to this resource. */
    resourcePath?: true;
    /** The URL to this resource. */
    url?: true;
    ["...on Bot"]: ValueTypes["Bot"];
    ["...on ClosedEvent"]: ValueTypes["ClosedEvent"];
    ["...on CrossReferencedEvent"]: ValueTypes["CrossReferencedEvent"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on MergedEvent"]: ValueTypes["MergedEvent"];
    ["...on Milestone"]: ValueTypes["Milestone"];
    ["...on Organization"]: ValueTypes["Organization"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on PullRequestCommit"]: ValueTypes["PullRequestCommit"];
    ["...on Release"]: ValueTypes["Release"];
    ["...on Repository"]: ValueTypes["Repository"];
    ["...on RepositoryTopic"]: ValueTypes["RepositoryTopic"];
    ["...on ReviewDismissedEvent"]: ValueTypes["ReviewDismissedEvent"];
    ["...on User"]: ValueTypes["User"];
    __typename?: true;
  }>;
  /** Represents an unknown signature on a Commit or Tag. */
  ["UnknownSignature"]: AliasType<{
    /** Email used to sign this object. */
    email?: true;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: true;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: true;
    /** ASCII-armored signature header from object. */
    signature?: true;
    /** GitHub user corresponding to the email signing this commit. */
    signer?: ValueTypes["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: true;
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: true;
    __typename?: true;
  }>;
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  ["UnlabeledEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Identifies the label associated with the 'unlabeled' event. */
    label?: ValueTypes["Label"];
    /** Identifies the `Labelable` associated with the event. */
    labelable?: ValueTypes["Labelable"];
    __typename?: true;
  }>;
  /** Represents an 'unlocked' event on a given issue or pull request. */
  ["UnlockedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Object that was unlocked. */
    lockable?: ValueTypes["Lockable"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UnlockLockable */
  ["UnlockLockableInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** ID of the issue or pull request to be unlocked. */
    lockableId: string;
  };
  /** Autogenerated return type of UnlockLockable */
  ["UnlockLockablePayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** The item that was unlocked. */
    unlockedRecord?: ValueTypes["Lockable"];
    __typename?: true;
  }>;
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  ["UnsubscribedEvent"]: AliasType<{
    /** Identifies the actor who performed the event. */
    actor?: ValueTypes["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    id?: true;
    /** Object referenced by event. */
    subscribable?: ValueTypes["Subscribable"];
    __typename?: true;
  }>;
  /** Entities that can be updated. */
  ["Updatable"]: AliasType<{
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: true;
    ["...on CommitComment"]: ValueTypes["CommitComment"];
    ["...on GistComment"]: ValueTypes["GistComment"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on Project"]: ValueTypes["Project"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on PullRequestReview"]: ValueTypes["PullRequestReview"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** Comments that can be updated. */
  ["UpdatableComment"]: AliasType<{
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: true;
    ["...on CommitComment"]: ValueTypes["CommitComment"];
    ["...on GistComment"]: ValueTypes["GistComment"];
    ["...on Issue"]: ValueTypes["Issue"];
    ["...on IssueComment"]: ValueTypes["IssueComment"];
    ["...on PullRequest"]: ValueTypes["PullRequest"];
    ["...on PullRequestReview"]: ValueTypes["PullRequestReview"];
    ["...on PullRequestReviewComment"]: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UpdateProjectCard */
  ["UpdateProjectCardInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** Whether or not the ProjectCard should be archived */
    isArchived?: boolean;
    /** The note of ProjectCard. */
    note?: string;
    /** The ProjectCard ID to update. */
    projectCardId: string;
  };
  /** Autogenerated return type of UpdateProjectCard */
  ["UpdateProjectCardPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The updated ProjectCard.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectCard` will change from `ProjectCard!` to `ProjectCard`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    projectCard?: ValueTypes["ProjectCard"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UpdateProjectColumn */
  ["UpdateProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of project column. */
    name: string;
    /** The ProjectColumn ID to update. */
    projectColumnId: string;
  };
  /** Autogenerated return type of UpdateProjectColumn */
  ["UpdateProjectColumnPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The updated project column.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectColumn` will change from `ProjectColumn!` to `ProjectColumn`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    projectColumn?: ValueTypes["ProjectColumn"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UpdateProject */
  ["UpdateProjectInput"]: {
    /** The description of project. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of project. */
    name?: string;
    /** The Project ID to update. */
    projectId: string;
    /** Whether the project is public or not. */
    public?: boolean;
    /** Whether the project is open or closed. */
    state?: ValueTypes["ProjectState"];
  };
  /** Autogenerated return type of UpdateProject */
  ["UpdateProjectPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The updated project.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: ValueTypes["Project"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UpdatePullRequestReviewComment */
  ["UpdatePullRequestReviewCommentInput"]: {
    /** The text of the comment. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the comment to modify. */
    pullRequestReviewCommentId: string;
  };
  /** Autogenerated return type of UpdatePullRequestReviewComment */
  ["UpdatePullRequestReviewCommentPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The updated comment.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReviewComment` will change from
  `PullRequestReviewComment!` to `PullRequestReviewComment`.
  **Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReviewComment?: ValueTypes["PullRequestReviewComment"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UpdatePullRequestReview */
  ["UpdatePullRequestReviewInput"]: {
    /** The contents of the pull request review body. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the pull request review to modify. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of UpdatePullRequestReview */
  ["UpdatePullRequestReviewPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The updated pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: ValueTypes["PullRequestReview"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UpdateSubscription */
  ["UpdateSubscriptionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The new state of the subscription. */
    state: ValueTypes["SubscriptionState"];
    /** The Node ID of the subscribable object to modify. */
    subscribableId: string;
  };
  /** Autogenerated return type of UpdateSubscription */
  ["UpdateSubscriptionPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** 														The input subscribable entity.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subscribable` will change from `Subscribable!` to `Subscribable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subscribable?: ValueTypes["Subscribable"];
    __typename?: true;
  }>;
  /** Autogenerated input type of UpdateTopics */
  ["UpdateTopicsInput"]: {
    /** The Node ID of the repository. */
    repositoryId: string;
    /** An array of topic names. */
    topicNames: string[];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of UpdateTopics */
  ["UpdateTopicsPayload"]: AliasType<{
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: true;
    /** Names of the provided topics that are not valid. */
    invalidTopicNames?: true;
    /** 														The updated repository.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `repository` will change from `Repository!` to `Repository`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    repository?: ValueTypes["Repository"];
    __typename?: true;
  }>;
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  ["URI"]: unknown;
  /** A user is an individual's account on GitHub that owns repositories and can make new content. */
  ["User"]: AliasType<{
    avatarUrl?: [{ size?: number }, true];
    /** The user's public profile bio. */
    bio?: true;
    /** The user's public profile bio as HTML. */
    bioHTML?: true;
    commitComments?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["CommitCommentConnection"]
    ];
    /** The user's public profile company. */
    company?: true;
    /** The user's public profile company as HTML. */
    companyHTML?: true;
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the primary key from the database. */
    databaseId?: true;
    /** The user's publicly visible profile email. */
    email?: true;
    followers?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["FollowerConnection"]
    ];
    following?: [
      { after?: string; before?: string; first?: number; last?: number },
      ValueTypes["FollowingConnection"]
    ];
    gist?: [{ name: string }, ValueTypes["Gist"]];
    gistComments?: [
      { first?: number; last?: number; after?: string; before?: string },
      ValueTypes["GistCommentConnection"]
    ];
    gists?: [
      {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        orderBy?: ValueTypes["GistOrder"];
        privacy?: ValueTypes["GistPrivacy"];
      },
      ValueTypes["GistConnection"]
    ];
    id?: true;
    /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
    isBountyHunter?: true;
    /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
    isCampusExpert?: true;
    /** Whether or not this user is a GitHub Developer Program member. */
    isDeveloperProgramMember?: true;
    /** Whether or not this user is a GitHub employee. */
    isEmployee?: true;
    /** Whether or not the user has marked themselves as for hire. */
    isHireable?: true;
    /** Whether or not this user is a site administrator. */
    isSiteAdmin?: true;
    /** Whether or not this user is the viewing user. */
    isViewer?: true;
    issueComments?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["IssueCommentConnection"]
    ];
    issues?: [
      {
        labels?: string[];
        last?: number;
        orderBy?: ValueTypes["IssueOrder"];
        states?: ValueTypes["IssueState"][];
        after?: string;
        before?: string;
        first?: number;
      },
      ValueTypes["IssueConnection"]
    ];
    /** The user's public profile location. */
    location?: true;
    /** The username used to login. */
    login?: true;
    /** The user's public profile name. */
    name?: true;
    organization?: [{ login: string }, ValueTypes["Organization"]];
    organizations?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["OrganizationConnection"]
    ];
    pinnedRepositories?: [
      {
        privacy?: ValueTypes["RepositoryPrivacy"];
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        after?: string;
        before?: string;
        first?: number;
        isLocked?: boolean;
        last?: number;
        orderBy?: ValueTypes["RepositoryOrder"];
      },
      ValueTypes["RepositoryConnection"]
    ];
    publicKeys?: [
      { before?: string; first?: number; last?: number; after?: string },
      ValueTypes["PublicKeyConnection"]
    ];
    pullRequests?: [
      {
        after?: string;
        first?: number;
        headRefName?: string;
        labels?: string[];
        last?: number;
        states?: ValueTypes["PullRequestState"][];
        baseRefName?: string;
        before?: string;
        orderBy?: ValueTypes["IssueOrder"];
      },
      ValueTypes["PullRequestConnection"]
    ];
    repositories?: [
      {
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        privacy?: ValueTypes["RepositoryPrivacy"];
        after?: string;
        before?: string;
        first?: number;
        isFork?: boolean;
        isLocked?: boolean;
        last?: number;
        orderBy?: ValueTypes["RepositoryOrder"];
      },
      ValueTypes["RepositoryConnection"]
    ];
    repositoriesContributedTo?: [
      {
        first?: number;
        orderBy?: ValueTypes["RepositoryOrder"];
        privacy?: ValueTypes["RepositoryPrivacy"];
        after?: string;
        before?: string;
        contributionTypes?: (
          | ValueTypes["RepositoryContributionType"]
          | undefined
        )[];
        includeUserRepositories?: boolean;
        isLocked?: boolean;
        last?: number;
      },
      ValueTypes["RepositoryConnection"]
    ];
    repository?: [{ name: string }, ValueTypes["Repository"]];
    /** The HTTP path for this user */
    resourcePath?: true;
    starredRepositories?: [
      {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        orderBy?: ValueTypes["StarOrder"];
        ownedByViewer?: boolean;
      },
      ValueTypes["StarredRepositoryConnection"]
    ];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    /** The HTTP URL for this user */
    url?: true;
    /** Whether or not the viewer is able to follow the user. */
    viewerCanFollow?: true;
    /** Whether or not this user is followed by the viewer. */
    viewerIsFollowing?: true;
    watching?: [
      {
        affiliations?: (ValueTypes["RepositoryAffiliation"] | undefined)[];
        after?: string;
        before?: string;
        first?: number;
        isLocked?: boolean;
        last?: number;
        orderBy?: ValueTypes["RepositoryOrder"];
        privacy?: ValueTypes["RepositoryPrivacy"];
      },
      ValueTypes["RepositoryConnection"]
    ];
    /** A URL pointing to the user's public website/blog. */
    websiteUrl?: true;
    __typename?: true;
  }>;
  /** The connection type for User. */
  ["UserConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["UserEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["User"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edit on user content */
  ["UserContentEdit"]: AliasType<{
    /** Identifies the date and time when the object was created. */
    createdAt?: true;
    /** Identifies the date and time when the object was deleted. */
    deletedAt?: true;
    /** The actor who deleted this content */
    deletedBy?: ValueTypes["Actor"];
    /** A summary of the changes for this edit */
    diff?: true;
    /** When this content was edited */
    editedAt?: true;
    /** The actor who edited this content */
    editor?: ValueTypes["Actor"];
    id?: true;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: true;
    __typename?: true;
  }>;
  /** A list of edits to content. */
  ["UserContentEditConnection"]: AliasType<{
    /** A list of edges. */
    edges?: ValueTypes["UserContentEditEdge"];
    /** A list of nodes. */
    nodes?: ValueTypes["UserContentEdit"];
    /** Information to aid in pagination. */
    pageInfo?: ValueTypes["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: true;
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["UserContentEditEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["UserContentEdit"];
    __typename?: true;
  }>;
  /** An edge in a connection. */
  ["UserEdge"]: AliasType<{
    /** A cursor for use in pagination. */
    cursor?: true;
    /** The item at the end of the edge. */
    node?: ValueTypes["User"];
    __typename?: true;
  }>;
  /** A valid x509 certificate string */
  ["X509Certificate"]: unknown;
};

export type PartialObjects = {
  /** Autogenerated input type of AcceptTopicSuggestion */
  ["AcceptTopicSuggestionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the suggested topic. */
    name: string;
    /** The Node ID of the repository. */
    repositoryId: string;
  };
  /** Autogenerated return type of AcceptTopicSuggestion */
  ["AcceptTopicSuggestionPayload"]: {
    __typename?: "AcceptTopicSuggestionPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The accepted topic.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `topic` will change from `Topic!` to `Topic`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    topic?: PartialObjects["Topic"];
  };
  /** Represents an object which can take actions on GitHub. Typically a User or Bot. */
  ["Actor"]: {
    /** The username of the actor. */
    login?: string;
    /** The HTTP path for this actor. */
    resourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this actor. */
    url?: PartialObjects["URI"];
    /** A URL pointing to the actor's public avatar. */
    avatarUrl?: PartialObjects["URI"];
  } & (
    | PartialObjects["Bot"]
    | PartialObjects["Organization"]
    | PartialObjects["User"]
  );
  /** Autogenerated input type of AddComment */
  ["AddCommentInput"]: {
    /** The Node ID of the subject to modify. */
    subjectId: string;
    /** The contents of the comment. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of AddComment */
  ["AddCommentPayload"]: {
    __typename?: "AddCommentPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The edge from the subject's comment connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `commentEdge` will change from `IssueCommentEdge!` to `IssueCommentEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    commentEdge?: PartialObjects["IssueCommentEdge"];
    /** 														The subject
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Node!` to `Node`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subject?: PartialObjects["Node"];
    /** 														The edge from the subject's timeline connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `timelineEdge` will change from `IssueTimelineItemEdge!` to `IssueTimelineItemEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    timelineEdge?: PartialObjects["IssueTimelineItemEdge"];
  };
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  ["AddedToProjectEvent"]: {
    __typename?: "AddedToProjectEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
  };
  /** Autogenerated input type of AddProjectCard */
  ["AddProjectCardInput"]: {
    /** The content of the card. Must be a member of the ProjectCardItem union */
    contentId?: string;
    /** The note on the card. */
    note?: string;
    /** The Node ID of the ProjectColumn. */
    projectColumnId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of AddProjectCard */
  ["AddProjectCardPayload"]: {
    __typename?: "AddProjectCardPayload";
    /** 														The edge from the ProjectColumn's card connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `cardEdge` will change from `ProjectCardEdge!` to `ProjectCardEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    cardEdge?: PartialObjects["ProjectCardEdge"];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The ProjectColumn
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectColumn` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    projectColumn?: PartialObjects["Project"];
  };
  /** Autogenerated input type of AddProjectColumn */
  ["AddProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the column. */
    name: string;
    /** The Node ID of the project. */
    projectId: string;
  };
  /** Autogenerated return type of AddProjectColumn */
  ["AddProjectColumnPayload"]: {
    __typename?: "AddProjectColumnPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The edge from the project's column connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `columnEdge` will change from `ProjectColumnEdge!` to `ProjectColumnEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    columnEdge?: PartialObjects["ProjectColumnEdge"];
    /** 														The project
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: PartialObjects["Project"];
  };
  /** Autogenerated input type of AddPullRequestReviewComment */
  ["AddPullRequestReviewCommentInput"]: {
    /** The comment id to reply to. */
    inReplyTo?: string;
    /** The relative path of the file to comment on. */
    path?: string;
    /** The line index in the diff to comment on. */
    position?: number;
    /** The Node ID of the review to modify. */
    pullRequestReviewId: string;
    /** The text of the comment. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The SHA of the commit to comment on. */
    commitOID?: PartialObjects["GitObjectID"];
  };
  /** Autogenerated return type of AddPullRequestReviewComment */
  ["AddPullRequestReviewCommentPayload"]: {
    __typename?: "AddPullRequestReviewCommentPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The newly created comment.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `comment` will change from `PullRequestReviewComment!` to `PullRequestReviewComment`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    comment?: PartialObjects["PullRequestReviewComment"];
    /** 														The edge from the review's comment connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `commentEdge` will change from
  `PullRequestReviewCommentEdge!` to `PullRequestReviewCommentEdge`.
  **Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    commentEdge?: PartialObjects["PullRequestReviewCommentEdge"];
  };
  /** Autogenerated input type of AddPullRequestReview */
  ["AddPullRequestReviewInput"]: {
    /** The Node ID of the pull request to modify. */
    pullRequestId: string;
    /** The contents of the review body comment. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The review line comments. */
    comments?: (PartialObjects["DraftPullRequestReviewComment"] | undefined)[];
    /** The commit OID the review pertains to. */
    commitOID?: PartialObjects["GitObjectID"];
    /** The event to perform on the pull request review. */
    event?: PartialObjects["PullRequestReviewEvent"];
  };
  /** Autogenerated return type of AddPullRequestReview */
  ["AddPullRequestReviewPayload"]: {
    __typename?: "AddPullRequestReviewPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The newly created pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: PartialObjects["PullRequestReview"];
    /** 														The edge from the pull request's review connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reviewEdge` will change from `PullRequestReviewEdge!` to `PullRequestReviewEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    reviewEdge?: PartialObjects["PullRequestReviewEdge"];
  };
  /** Autogenerated input type of AddReaction */
  ["AddReactionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the emoji to react with. */
    content: PartialObjects["ReactionContent"];
    /** The Node ID of the subject to modify. */
    subjectId: string;
  };
  /** Autogenerated return type of AddReaction */
  ["AddReactionPayload"]: {
    __typename?: "AddReactionPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The reaction object.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reaction` will change from `Reaction!` to `Reaction`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    reaction?: PartialObjects["Reaction"];
    /** 														The reactable subject.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Reactable!` to `Reactable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subject?: PartialObjects["Reactable"];
  };
  /** Autogenerated input type of AddStar */
  ["AddStarInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Starrable ID to star. */
    starrableId: string;
  };
  /** Autogenerated return type of AddStar */
  ["AddStarPayload"]: {
    __typename?: "AddStarPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The starrable.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `starrable` will change from `Starrable!` to `Starrable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    starrable?: PartialObjects["Starrable"];
  };
  /** A GitHub App. */
  ["App"]: {
    __typename?: "App";
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The description of the app. */
    description?: string;
    id?: string;
    /** The hex color code, without the leading '#', for the logo background. */
    logoBackgroundColor?: string;
    /** A URL pointing to the app's logo. */
    logoUrl?: PartialObjects["URI"];
    /** The name of the app. */
    name?: string;
    /** A slug based on the name of the app for use in URLs. */
    slug?: string;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The URL to the app's homepage. */
    url?: PartialObjects["URI"];
  };
  /** An object that can have users assigned to it. */
  ["Assignable"]: {
    /** A list of Users assigned to this object. */
    assignees?: PartialObjects["UserConnection"];
  } & (PartialObjects["Issue"] | PartialObjects["PullRequest"]);
  /** Represents an 'assigned' event on any assignable object. */
  ["AssignedEvent"]: {
    __typename?: "AssignedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the assignable associated with the event. */
    assignable?: PartialObjects["Assignable"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Identifies the user who was assigned. */
    user?: PartialObjects["User"];
  };
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  ["BaseRefChangedEvent"]: {
    __typename?: "BaseRefChangedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
  };
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  ["BaseRefForcePushedEvent"]: {
    __typename?: "BaseRefForcePushedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
    afterCommit?: PartialObjects["Commit"];
    /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
    beforeCommit?: PartialObjects["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
    /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
    ref?: PartialObjects["Ref"];
  };
  /** Represents a Git blame. */
  ["Blame"]: {
    __typename?: "Blame";
    /** The list of ranges from a Git blame. */
    ranges?: PartialObjects["BlameRange"][];
  };
  /** Represents a range of information from a Git blame. */
  ["BlameRange"]: {
    __typename?: "BlameRange";
    /** 																Identifies the recency of the change, from 1 (new) to 10 (old). This is
calculated as a 2-quantile and determines the length of distance between the
median age of all the changes in the file and the recency of the current
range's change. */
    age?: number;
    /** Identifies the line author */
    commit?: PartialObjects["Commit"];
    /** The ending line for the range */
    endingLine?: number;
    /** The starting line for the range */
    startingLine?: number;
  };
  /** Represents a Git blob. */
  ["Blob"]: {
    __typename?: "Blob";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: string;
    /** Byte size of Blob object */
    byteSize?: number;
    /** The HTTP path for this Git object */
    commitResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this Git object */
    commitUrl?: PartialObjects["URI"];
    id?: string;
    /** Indicates whether the Blob is binary or text */
    isBinary?: boolean;
    /** Indicates whether the contents is truncated */
    isTruncated?: boolean;
    /** The Git object ID */
    oid?: PartialObjects["GitObjectID"];
    /** The Repository the Git object belongs to */
    repository?: PartialObjects["Repository"];
    /** UTF8 text data or null if the Blob is binary */
    text?: string;
  };
  /** A special type of user which takes actions on behalf of GitHub Apps. */
  ["Bot"]: {
    __typename?: "Bot";
    /** A URL pointing to the GitHub App's public avatar. */
    avatarUrl?: PartialObjects["URI"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
    /** The username of the actor. */
    login?: string;
    /** The HTTP path for this bot */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this bot */
    url?: PartialObjects["URI"];
  };
  /** An object that can be closed */
  ["Closable"]: {
    /** Identifies the date and time when the object was closed. */
    closedAt?: PartialObjects["DateTime"];
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: boolean;
  } & (
    | PartialObjects["Issue"]
    | PartialObjects["Milestone"]
    | PartialObjects["Project"]
    | PartialObjects["PullRequest"]
  );
  /** Represents a 'closed' event on any `Closable`. */
  ["ClosedEvent"]: {
    __typename?: "ClosedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Object that was closed. */
    closable?: PartialObjects["Closable"];
    /** Object which triggered the creation of this event. */
    closer?: PartialObjects["Closer"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** The HTTP path for this closed event. */
    resourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this closed event. */
    url?: PartialObjects["URI"];
  };
  /** The object which triggered a `ClosedEvent`. */
  ["Closer"]: PartialObjects["Commit"] | PartialObjects["PullRequest"];
  /** The Code of Conduct for a repository */
  ["CodeOfConduct"]: {
    __typename?: "CodeOfConduct";
    /** The body of the CoC */
    body?: string;
    /** The key for the CoC */
    key?: string;
    /** The formal name of the CoC */
    name?: string;
    /** The path to the CoC */
    url?: PartialObjects["URI"];
  };
  /** Collaborators affiliation level with a subject. */
  ["CollaboratorAffiliation"]: CollaboratorAffiliation;
  /** Represents a comment. */
  ["Comment"]: {
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The body rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** The body as Markdown. */
    body?: string;
    id?: string;
    /** The body rendered to text. */
    bodyText?: string;
    /** The actor who edited the comment. */
    editor?: PartialObjects["Actor"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** Author's association with the subject of the comment. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
  } & (
    | PartialObjects["CommitComment"]
    | PartialObjects["GistComment"]
    | PartialObjects["Issue"]
    | PartialObjects["IssueComment"]
    | PartialObjects["PullRequest"]
    | PartialObjects["PullRequestReview"]
    | PartialObjects["PullRequestReviewComment"]
  );
  /** A comment author association with repository. */
  ["CommentAuthorAssociation"]: CommentAuthorAssociation;
  /** The possible errors that will prevent a user from updating a comment. */
  ["CommentCannotUpdateReason"]: CommentCannotUpdateReason;
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  ["CommentDeletedEvent"]: {
    __typename?: "CommentDeletedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
  };
  /** Represents a Git commit. */
  ["Commit"]: {
    __typename?: "Commit";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: string;
    /** The number of additions in this commit. */
    additions?: number;
    /** Authorship details of the commit. */
    author?: PartialObjects["GitActor"];
    /** Check if the committer and the author match. */
    authoredByCommitter?: boolean;
    /** The datetime when this commit was authored. */
    authoredDate?: PartialObjects["DateTime"];
    /** Fetches `git blame` information. */
    blame?: PartialObjects["Blame"];
    /** The number of changed files in this commit. */
    changedFiles?: number;
    /** Comments made on the commit. */
    comments?: PartialObjects["CommitCommentConnection"];
    /** The HTTP path for this Git object */
    commitResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this Git object */
    commitUrl?: PartialObjects["URI"];
    /** The datetime when this commit was committed. */
    committedDate?: PartialObjects["DateTime"];
    /** Check if commited via GitHub web UI. */
    committedViaWeb?: boolean;
    /** Committership details of the commit. */
    committer?: PartialObjects["GitActor"];
    /** The number of deletions in this commit. */
    deletions?: number;
    /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
    history?: PartialObjects["CommitHistoryConnection"];
    id?: string;
    /** The Git commit message */
    message?: string;
    /** The Git commit message body */
    messageBody?: string;
    /** The commit message body rendered to HTML. */
    messageBodyHTML?: PartialObjects["HTML"];
    /** The Git commit message headline */
    messageHeadline?: string;
    /** The commit message headline rendered to HTML. */
    messageHeadlineHTML?: PartialObjects["HTML"];
    /** The Git object ID */
    oid?: PartialObjects["GitObjectID"];
    /** The parents of a commit. */
    parents?: PartialObjects["CommitConnection"];
    /** The datetime when this commit was pushed. */
    pushedDate?: PartialObjects["DateTime"];
    /** The Repository this commit belongs to */
    repository?: PartialObjects["Repository"];
    /** The HTTP path for this commit */
    resourcePath?: PartialObjects["URI"];
    /** Commit signing information, if present. */
    signature?: PartialObjects["GitSignature"];
    /** Status information for this commit */
    status?: PartialObjects["Status"];
    /** 																Returns a URL to download a tarball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes. */
    tarballUrl?: PartialObjects["URI"];
    /** Commit's root Tree */
    tree?: PartialObjects["Tree"];
    /** The HTTP path for the tree of this commit */
    treeResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for the tree of this commit */
    treeUrl?: PartialObjects["URI"];
    /** The HTTP URL for this commit */
    url?: PartialObjects["URI"];
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: boolean;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: PartialObjects["SubscriptionState"];
    /** 																Returns a URL to download a zipball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes. */
    zipballUrl?: PartialObjects["URI"];
  };
  /** Specifies an author for filtering Git commits. */
  ["CommitAuthor"]: {
    /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
    emails?: string[];
    /** 																ID of a User to filter by. If non-null, only commits authored by this user
will be returned. This field takes precedence over emails. */
    id?: string;
  };
  /** Represents a comment on a given Commit. */
  ["CommitComment"]: {
    __typename?: "CommitComment";
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
    /** Identifies the comment body. */
    body?: string;
    /** Identifies the comment body rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** The body rendered to text. */
    bodyText?: string;
    /** Identifies the commit associated with the comment, if the commit exists. */
    commit?: PartialObjects["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The actor who edited the comment. */
    editor?: PartialObjects["Actor"];
    id?: string;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** Identifies the file path associated with the comment. */
    path?: string;
    /** Identifies the line position associated with the comment. */
    position?: number;
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: PartialObjects["ReactionGroup"][];
    /** A list of Reactions left on the Issue. */
    reactions?: PartialObjects["ReactionConnection"];
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path permalink for this commit comment. */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL permalink for this commit comment. */
    url?: PartialObjects["URI"];
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: boolean;
    /** Can user react to this subject */
    viewerCanReact?: boolean;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
  };
  /** The connection type for CommitComment. */
  ["CommitCommentConnection"]: {
    __typename?: "CommitCommentConnection";
    /** A list of edges. */
    edges?: (PartialObjects["CommitCommentEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["CommitComment"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["CommitCommentEdge"]: {
    __typename?: "CommitCommentEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["CommitComment"];
  };
  /** A thread of comments on a commit. */
  ["CommitCommentThread"]: {
    __typename?: "CommitCommentThread";
    /** The comments that exist in this thread. */
    comments?: PartialObjects["CommitCommentConnection"];
    /** The commit the comments were made on. */
    commit?: PartialObjects["Commit"];
    id?: string;
    /** The file the comments were made on. */
    path?: string;
    /** The position in the diff for the commit that the comment was made on. */
    position?: number;
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
  };
  /** The connection type for Commit. */
  ["CommitConnection"]: {
    __typename?: "CommitConnection";
    /** A list of edges. */
    edges?: (PartialObjects["CommitEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Commit"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["CommitEdge"]: {
    __typename?: "CommitEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Commit"];
  };
  /** The connection type for Commit. */
  ["CommitHistoryConnection"]: {
    __typename?: "CommitHistoryConnection";
    edges?: (PartialObjects["CommitEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Commit"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ["ConvertedNoteToIssueEvent"]: {
    __typename?: "ConvertedNoteToIssueEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
  };
  /** Autogenerated input type of CreateProject */
  ["CreateProjectInput"]: {
    /** The description of project. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of project. */
    name: string;
    /** The owner ID to create the project under. */
    ownerId: string;
  };
  /** Autogenerated return type of CreateProject */
  ["CreateProjectPayload"]: {
    __typename?: "CreateProjectPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The new project.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: PartialObjects["Project"];
  };
  /** Represents a mention made by one issue or pull request to another. */
  ["CrossReferencedEvent"]: {
    __typename?: "CrossReferencedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Reference originated in a different repository. */
    isCrossRepository?: boolean;
    /** Identifies when the reference was made. */
    referencedAt?: PartialObjects["DateTime"];
    /** The HTTP path for this pull request. */
    resourcePath?: PartialObjects["URI"];
    /** Issue or pull request that made the reference. */
    source?: PartialObjects["ReferencedSubject"];
    /** Issue or pull request to which the reference was made. */
    target?: PartialObjects["ReferencedSubject"];
    /** The HTTP URL for this pull request. */
    url?: PartialObjects["URI"];
    /** Checks if the target will be closed when the source is merged. */
    willCloseTarget?: boolean;
  };
  /** An ISO-8601 encoded UTC date string. */
  ["DateTime"]: any;
  /** Autogenerated input type of DeclineTopicSuggestion */
  ["DeclineTopicSuggestionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the suggested topic. */
    name: string;
    /** The reason why the suggested topic is declined. */
    reason: PartialObjects["TopicSuggestionDeclineReason"];
    /** The Node ID of the repository. */
    repositoryId: string;
  };
  /** Autogenerated return type of DeclineTopicSuggestion */
  ["DeclineTopicSuggestionPayload"]: {
    __typename?: "DeclineTopicSuggestionPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The declined topic.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `topic` will change from `Topic!` to `Topic`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    topic?: PartialObjects["Topic"];
  };
  /** Entities that can be deleted. */
  ["Deletable"]: {
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: boolean;
  } & (
    | PartialObjects["CommitComment"]
    | PartialObjects["GistComment"]
    | PartialObjects["IssueComment"]
    | PartialObjects["PullRequestReview"]
    | PartialObjects["PullRequestReviewComment"]
  );
  /** Autogenerated input type of DeleteProjectCard */
  ["DeleteProjectCardInput"]: {
    /** The id of the card to delete. */
    cardId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of DeleteProjectCard */
  ["DeleteProjectCardPayload"]: {
    __typename?: "DeleteProjectCardPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The column the deleted card was in.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `column` will change from `ProjectColumn!` to `ProjectColumn`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    column?: PartialObjects["ProjectColumn"];
    /** 														The deleted card ID.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `deletedCardId` will change from `ID!` to `ID`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    deletedCardId?: string;
  };
  /** Autogenerated input type of DeleteProjectColumn */
  ["DeleteProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The id of the column to delete. */
    columnId: string;
  };
  /** Autogenerated return type of DeleteProjectColumn */
  ["DeleteProjectColumnPayload"]: {
    __typename?: "DeleteProjectColumnPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The deleted column ID.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `deletedColumnId` will change from `ID!` to `ID`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    deletedColumnId?: string;
    /** 														The project the deleted column was in.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: PartialObjects["Project"];
  };
  /** Autogenerated input type of DeleteProject */
  ["DeleteProjectInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Project ID to update. */
    projectId: string;
  };
  /** Autogenerated return type of DeleteProject */
  ["DeleteProjectPayload"]: {
    __typename?: "DeleteProjectPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The repository or organization the project was removed from.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `owner` will change from `ProjectOwner!` to `ProjectOwner`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    owner?: PartialObjects["ProjectOwner"];
  };
  /** Autogenerated input type of DeletePullRequestReview */
  ["DeletePullRequestReviewInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the pull request review to delete. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of DeletePullRequestReview */
  ["DeletePullRequestReviewPayload"]: {
    __typename?: "DeletePullRequestReviewPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The deleted pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: PartialObjects["PullRequestReview"];
  };
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  ["DemilestonedEvent"]: {
    __typename?: "DemilestonedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Identifies the milestone title associated with the 'demilestoned' event. */
    milestoneTitle?: string;
    /** Object referenced by event. */
    subject?: PartialObjects["MilestoneItem"];
  };
  /** Represents a 'deployed' event on a given pull request. */
  ["DeployedEvent"]: {
    __typename?: "DeployedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The deployment associated with the 'deployed' event. */
    deployment?: PartialObjects["Deployment"];
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
    /** The ref associated with the 'deployed' event. */
    ref?: PartialObjects["Ref"];
  };
  /** A repository deploy key. */
  ["DeployKey"]: {
    __typename?: "DeployKey";
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** The deploy key. */
    key?: string;
    /** Whether or not the deploy key is read only. */
    readOnly?: boolean;
    /** The deploy key title. */
    title?: string;
    /** Whether or not the deploy key has been verified. */
    verified?: boolean;
  };
  /** The connection type for DeployKey. */
  ["DeployKeyConnection"]: {
    __typename?: "DeployKeyConnection";
    /** A list of edges. */
    edges?: (PartialObjects["DeployKeyEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["DeployKey"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["DeployKeyEdge"]: {
    __typename?: "DeployKeyEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["DeployKey"];
  };
  /** Represents triggered deployment instance. */
  ["Deployment"]: {
    __typename?: "Deployment";
    /** Identifies the commit sha of the deployment. */
    commit?: PartialObjects["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the actor who triggered the deployment. */
    creator?: PartialObjects["Actor"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The deployment description. */
    description?: string;
    /** The environment to which this deployment was made. */
    environment?: string;
    id?: string;
    /** The latest status of this deployment. */
    latestStatus?: PartialObjects["DeploymentStatus"];
    /** Extra information that a deployment system might need. */
    payload?: string;
    /** Identifies the Ref of the deployment, if the deployment was created by ref. */
    ref?: PartialObjects["Ref"];
    /** Identifies the repository associated with the deployment. */
    repository?: PartialObjects["Repository"];
    /** The current state of the deployment. */
    state?: PartialObjects["DeploymentState"];
    /** A list of statuses associated with the deployment. */
    statuses?: PartialObjects["DeploymentStatusConnection"];
    /** The deployment task. */
    task?: string;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
  };
  /** The connection type for Deployment. */
  ["DeploymentConnection"]: {
    __typename?: "DeploymentConnection";
    /** A list of edges. */
    edges?: (PartialObjects["DeploymentEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Deployment"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["DeploymentEdge"]: {
    __typename?: "DeploymentEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Deployment"];
  };
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  ["DeploymentEnvironmentChangedEvent"]: {
    __typename?: "DeploymentEnvironmentChangedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The deployment status that updated the deployment environment. */
    deploymentStatus?: PartialObjects["DeploymentStatus"];
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
  };
  /** The possible states in which a deployment can be. */
  ["DeploymentState"]: DeploymentState;
  /** Describes the status of a given deployment attempt. */
  ["DeploymentStatus"]: {
    __typename?: "DeploymentStatus";
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the actor who triggered the deployment. */
    creator?: PartialObjects["Actor"];
    /** Identifies the deployment associated with status. */
    deployment?: PartialObjects["Deployment"];
    /** Identifies the description of the deployment. */
    description?: string;
    /** Identifies the environment URL of the deployment. */
    environmentUrl?: PartialObjects["URI"];
    id?: string;
    /** Identifies the log URL of the deployment. */
    logUrl?: PartialObjects["URI"];
    /** Identifies the current state of the deployment. */
    state?: PartialObjects["DeploymentStatusState"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
  };
  /** The connection type for DeploymentStatus. */
  ["DeploymentStatusConnection"]: {
    __typename?: "DeploymentStatusConnection";
    /** A list of edges. */
    edges?: (PartialObjects["DeploymentStatusEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["DeploymentStatus"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["DeploymentStatusEdge"]: {
    __typename?: "DeploymentStatusEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["DeploymentStatus"];
  };
  /** The possible states for a deployment status. */
  ["DeploymentStatusState"]: DeploymentStatusState;
  /** Autogenerated input type of DismissPullRequestReview */
  ["DismissPullRequestReviewInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The contents of the pull request review dismissal message. */
    message: string;
    /** The Node ID of the pull request review to modify. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of DismissPullRequestReview */
  ["DismissPullRequestReviewPayload"]: {
    __typename?: "DismissPullRequestReviewPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The dismissed pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: PartialObjects["PullRequestReview"];
  };
  /** Specifies a review comment to be left with a Pull Request Review. */
  ["DraftPullRequestReviewComment"]: {
    /** Path to the file being commented on. */
    path: string;
    /** Position in the file to leave a comment on. */
    position: number;
    /** Body of the comment to leave. */
    body: string;
  };
  /** An external identity provisioned by SAML SSO or SCIM. */
  ["ExternalIdentity"]: {
    __typename?: "ExternalIdentity";
    /** The GUID for this identity */
    guid?: string;
    id?: string;
    /** Organization invitation for this SCIM-provisioned external identity */
    organizationInvitation?: PartialObjects["OrganizationInvitation"];
    /** SAML Identity attributes */
    samlIdentity?: PartialObjects["ExternalIdentitySamlAttributes"];
    /** SCIM Identity attributes */
    scimIdentity?: PartialObjects["ExternalIdentityScimAttributes"];
    /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
    user?: PartialObjects["User"];
  };
  /** The connection type for ExternalIdentity. */
  ["ExternalIdentityConnection"]: {
    __typename?: "ExternalIdentityConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ExternalIdentityEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["ExternalIdentity"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ExternalIdentityEdge"]: {
    __typename?: "ExternalIdentityEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["ExternalIdentity"];
  };
  /** SAML attributes for the External Identity */
  ["ExternalIdentitySamlAttributes"]: {
    __typename?: "ExternalIdentitySamlAttributes";
    /** The NameID of the SAML identity */
    nameId?: string;
  };
  /** SCIM attributes for the External Identity */
  ["ExternalIdentityScimAttributes"]: {
    __typename?: "ExternalIdentityScimAttributes";
    /** The userName of the SCIM identity */
    username?: string;
  };
  /** The connection type for User. */
  ["FollowerConnection"]: {
    __typename?: "FollowerConnection";
    /** A list of edges. */
    edges?: (PartialObjects["UserEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["User"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** The connection type for User. */
  ["FollowingConnection"]: {
    __typename?: "FollowingConnection";
    /** A list of edges. */
    edges?: (PartialObjects["UserEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["User"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** A Gist. */
  ["Gist"]: {
    __typename?: "Gist";
    /** A list of comments associated with the gist */
    comments?: PartialObjects["GistCommentConnection"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The gist description. */
    description?: string;
    id?: string;
    /** Whether the gist is public or not. */
    isPublic?: boolean;
    /** The gist name. */
    name?: string;
    /** The gist owner. */
    owner?: PartialObjects["RepositoryOwner"];
    /** Identifies when the gist was last pushed to. */
    pushedAt?: PartialObjects["DateTime"];
    /** A list of users who have starred this starrable. */
    stargazers?: PartialObjects["StargazerConnection"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred?: boolean;
  };
  /** Represents a comment on an Gist. */
  ["GistComment"]: {
    __typename?: "GistComment";
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** Author's association with the gist. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
    /** Identifies the comment body. */
    body?: string;
    /** The comment body rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** The body rendered to text. */
    bodyText?: string;
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The actor who edited the comment. */
    editor?: PartialObjects["Actor"];
    /** The associated gist. */
    gist?: PartialObjects["Gist"];
    id?: string;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: boolean;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
  };
  /** The connection type for GistComment. */
  ["GistCommentConnection"]: {
    __typename?: "GistCommentConnection";
    /** A list of edges. */
    edges?: (PartialObjects["GistCommentEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["GistComment"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["GistCommentEdge"]: {
    __typename?: "GistCommentEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["GistComment"];
  };
  /** The connection type for Gist. */
  ["GistConnection"]: {
    __typename?: "GistConnection";
    /** A list of edges. */
    edges?: (PartialObjects["GistEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Gist"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["GistEdge"]: {
    __typename?: "GistEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Gist"];
  };
  /** Ordering options for gist connections */
  ["GistOrder"]: {
    /** The ordering direction. */
    direction: PartialObjects["OrderDirection"];
    /** The field to order repositories by. */
    field: PartialObjects["GistOrderField"];
  };
  /** Properties by which gist connections can be ordered. */
  ["GistOrderField"]: GistOrderField;
  /** The privacy of a Gist */
  ["GistPrivacy"]: GistPrivacy;
  /** Represents an actor in a Git commit (ie. an author or committer). */
  ["GitActor"]: {
    __typename?: "GitActor";
    /** A URL pointing to the author's public avatar. */
    avatarUrl?: PartialObjects["URI"];
    /** The timestamp of the Git action (authoring or committing). */
    date?: PartialObjects["GitTimestamp"];
    /** The email in the Git commit. */
    email?: string;
    /** The name in the Git commit. */
    name?: string;
    /** The GitHub user corresponding to the email field. Null if no such user exists. */
    user?: PartialObjects["User"];
  };
  /** Represents information about the GitHub instance. */
  ["GitHubMetadata"]: {
    __typename?: "GitHubMetadata";
    /** Returns a String that's a SHA of `github-services` */
    gitHubServicesSha?: PartialObjects["GitObjectID"];
    /** IP addresses that users connect to for git operations */
    gitIpAddresses?: string[];
    /** IP addresses that service hooks are sent from */
    hookIpAddresses?: string[];
    /** IP addresses that the importer connects from */
    importerIpAddresses?: string[];
    /** Whether or not users are verified */
    isPasswordAuthenticationVerifiable?: boolean;
    /** IP addresses for GitHub Pages' A records */
    pagesIpAddresses?: string[];
  };
  /** Represents a Git object. */
  ["GitObject"]: {
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: string;
    /** The HTTP path for this Git object */
    commitResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this Git object */
    commitUrl?: PartialObjects["URI"];
    id?: string;
    /** The Git object ID */
    oid?: PartialObjects["GitObjectID"];
    /** The Repository the Git object belongs to */
    repository?: PartialObjects["Repository"];
  } & (
    | PartialObjects["Blob"]
    | PartialObjects["Commit"]
    | PartialObjects["Tag"]
    | PartialObjects["Tree"]
  );
  /** A Git object ID. */
  ["GitObjectID"]: any;
  /** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
  ["GitSignature"]: {
    /** GitHub user corresponding to the email signing this commit. */
    signer?: PartialObjects["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: PartialObjects["GitSignatureState"];
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: boolean;
    /** Email used to sign this object. */
    email?: string;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: boolean;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: string;
    /** ASCII-armored signature header from object. */
    signature?: string;
  } & (
    | PartialObjects["GpgSignature"]
    | PartialObjects["SmimeSignature"]
    | PartialObjects["UnknownSignature"]
  );
  /** The state of a Git signature. */
  ["GitSignatureState"]: GitSignatureState;
  /** Git SSH string */
  ["GitSSHRemote"]: any;
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  ["GitTimestamp"]: any;
  /** Represents a GPG signature on a Commit or Tag. */
  ["GpgSignature"]: {
    __typename?: "GpgSignature";
    /** Email used to sign this object. */
    email?: string;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: boolean;
    /** Hex-encoded ID of the key that signed this object. */
    keyId?: string;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: string;
    /** ASCII-armored signature header from object. */
    signature?: string;
    /** GitHub user corresponding to the email signing this commit. */
    signer?: PartialObjects["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: PartialObjects["GitSignatureState"];
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: boolean;
  };
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  ["HeadRefDeletedEvent"]: {
    __typename?: "HeadRefDeletedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the Ref associated with the `head_ref_deleted` event. */
    headRef?: PartialObjects["Ref"];
    /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
    headRefName?: string;
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
  };
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  ["HeadRefForcePushedEvent"]: {
    __typename?: "HeadRefForcePushedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
    afterCommit?: PartialObjects["Commit"];
    /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
    beforeCommit?: PartialObjects["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
    /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
    ref?: PartialObjects["Ref"];
  };
  /** Represents a 'head_ref_restored' event on a given pull request. */
  ["HeadRefRestoredEvent"]: {
    __typename?: "HeadRefRestoredEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
  };
  /** A string containing HTML code. */
  ["HTML"]: any;
  /** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
  ["Issue"]: {
    __typename?: "Issue";
    /** Reason that the conversation was locked. */
    activeLockReason?: PartialObjects["LockReason"];
    /** A list of Users assigned to this object. */
    assignees?: PartialObjects["UserConnection"];
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
    /** Identifies the body of the issue. */
    body?: string;
    /** Identifies the body of the issue rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** Identifies the body of the issue rendered to text. */
    bodyText?: string;
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: boolean;
    /** Identifies the date and time when the object was closed. */
    closedAt?: PartialObjects["DateTime"];
    /** A list of comments associated with the Issue. */
    comments?: PartialObjects["IssueCommentConnection"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The actor who edited the comment. */
    editor?: PartialObjects["Actor"];
    id?: string;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** A list of labels associated with the object. */
    labels?: PartialObjects["LabelConnection"];
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** `true` if the object is locked */
    locked?: boolean;
    /** Identifies the milestone associated with the issue. */
    milestone?: PartialObjects["Milestone"];
    /** Identifies the issue number. */
    number?: number;
    /** A list of Users that are participating in the Issue conversation. */
    participants?: PartialObjects["UserConnection"];
    /** List of project cards associated with this issue. */
    projectCards?: PartialObjects["ProjectCardConnection"];
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: PartialObjects["ReactionGroup"][];
    /** A list of Reactions left on the Issue. */
    reactions?: PartialObjects["ReactionConnection"];
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path for this issue */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the state of the issue. */
    state?: PartialObjects["IssueState"];
    /** A list of events, comments, commits, etc. associated with the issue. */
    timeline?: PartialObjects["IssueTimelineConnection"];
    /** Identifies the issue title. */
    title?: string;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this issue */
    url?: PartialObjects["URI"];
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Can user react to this subject */
    viewerCanReact?: boolean;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: boolean;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: PartialObjects["SubscriptionState"];
  };
  /** Represents a comment on an Issue. */
  ["IssueComment"]: {
    __typename?: "IssueComment";
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
    /** The body as Markdown. */
    body?: string;
    /** The body rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** The body rendered to text. */
    bodyText?: string;
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The actor who edited the comment. */
    editor?: PartialObjects["Actor"];
    id?: string;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** Identifies the issue associated with the comment. */
    issue?: PartialObjects["Issue"];
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** 																Returns the pull request associated with the comment, if this comment was made on a
pull request. */
    pullRequest?: PartialObjects["PullRequest"];
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: PartialObjects["ReactionGroup"][];
    /** A list of Reactions left on the Issue. */
    reactions?: PartialObjects["ReactionConnection"];
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path for this issue comment */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this issue comment */
    url?: PartialObjects["URI"];
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: boolean;
    /** Can user react to this subject */
    viewerCanReact?: boolean;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
  };
  /** The connection type for IssueComment. */
  ["IssueCommentConnection"]: {
    __typename?: "IssueCommentConnection";
    /** A list of edges. */
    edges?: (PartialObjects["IssueCommentEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["IssueComment"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["IssueCommentEdge"]: {
    __typename?: "IssueCommentEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["IssueComment"];
  };
  /** The connection type for Issue. */
  ["IssueConnection"]: {
    __typename?: "IssueConnection";
    /** A list of edges. */
    edges?: (PartialObjects["IssueEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Issue"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["IssueEdge"]: {
    __typename?: "IssueEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Issue"];
  };
  /** Ways in which lists of issues can be ordered upon return. */
  ["IssueOrder"]: {
    /** The direction in which to order issues by the specified field. */
    direction: PartialObjects["OrderDirection"];
    /** The field in which to order issues by. */
    field: PartialObjects["IssueOrderField"];
  };
  /** Properties by which issue connections can be ordered. */
  ["IssueOrderField"]: IssueOrderField;
  /** Used for return value of Repository.issueOrPullRequest. */
  ["IssueOrPullRequest"]:
    | PartialObjects["Issue"]
    | PartialObjects["PullRequest"];
  /** The possible states of an issue. */
  ["IssueState"]: IssueState;
  /** The connection type for IssueTimelineItem. */
  ["IssueTimelineConnection"]: {
    __typename?: "IssueTimelineConnection";
    /** A list of edges. */
    edges?: (PartialObjects["IssueTimelineItemEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["IssueTimelineItem"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An item in an issue timeline */
  ["IssueTimelineItem"]:
    | PartialObjects["AssignedEvent"]
    | PartialObjects["ClosedEvent"]
    | PartialObjects["Commit"]
    | PartialObjects["CrossReferencedEvent"]
    | PartialObjects["DemilestonedEvent"]
    | PartialObjects["IssueComment"]
    | PartialObjects["LabeledEvent"]
    | PartialObjects["LockedEvent"]
    | PartialObjects["MilestonedEvent"]
    | PartialObjects["ReferencedEvent"]
    | PartialObjects["RenamedTitleEvent"]
    | PartialObjects["ReopenedEvent"]
    | PartialObjects["SubscribedEvent"]
    | PartialObjects["UnassignedEvent"]
    | PartialObjects["UnlabeledEvent"]
    | PartialObjects["UnlockedEvent"]
    | PartialObjects["UnsubscribedEvent"];
  /** An edge in a connection. */
  ["IssueTimelineItemEdge"]: {
    __typename?: "IssueTimelineItemEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["IssueTimelineItem"];
  };
  /** A label for categorizing Issues or Milestones with a given Repository. */
  ["Label"]: {
    __typename?: "Label";
    /** Identifies the label color. */
    color?: string;
    /** Identifies the date and time when the label was created. */
    createdAt?: PartialObjects["DateTime"];
    /** A brief description of this label. */
    description?: string;
    id?: string;
    /** Indicates whether or not this is a default label. */
    isDefault?: boolean;
    /** A list of issues associated with this label. */
    issues?: PartialObjects["IssueConnection"];
    /** Identifies the label name. */
    name?: string;
    /** A list of pull requests associated with this label. */
    pullRequests?: PartialObjects["PullRequestConnection"];
    /** The repository associated with this label. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path for this label. */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the date and time when the label was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this label. */
    url?: PartialObjects["URI"];
  };
  /** An object that can have labels assigned to it. */
  ["Labelable"]: {
    /** A list of labels associated with the object. */
    labels?: PartialObjects["LabelConnection"];
  } & (PartialObjects["Issue"] | PartialObjects["PullRequest"]);
  /** The connection type for Label. */
  ["LabelConnection"]: {
    __typename?: "LabelConnection";
    /** A list of edges. */
    edges?: (PartialObjects["LabelEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Label"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a 'labeled' event on a given issue or pull request. */
  ["LabeledEvent"]: {
    __typename?: "LabeledEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Identifies the label associated with the 'labeled' event. */
    label?: PartialObjects["Label"];
    /** Identifies the `Labelable` associated with the event. */
    labelable?: PartialObjects["Labelable"];
  };
  /** An edge in a connection. */
  ["LabelEdge"]: {
    __typename?: "LabelEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Label"];
  };
  /** Represents a given language found in repositories. */
  ["Language"]: {
    __typename?: "Language";
    /** The color defined for the current language. */
    color?: string;
    id?: string;
    /** The name of the current language. */
    name?: string;
  };
  /** A list of languages associated with the parent. */
  ["LanguageConnection"]: {
    __typename?: "LanguageConnection";
    /** A list of edges. */
    edges?: (PartialObjects["LanguageEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Language"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
    /** The total size in bytes of files written in that language. */
    totalSize?: number;
  };
  /** Represents the language of a repository. */
  ["LanguageEdge"]: {
    __typename?: "LanguageEdge";
    cursor?: string;
    node?: PartialObjects["Language"];
    /** The number of bytes of code written in the language. */
    size?: number;
  };
  /** Ordering options for language connections. */
  ["LanguageOrder"]: {
    /** The ordering direction. */
    direction: PartialObjects["OrderDirection"];
    /** The field to order languages by. */
    field: PartialObjects["LanguageOrderField"];
  };
  /** Properties by which language connections can be ordered. */
  ["LanguageOrderField"]: LanguageOrderField;
  /** A repository's open source license */
  ["License"]: {
    __typename?: "License";
    /** The full text of the license */
    body?: string;
    /** The conditions set by the license */
    conditions?: PartialObjects["LicenseRule"][];
    /** A human-readable description of the license */
    description?: string;
    /** Whether the license should be featured */
    featured?: boolean;
    /** Whether the license should be displayed in license pickers */
    hidden?: boolean;
    id?: string;
    /** Instructions on how to implement the license */
    implementation?: string;
    /** The lowercased SPDX ID of the license */
    key?: string;
    /** The limitations set by the license */
    limitations?: PartialObjects["LicenseRule"][];
    /** The license full name specified by <https: spdx.org="" licenses=""></https:> */
    name?: string;
    /** Customary short name if applicable (e.g, GPLv3) */
    nickname?: string;
    /** The permissions set by the license */
    permissions?: PartialObjects["LicenseRule"][];
    /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
    pseudoLicense?: boolean;
    /** Short identifier specified by <https://spdx.org/licenses> */
    spdxId?: string;
    /** URL to the license on <https://choosealicense.com> */
    url?: PartialObjects["URI"];
  };
  /** Describes a License's conditions, permissions, and limitations */
  ["LicenseRule"]: {
    __typename?: "LicenseRule";
    /** A description of the rule */
    description?: string;
    /** The machine-readable rule key */
    key?: string;
    /** The human-readable rule label */
    label?: string;
  };
  /** An object that can be locked. */
  ["Lockable"]: {
    /** Reason that the conversation was locked. */
    activeLockReason?: PartialObjects["LockReason"];
    /** `true` if the object is locked */
    locked?: boolean;
  } & (PartialObjects["Issue"] | PartialObjects["PullRequest"]);
  /** Represents a 'locked' event on a given issue or pull request. */
  ["LockedEvent"]: {
    __typename?: "LockedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Reason that the conversation was locked (optional). */
    lockReason?: PartialObjects["LockReason"];
    /** Object that was locked. */
    lockable?: PartialObjects["Lockable"];
  };
  /** Autogenerated input type of LockLockable */
  ["LockLockableInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** A reason for why the issue or pull request will be locked. */
    lockReason?: PartialObjects["LockReason"];
    /** ID of the issue or pull request to be locked. */
    lockableId: string;
  };
  /** Autogenerated return type of LockLockable */
  ["LockLockablePayload"]: {
    __typename?: "LockLockablePayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The item that was locked. */
    lockedRecord?: PartialObjects["Lockable"];
  };
  /** The possible reasons that an issue or pull request was locked. */
  ["LockReason"]: LockReason;
  /** A public description of a Marketplace category. */
  ["MarketplaceCategory"]: {
    __typename?: "MarketplaceCategory";
    /** The category's description. */
    description?: string;
    /** The technical description of how apps listed in this category work with GitHub. */
    howItWorks?: string;
    id?: string;
    /** The category's name. */
    name?: string;
    /** How many Marketplace listings have this as their primary category. */
    primaryListingCount?: number;
    /** The HTTP path for this Marketplace category. */
    resourcePath?: PartialObjects["URI"];
    /** How many Marketplace listings have this as their secondary category. */
    secondaryListingCount?: number;
    /** The short name of the category used in its URL. */
    slug?: string;
    /** The HTTP URL for this Marketplace category. */
    url?: PartialObjects["URI"];
  };
  /** A listing in the GitHub integration marketplace. */
  ["MarketplaceListing"]: {
    __typename?: "MarketplaceListing";
    /** The GitHub App this listing represents. */
    app?: PartialObjects["App"];
    /** URL to the listing owner's company site. */
    companyUrl?: PartialObjects["URI"];
    /** The HTTP path for configuring access to the listing's integration or OAuth app */
    configurationResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for configuring access to the listing's integration or OAuth app */
    configurationUrl?: PartialObjects["URI"];
    /** URL to the listing's documentation. */
    documentationUrl?: PartialObjects["URI"];
    /** The listing's detailed description. */
    extendedDescription?: string;
    /** The listing's detailed description rendered to HTML. */
    extendedDescriptionHTML?: PartialObjects["HTML"];
    /** The listing's introductory description. */
    fullDescription?: string;
    /** The listing's introductory description rendered to HTML. */
    fullDescriptionHTML?: PartialObjects["HTML"];
    /** Whether this listing has been submitted for review from GitHub for approval to be displayed in the Marketplace. */
    hasApprovalBeenRequested?: boolean;
    /** Does this listing have any plans with a free trial? */
    hasPublishedFreeTrialPlans?: boolean;
    /** Does this listing have a terms of service link? */
    hasTermsOfService?: boolean;
    /** A technical description of how this app works with GitHub. */
    howItWorks?: string;
    /** The listing's technical description rendered to HTML. */
    howItWorksHTML?: PartialObjects["HTML"];
    id?: string;
    /** URL to install the product to the viewer's account or organization. */
    installationUrl?: PartialObjects["URI"];
    /** Whether this listing's app has been installed for the current viewer */
    installedForViewer?: boolean;
    /** Whether this listing has been approved for display in the Marketplace. */
    isApproved?: boolean;
    /** Whether this listing has been removed from the Marketplace. */
    isDelisted?: boolean;
    /** 																Whether this listing is still an editable draft that has not been submitted
for review and is not publicly visible in the Marketplace. */
    isDraft?: boolean;
    /** Whether the product this listing represents is available as part of a paid plan. */
    isPaid?: boolean;
    /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
    isRejected?: boolean;
    /** The hex color code, without the leading '#', for the logo background. */
    logoBackgroundColor?: string;
    /** URL for the listing's logo image. */
    logoUrl?: PartialObjects["URI"];
    /** The listing's full name. */
    name?: string;
    /** The listing's very short description without a trailing period or ampersands. */
    normalizedShortDescription?: string;
    /** URL to the listing's detailed pricing. */
    pricingUrl?: PartialObjects["URI"];
    /** The category that best describes the listing. */
    primaryCategory?: PartialObjects["MarketplaceCategory"];
    /** URL to the listing's privacy policy. */
    privacyPolicyUrl?: PartialObjects["URI"];
    /** The HTTP path for the Marketplace listing. */
    resourcePath?: PartialObjects["URI"];
    /** The URLs for the listing's screenshots. */
    screenshotUrls?: string[];
    /** An alternate category that describes the listing. */
    secondaryCategory?: PartialObjects["MarketplaceCategory"];
    /** The listing's very short description. */
    shortDescription?: string;
    /** The short name of the listing used in its URL. */
    slug?: string;
    /** URL to the listing's status page. */
    statusUrl?: PartialObjects["URI"];
    /** An email address for support for this listing's app. */
    supportEmail?: string;
    /** Either a URL or an email address for support for this listing's app. */
    supportUrl?: PartialObjects["URI"];
    /** URL to the listing's terms of service. */
    termsOfServiceUrl?: PartialObjects["URI"];
    /** The HTTP URL for the Marketplace listing. */
    url?: PartialObjects["URI"];
    /** Can the current viewer add plans for this Marketplace listing. */
    viewerCanAddPlans?: boolean;
    /** Can the current viewer approve this Marketplace listing. */
    viewerCanApprove?: boolean;
    /** Can the current viewer delist this Marketplace listing. */
    viewerCanDelist?: boolean;
    /** Can the current viewer edit this Marketplace listing. */
    viewerCanEdit?: boolean;
    /** 																Can the current viewer edit the primary and secondary category of this
Marketplace listing. */
    viewerCanEditCategories?: boolean;
    /** Can the current viewer edit the plans for this Marketplace listing. */
    viewerCanEditPlans?: boolean;
    /** 																Can the current viewer return this Marketplace listing to draft state
so it becomes editable again. */
    viewerCanRedraft?: boolean;
    /** 																Can the current viewer reject this Marketplace listing by returning it to
an editable draft state or rejecting it entirely. */
    viewerCanReject?: boolean;
    /** 																Can the current viewer request this listing be reviewed for display in
the Marketplace. */
    viewerCanRequestApproval?: boolean;
    /** Indicates whether the current user has an active subscription to this Marketplace listing. */
    viewerHasPurchased?: boolean;
    /** 																Indicates if the current user has purchased a subscription to this Marketplace listing
for all of the organizations the user owns. */
    viewerHasPurchasedForAllOrganizations?: boolean;
    /** Does the current viewer role allow them to administer this Marketplace listing. */
    viewerIsListingAdmin?: boolean;
  };
  /** Look up Marketplace Listings */
  ["MarketplaceListingConnection"]: {
    __typename?: "MarketplaceListingConnection";
    /** A list of edges. */
    edges?: (PartialObjects["MarketplaceListingEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["MarketplaceListing"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["MarketplaceListingEdge"]: {
    __typename?: "MarketplaceListingEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["MarketplaceListing"];
  };
  /** Represents a 'mentioned' event on a given issue or pull request. */
  ["MentionedEvent"]: {
    __typename?: "MentionedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
  };
  /** Whether or not a PullRequest can be merged. */
  ["MergeableState"]: MergeableState;
  /** Represents a 'merged' event on a given pull request. */
  ["MergedEvent"]: {
    __typename?: "MergedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the commit associated with the `merge` event. */
    commit?: PartialObjects["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Identifies the Ref associated with the `merge` event. */
    mergeRef?: PartialObjects["Ref"];
    /** Identifies the name of the Ref associated with the `merge` event. */
    mergeRefName?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
    /** The HTTP path for this merged event. */
    resourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this merged event. */
    url?: PartialObjects["URI"];
  };
  /** Represents a Milestone object on a given repository. */
  ["Milestone"]: {
    __typename?: "Milestone";
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: boolean;
    /** Identifies the date and time when the object was closed. */
    closedAt?: PartialObjects["DateTime"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the actor who created the milestone. */
    creator?: PartialObjects["Actor"];
    /** Identifies the description of the milestone. */
    description?: string;
    /** Identifies the due date of the milestone. */
    dueOn?: PartialObjects["DateTime"];
    id?: string;
    /** A list of issues associated with the milestone. */
    issues?: PartialObjects["IssueConnection"];
    /** Identifies the number of the milestone. */
    number?: number;
    /** A list of pull requests associated with the milestone. */
    pullRequests?: PartialObjects["PullRequestConnection"];
    /** The repository associated with this milestone. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path for this milestone */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the state of the milestone. */
    state?: PartialObjects["MilestoneState"];
    /** Identifies the title of the milestone. */
    title?: string;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this milestone */
    url?: PartialObjects["URI"];
  };
  /** The connection type for Milestone. */
  ["MilestoneConnection"]: {
    __typename?: "MilestoneConnection";
    /** A list of edges. */
    edges?: (PartialObjects["MilestoneEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Milestone"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a 'milestoned' event on a given issue or pull request. */
  ["MilestonedEvent"]: {
    __typename?: "MilestonedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Identifies the milestone title associated with the 'milestoned' event. */
    milestoneTitle?: string;
    /** Object referenced by event. */
    subject?: PartialObjects["MilestoneItem"];
  };
  /** An edge in a connection. */
  ["MilestoneEdge"]: {
    __typename?: "MilestoneEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Milestone"];
  };
  /** Types that can be inside a Milestone. */
  ["MilestoneItem"]: PartialObjects["Issue"] | PartialObjects["PullRequest"];
  /** Ordering options for milestone connections. */
  ["MilestoneOrder"]: {
    /** The ordering direction. */
    direction: PartialObjects["OrderDirection"];
    /** The field to order milestones by. */
    field: PartialObjects["MilestoneOrderField"];
  };
  /** Properties by which milestone connections can be ordered. */
  ["MilestoneOrderField"]: MilestoneOrderField;
  /** The possible states of a milestone. */
  ["MilestoneState"]: MilestoneState;
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  ["MovedColumnsInProjectEvent"]: {
    __typename?: "MovedColumnsInProjectEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
  };
  /** Autogenerated input type of MoveProjectCard */
  ["MoveProjectCardInput"]: {
    /** Place the new card after the card with this id. Pass null to place it at the top. */
    afterCardId?: string;
    /** The id of the card to move. */
    cardId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The id of the column to move it into. */
    columnId: string;
  };
  /** Autogenerated return type of MoveProjectCard */
  ["MoveProjectCardPayload"]: {
    __typename?: "MoveProjectCardPayload";
    /** 														The new edge of the moved card.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `cardEdge` will change from `ProjectCardEdge!` to `ProjectCardEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    cardEdge?: PartialObjects["ProjectCardEdge"];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated input type of MoveProjectColumn */
  ["MoveProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The id of the column to move. */
    columnId: string;
    /** Place the new column after the column with this id. Pass null to place it at the front. */
    afterColumnId?: string;
  };
  /** Autogenerated return type of MoveProjectColumn */
  ["MoveProjectColumnPayload"]: {
    __typename?: "MoveProjectColumnPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The new edge of the moved column.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `columnEdge` will change from `ProjectColumnEdge!` to `ProjectColumnEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    columnEdge?: PartialObjects["ProjectColumnEdge"];
  };
  /** The root query for implementing GraphQL mutations. */
  ["Mutation"]: {
    __typename?: "Mutation";
    /** Applies a suggested topic to the repository. */
    acceptTopicSuggestion?: PartialObjects["AcceptTopicSuggestionPayload"];
    /** Adds a comment to an Issue or Pull Request. */
    addComment?: PartialObjects["AddCommentPayload"];
    /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
    addProjectCard?: PartialObjects["AddProjectCardPayload"];
    /** Adds a column to a Project. */
    addProjectColumn?: PartialObjects["AddProjectColumnPayload"];
    /** Adds a review to a Pull Request. */
    addPullRequestReview?: PartialObjects["AddPullRequestReviewPayload"];
    /** Adds a comment to a review. */
    addPullRequestReviewComment?: PartialObjects["AddPullRequestReviewCommentPayload"];
    /** Adds a reaction to a subject. */
    addReaction?: PartialObjects["AddReactionPayload"];
    /** Adds a star to a Starrable. */
    addStar?: PartialObjects["AddStarPayload"];
    /** Creates a new project. */
    createProject?: PartialObjects["CreateProjectPayload"];
    /** Rejects a suggested topic for the repository. */
    declineTopicSuggestion?: PartialObjects["DeclineTopicSuggestionPayload"];
    /** Deletes a project. */
    deleteProject?: PartialObjects["DeleteProjectPayload"];
    /** Deletes a project card. */
    deleteProjectCard?: PartialObjects["DeleteProjectCardPayload"];
    /** Deletes a project column. */
    deleteProjectColumn?: PartialObjects["DeleteProjectColumnPayload"];
    /** Deletes a pull request review. */
    deletePullRequestReview?: PartialObjects["DeletePullRequestReviewPayload"];
    /** Dismisses an approved or rejected pull request review. */
    dismissPullRequestReview?: PartialObjects["DismissPullRequestReviewPayload"];
    /** Lock a lockable object */
    lockLockable?: PartialObjects["LockLockablePayload"];
    /** Moves a project card to another place. */
    moveProjectCard?: PartialObjects["MoveProjectCardPayload"];
    /** Moves a project column to another place. */
    moveProjectColumn?: PartialObjects["MoveProjectColumnPayload"];
    /** Removes outside collaborator from all repositories in an organization. */
    removeOutsideCollaborator?: PartialObjects["RemoveOutsideCollaboratorPayload"];
    /** Removes a reaction from a subject. */
    removeReaction?: PartialObjects["RemoveReactionPayload"];
    /** Removes a star from a Starrable. */
    removeStar?: PartialObjects["RemoveStarPayload"];
    /** Set review requests on a pull request. */
    requestReviews?: PartialObjects["RequestReviewsPayload"];
    /** Submits a pending pull request review. */
    submitPullRequestReview?: PartialObjects["SubmitPullRequestReviewPayload"];
    /** Unlock a lockable object */
    unlockLockable?: PartialObjects["UnlockLockablePayload"];
    /** Updates an existing project. */
    updateProject?: PartialObjects["UpdateProjectPayload"];
    /** Updates an existing project card. */
    updateProjectCard?: PartialObjects["UpdateProjectCardPayload"];
    /** Updates an existing project column. */
    updateProjectColumn?: PartialObjects["UpdateProjectColumnPayload"];
    /** Updates the body of a pull request review. */
    updatePullRequestReview?: PartialObjects["UpdatePullRequestReviewPayload"];
    /** Updates a pull request review comment. */
    updatePullRequestReviewComment?: PartialObjects["UpdatePullRequestReviewCommentPayload"];
    /** Updates the state for subscribable subjects. */
    updateSubscription?: PartialObjects["UpdateSubscriptionPayload"];
    /** Replaces the repository's topics with the given topics. */
    updateTopics?: PartialObjects["UpdateTopicsPayload"];
  };
  /** An object with an ID. */
  ["Node"]: {
    /** ID of the object. */
    id?: string;
  } & (
    | PartialObjects["AddedToProjectEvent"]
    | PartialObjects["App"]
    | PartialObjects["AssignedEvent"]
    | PartialObjects["BaseRefChangedEvent"]
    | PartialObjects["BaseRefForcePushedEvent"]
    | PartialObjects["Blob"]
    | PartialObjects["Bot"]
    | PartialObjects["ClosedEvent"]
    | PartialObjects["CommentDeletedEvent"]
    | PartialObjects["Commit"]
    | PartialObjects["CommitComment"]
    | PartialObjects["CommitCommentThread"]
    | PartialObjects["ConvertedNoteToIssueEvent"]
    | PartialObjects["CrossReferencedEvent"]
    | PartialObjects["DemilestonedEvent"]
    | PartialObjects["DeployedEvent"]
    | PartialObjects["DeployKey"]
    | PartialObjects["Deployment"]
    | PartialObjects["DeploymentEnvironmentChangedEvent"]
    | PartialObjects["DeploymentStatus"]
    | PartialObjects["ExternalIdentity"]
    | PartialObjects["Gist"]
    | PartialObjects["GistComment"]
    | PartialObjects["HeadRefDeletedEvent"]
    | PartialObjects["HeadRefForcePushedEvent"]
    | PartialObjects["HeadRefRestoredEvent"]
    | PartialObjects["Issue"]
    | PartialObjects["IssueComment"]
    | PartialObjects["Label"]
    | PartialObjects["LabeledEvent"]
    | PartialObjects["Language"]
    | PartialObjects["License"]
    | PartialObjects["LockedEvent"]
    | PartialObjects["MarketplaceCategory"]
    | PartialObjects["MarketplaceListing"]
    | PartialObjects["MentionedEvent"]
    | PartialObjects["MergedEvent"]
    | PartialObjects["Milestone"]
    | PartialObjects["MilestonedEvent"]
    | PartialObjects["MovedColumnsInProjectEvent"]
    | PartialObjects["Organization"]
    | PartialObjects["OrganizationIdentityProvider"]
    | PartialObjects["OrganizationInvitation"]
    | PartialObjects["Project"]
    | PartialObjects["ProjectCard"]
    | PartialObjects["ProjectColumn"]
    | PartialObjects["ProtectedBranch"]
    | PartialObjects["PublicKey"]
    | PartialObjects["PullRequest"]
    | PartialObjects["PullRequestCommit"]
    | PartialObjects["PullRequestReview"]
    | PartialObjects["PullRequestReviewComment"]
    | PartialObjects["PullRequestReviewThread"]
    | PartialObjects["PushAllowance"]
    | PartialObjects["Reaction"]
    | PartialObjects["Ref"]
    | PartialObjects["ReferencedEvent"]
    | PartialObjects["Release"]
    | PartialObjects["ReleaseAsset"]
    | PartialObjects["RemovedFromProjectEvent"]
    | PartialObjects["RenamedTitleEvent"]
    | PartialObjects["ReopenedEvent"]
    | PartialObjects["Repository"]
    | PartialObjects["RepositoryInvitation"]
    | PartialObjects["RepositoryTopic"]
    | PartialObjects["ReviewDismissalAllowance"]
    | PartialObjects["ReviewDismissedEvent"]
    | PartialObjects["ReviewRequest"]
    | PartialObjects["ReviewRequestedEvent"]
    | PartialObjects["ReviewRequestRemovedEvent"]
    | PartialObjects["Status"]
    | PartialObjects["StatusContext"]
    | PartialObjects["SubscribedEvent"]
    | PartialObjects["Tag"]
    | PartialObjects["Team"]
    | PartialObjects["Topic"]
    | PartialObjects["Tree"]
    | PartialObjects["UnassignedEvent"]
    | PartialObjects["UnlabeledEvent"]
    | PartialObjects["UnlockedEvent"]
    | PartialObjects["UnsubscribedEvent"]
    | PartialObjects["User"]
    | PartialObjects["UserContentEdit"]
  );
  /** Possible directions in which to order a list of items when provided an `orderBy` argument. */
  ["OrderDirection"]: OrderDirection;
  /** An account on GitHub, with one or more owners, that has repositories, members and teams. */
  ["Organization"]: {
    __typename?: "Organization";
    /** A URL pointing to the organization's public avatar. */
    avatarUrl?: PartialObjects["URI"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The organization's public profile description. */
    description?: string;
    /** The organization's public email. */
    email?: string;
    id?: string;
    /** Whether the organization has verified its profile email and website. */
    isVerified?: boolean;
    /** The organization's public profile location. */
    location?: string;
    /** The organization's login name. */
    login?: string;
    /** A list of users who are members of this organization. */
    members?: PartialObjects["UserConnection"];
    /** The organization's public profile name. */
    name?: string;
    /** The HTTP path creating a new team */
    newTeamResourcePath?: PartialObjects["URI"];
    /** The HTTP URL creating a new team */
    newTeamUrl?: PartialObjects["URI"];
    /** The billing email for the organization. */
    organizationBillingEmail?: string;
    /** A list of repositories this user has pinned to their profile */
    pinnedRepositories?: PartialObjects["RepositoryConnection"];
    /** Find project by number. */
    project?: PartialObjects["Project"];
    /** A list of projects under the owner. */
    projects?: PartialObjects["ProjectConnection"];
    /** The HTTP path listing organization's projects */
    projectsResourcePath?: PartialObjects["URI"];
    /** The HTTP URL listing organization's projects */
    projectsUrl?: PartialObjects["URI"];
    /** A list of repositories that the user owns. */
    repositories?: PartialObjects["RepositoryConnection"];
    /** Find Repository. */
    repository?: PartialObjects["Repository"];
    /** 																When true the organization requires all members, billing managers, and outside
collaborators to enable two-factor authentication. */
    requiresTwoFactorAuthentication?: boolean;
    /** The HTTP path for this organization. */
    resourcePath?: PartialObjects["URI"];
    /** The Organization's SAML Identity Providers */
    samlIdentityProvider?: PartialObjects["OrganizationIdentityProvider"];
    /** Find an organization's team by its slug. */
    team?: PartialObjects["Team"];
    /** A list of teams in this organization. */
    teams?: PartialObjects["TeamConnection"];
    /** The HTTP path listing organization's teams */
    teamsResourcePath?: PartialObjects["URI"];
    /** The HTTP URL listing organization's teams */
    teamsUrl?: PartialObjects["URI"];
    /** The HTTP URL for this organization. */
    url?: PartialObjects["URI"];
    /** Organization is adminable by the viewer. */
    viewerCanAdminister?: boolean;
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects?: boolean;
    /** Viewer can create repositories on this organization */
    viewerCanCreateRepositories?: boolean;
    /** Viewer can create teams on this organization. */
    viewerCanCreateTeams?: boolean;
    /** Viewer is an active member of this organization. */
    viewerIsAMember?: boolean;
    /** The organization's public profile URL. */
    websiteUrl?: PartialObjects["URI"];
  };
  /** The connection type for Organization. */
  ["OrganizationConnection"]: {
    __typename?: "OrganizationConnection";
    /** A list of edges. */
    edges?: (PartialObjects["OrganizationEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Organization"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["OrganizationEdge"]: {
    __typename?: "OrganizationEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Organization"];
  };
  /** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
  ["OrganizationIdentityProvider"]: {
    __typename?: "OrganizationIdentityProvider";
    /** The digest algorithm used to sign SAML requests for the Identity Provider. */
    digestMethod?: PartialObjects["URI"];
    /** External Identities provisioned by this Identity Provider */
    externalIdentities?: PartialObjects["ExternalIdentityConnection"];
    id?: string;
    /** The x509 certificate used by the Identity Provder to sign assertions and responses. */
    idpCertificate?: PartialObjects["X509Certificate"];
    /** The Issuer Entity ID for the SAML Identity Provider */
    issuer?: string;
    /** Organization this Identity Provider belongs to */
    organization?: PartialObjects["Organization"];
    /** The signature algorithm used to sign SAML requests for the Identity Provider. */
    signatureMethod?: PartialObjects["URI"];
    /** The URL endpoint for the Identity Provider's SAML SSO. */
    ssoUrl?: PartialObjects["URI"];
  };
  /** An Invitation for a user to an organization. */
  ["OrganizationInvitation"]: {
    __typename?: "OrganizationInvitation";
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The email address of the user invited to the organization. */
    email?: string;
    id?: string;
    /** The type of invitation that was sent (e.g. email, user). */
    invitationType?: PartialObjects["OrganizationInvitationType"];
    /** The user who was invited to the organization. */
    invitee?: PartialObjects["User"];
    /** The user who created the invitation. */
    inviter?: PartialObjects["User"];
    /** The organization the invite is for */
    organization?: PartialObjects["Organization"];
    /** The user's pending role in the organization (e.g. member, owner). */
    role?: PartialObjects["OrganizationInvitationRole"];
  };
  /** The connection type for OrganizationInvitation. */
  ["OrganizationInvitationConnection"]: {
    __typename?: "OrganizationInvitationConnection";
    /** A list of edges. */
    edges?: (PartialObjects["OrganizationInvitationEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["OrganizationInvitation"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["OrganizationInvitationEdge"]: {
    __typename?: "OrganizationInvitationEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["OrganizationInvitation"];
  };
  /** The possible organization invitation roles. */
  ["OrganizationInvitationRole"]: OrganizationInvitationRole;
  /** The possible organization invitation types. */
  ["OrganizationInvitationType"]: OrganizationInvitationType;
  /** Information about pagination in a connection. */
  ["PageInfo"]: {
    __typename?: "PageInfo";
    /** When paginating forwards, the cursor to continue. */
    endCursor?: string;
    /** When paginating forwards, are there more items? */
    hasNextPage?: boolean;
    /** When paginating backwards, are there more items? */
    hasPreviousPage?: boolean;
    /** When paginating backwards, the cursor to continue. */
    startCursor?: string;
  };
  /** Projects manage issues, pull requests and notes within a project owner. */
  ["Project"]: {
    __typename?: "Project";
    /** The project's description body. */
    body?: string;
    /** The projects description body rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed?: boolean;
    /** Identifies the date and time when the object was closed. */
    closedAt?: PartialObjects["DateTime"];
    /** List of columns in the project */
    columns?: PartialObjects["ProjectColumnConnection"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The actor who originally created the project. */
    creator?: PartialObjects["Actor"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
    /** The project's name. */
    name?: string;
    /** The project's number. */
    number?: number;
    /** The project's owner. Currently limited to repositories and organizations. */
    owner?: PartialObjects["ProjectOwner"];
    /** List of pending cards in this project */
    pendingCards?: PartialObjects["ProjectCardConnection"];
    /** The HTTP path for this project */
    resourcePath?: PartialObjects["URI"];
    /** Whether the project is open or closed. */
    state?: PartialObjects["ProjectState"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this project */
    url?: PartialObjects["URI"];
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
  };
  /** A card in a project. */
  ["ProjectCard"]: {
    __typename?: "ProjectCard";
    /** 																The project column this card is associated under. A card may only belong to one
project column at a time. The column field will be null if the card is created
in a pending state and has yet to be associated with a column. Once cards are
associated with a column, they will not become pending in the future. */
    column?: PartialObjects["ProjectColumn"];
    /** The card content item */
    content?: PartialObjects["ProjectCardItem"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The actor who created this card */
    creator?: PartialObjects["Actor"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
    /** Whether the card is archived */
    isArchived?: boolean;
    /** The card note */
    note?: string;
    /** The project that contains this card. */
    project?: PartialObjects["Project"];
    /** The HTTP path for this card */
    resourcePath?: PartialObjects["URI"];
    /** The state of ProjectCard */
    state?: PartialObjects["ProjectCardState"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this card */
    url?: PartialObjects["URI"];
  };
  /** The possible archived states of a project card. */
  ["ProjectCardArchivedState"]: ProjectCardArchivedState;
  /** The connection type for ProjectCard. */
  ["ProjectCardConnection"]: {
    __typename?: "ProjectCardConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ProjectCardEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["ProjectCard"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ProjectCardEdge"]: {
    __typename?: "ProjectCardEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["ProjectCard"];
  };
  /** Types that can be inside Project Cards. */
  ["ProjectCardItem"]: PartialObjects["Issue"] | PartialObjects["PullRequest"];
  /** Various content states of a ProjectCard */
  ["ProjectCardState"]: ProjectCardState;
  /** A column inside a project. */
  ["ProjectColumn"]: {
    __typename?: "ProjectColumn";
    /** List of cards in the column */
    cards?: PartialObjects["ProjectCardConnection"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
    /** The project column's name. */
    name?: string;
    /** The project that contains this column. */
    project?: PartialObjects["Project"];
    /** The semantic purpose of the column */
    purpose?: PartialObjects["ProjectColumnPurpose"];
    /** The HTTP path for this project column */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this project column */
    url?: PartialObjects["URI"];
  };
  /** The connection type for ProjectColumn. */
  ["ProjectColumnConnection"]: {
    __typename?: "ProjectColumnConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ProjectColumnEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["ProjectColumn"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ProjectColumnEdge"]: {
    __typename?: "ProjectColumnEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["ProjectColumn"];
  };
  /** The semantic purpose of the column - todo, in progress, or done. */
  ["ProjectColumnPurpose"]: ProjectColumnPurpose;
  /** A list of projects associated with the owner. */
  ["ProjectConnection"]: {
    __typename?: "ProjectConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ProjectEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Project"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ProjectEdge"]: {
    __typename?: "ProjectEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Project"];
  };
  /** Ways in which lists of projects can be ordered upon return. */
  ["ProjectOrder"]: {
    /** The direction in which to order projects by the specified field. */
    direction: PartialObjects["OrderDirection"];
    /** The field in which to order projects by. */
    field: PartialObjects["ProjectOrderField"];
  };
  /** Properties by which project connections can be ordered. */
  ["ProjectOrderField"]: ProjectOrderField;
  /** Represents an owner of a Project. */
  ["ProjectOwner"]: {
    /** A list of projects under the owner. */
    projects?: PartialObjects["ProjectConnection"];
    /** The HTTP path listing owners projects */
    projectsResourcePath?: PartialObjects["URI"];
    /** The HTTP URL listing owners projects */
    projectsUrl?: PartialObjects["URI"];
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects?: boolean;
    id?: string;
    /** Find project by number. */
    project?: PartialObjects["Project"];
  } & (PartialObjects["Organization"] | PartialObjects["Repository"]);
  /** State of the project; either 'open' or 'closed' */
  ["ProjectState"]: ProjectState;
  /** A repository protected branch. */
  ["ProtectedBranch"]: {
    __typename?: "ProtectedBranch";
    /** The actor who created this protected branch. */
    creator?: PartialObjects["Actor"];
    /** Will new commits pushed to this branch dismiss pull request review approvals. */
    hasDismissableStaleReviews?: boolean;
    /** Are reviews required to update this branch. */
    hasRequiredReviews?: boolean;
    /** Are status checks required to update this branch. */
    hasRequiredStatusChecks?: boolean;
    /** Is pushing to this branch restricted. */
    hasRestrictedPushes?: boolean;
    /** Is dismissal of pull request reviews restricted. */
    hasRestrictedReviewDismissals?: boolean;
    /** Are branches required to be up to date before merging. */
    hasStrictRequiredStatusChecks?: boolean;
    id?: string;
    /** Can admins overwrite branch protection. */
    isAdminEnforced?: boolean;
    /** The name of the protected branch rule. */
    name?: string;
    /** A list push allowances for this protected branch. */
    pushAllowances?: PartialObjects["PushAllowanceConnection"];
    /** The repository associated with this protected branch. */
    repository?: PartialObjects["Repository"];
    /** List of required status check contexts that must pass for commits to be accepted to this branch. */
    requiredStatusCheckContexts?: (string | undefined)[];
    /** A list review dismissal allowances for this protected branch. */
    reviewDismissalAllowances?: PartialObjects["ReviewDismissalAllowanceConnection"];
  };
  /** The connection type for ProtectedBranch. */
  ["ProtectedBranchConnection"]: {
    __typename?: "ProtectedBranchConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ProtectedBranchEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["ProtectedBranch"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ProtectedBranchEdge"]: {
    __typename?: "ProtectedBranchEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["ProtectedBranch"];
  };
  /** A user's public key. */
  ["PublicKey"]: {
    __typename?: "PublicKey";
    id?: string;
    /** The public key string */
    key?: string;
  };
  /** The connection type for PublicKey. */
  ["PublicKeyConnection"]: {
    __typename?: "PublicKeyConnection";
    /** A list of edges. */
    edges?: (PartialObjects["PublicKeyEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["PublicKey"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["PublicKeyEdge"]: {
    __typename?: "PublicKeyEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["PublicKey"];
  };
  /** A repository pull request. */
  ["PullRequest"]: {
    __typename?: "PullRequest";
    /** Reason that the conversation was locked. */
    activeLockReason?: PartialObjects["LockReason"];
    /** The number of additions in this pull request. */
    additions?: number;
    /** A list of Users assigned to this object. */
    assignees?: PartialObjects["UserConnection"];
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
    /** Identifies the base Ref associated with the pull request. */
    baseRef?: PartialObjects["Ref"];
    /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
    baseRefName?: string;
    /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
    baseRefOid?: PartialObjects["GitObjectID"];
    /** The body as Markdown. */
    body?: string;
    /** The body rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** The body rendered to text. */
    bodyText?: string;
    /** The number of changed files in this pull request. */
    changedFiles?: number;
    /** `true` if the pull request is closed */
    closed?: boolean;
    /** Identifies the date and time when the object was closed. */
    closedAt?: PartialObjects["DateTime"];
    /** A list of comments associated with the pull request. */
    comments?: PartialObjects["IssueCommentConnection"];
    /** A list of commits present in this pull request's head branch not present in the base branch. */
    commits?: PartialObjects["PullRequestCommitConnection"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The number of deletions in this pull request. */
    deletions?: number;
    /** The actor who edited this pull request's body. */
    editor?: PartialObjects["Actor"];
    /** Identifies the head Ref associated with the pull request. */
    headRef?: PartialObjects["Ref"];
    /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
    headRefName?: string;
    /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
    headRefOid?: PartialObjects["GitObjectID"];
    /** The repository associated with this pull request's head Ref. */
    headRepository?: PartialObjects["Repository"];
    /** The owner of the repository associated with this pull request's head Ref. */
    headRepositoryOwner?: PartialObjects["RepositoryOwner"];
    id?: string;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** The head and base repositories are different. */
    isCrossRepository?: boolean;
    /** A list of labels associated with the object. */
    labels?: PartialObjects["LabelConnection"];
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** `true` if the pull request is locked */
    locked?: boolean;
    /** Indicates whether maintainers can modify the pull request. */
    maintainerCanModify?: boolean;
    /** The commit that was created when this pull request was merged. */
    mergeCommit?: PartialObjects["Commit"];
    /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
    mergeable?: PartialObjects["MergeableState"];
    /** Whether or not the pull request was merged. */
    merged?: boolean;
    /** The date and time that the pull request was merged. */
    mergedAt?: PartialObjects["DateTime"];
    /** The actor who merged the pull request. */
    mergedBy?: PartialObjects["Actor"];
    /** Identifies the milestone associated with the pull request. */
    milestone?: PartialObjects["Milestone"];
    /** Identifies the pull request number. */
    number?: number;
    /** A list of Users that are participating in the Pull Request conversation. */
    participants?: PartialObjects["UserConnection"];
    /** The permalink to the pull request. */
    permalink?: PartialObjects["URI"];
    /** 																The commit that GitHub automatically generated to test if this pull request
could be merged. This field will not return a value if the pull request is
merged, or if the test merge commit is still being generated. See the
`mergeable` field for more details on the mergeability of the pull request. */
    potentialMergeCommit?: PartialObjects["Commit"];
    /** List of project cards associated with this pull request. */
    projectCards?: PartialObjects["ProjectCardConnection"];
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: PartialObjects["ReactionGroup"][];
    /** A list of Reactions left on the Issue. */
    reactions?: PartialObjects["ReactionConnection"];
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path for this pull request. */
    resourcePath?: PartialObjects["URI"];
    /** The HTTP path for reverting this pull request. */
    revertResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for reverting this pull request. */
    revertUrl?: PartialObjects["URI"];
    /** A list of review requests associated with the pull request. */
    reviewRequests?: PartialObjects["ReviewRequestConnection"];
    /** A list of reviews associated with the pull request. */
    reviews?: PartialObjects["PullRequestReviewConnection"];
    /** Identifies the state of the pull request. */
    state?: PartialObjects["PullRequestState"];
    /** A list of reviewer suggestions based on commit history and past review comments. */
    suggestedReviewers?: PartialObjects["SuggestedReviewer"][];
    /** A list of events, comments, commits, etc. associated with the pull request. */
    timeline?: PartialObjects["PullRequestTimelineConnection"];
    /** Identifies the pull request title. */
    title?: string;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this pull request. */
    url?: PartialObjects["URI"];
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Whether or not the viewer can apply suggestion. */
    viewerCanApplySuggestion?: boolean;
    /** Can user react to this subject */
    viewerCanReact?: boolean;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: boolean;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: PartialObjects["SubscriptionState"];
  };
  /** Represents a Git commit part of a pull request. */
  ["PullRequestCommit"]: {
    __typename?: "PullRequestCommit";
    /** The Git commit object */
    commit?: PartialObjects["Commit"];
    id?: string;
    /** The pull request this commit belongs to */
    pullRequest?: PartialObjects["PullRequest"];
    /** The HTTP path for this pull request commit */
    resourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this pull request commit */
    url?: PartialObjects["URI"];
  };
  /** The connection type for PullRequestCommit. */
  ["PullRequestCommitConnection"]: {
    __typename?: "PullRequestCommitConnection";
    /** A list of edges. */
    edges?: (PartialObjects["PullRequestCommitEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["PullRequestCommit"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["PullRequestCommitEdge"]: {
    __typename?: "PullRequestCommitEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["PullRequestCommit"];
  };
  /** The connection type for PullRequest. */
  ["PullRequestConnection"]: {
    __typename?: "PullRequestConnection";
    /** A list of edges. */
    edges?: (PartialObjects["PullRequestEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["PullRequest"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["PullRequestEdge"]: {
    __typename?: "PullRequestEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["PullRequest"];
  };
  /** A review object for a given pull request. */
  ["PullRequestReview"]: {
    __typename?: "PullRequestReview";
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
    /** Identifies the pull request review body. */
    body?: string;
    /** The body of this review rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** The body of this review rendered as plain text. */
    bodyText?: string;
    /** A list of review comments for the current pull request review. */
    comments?: PartialObjects["PullRequestReviewCommentConnection"];
    /** Identifies the commit associated with this pull request review. */
    commit?: PartialObjects["Commit"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The actor who edited the comment. */
    editor?: PartialObjects["Actor"];
    id?: string;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** Identifies the pull request associated with this pull request review. */
    pullRequest?: PartialObjects["PullRequest"];
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path permalink for this PullRequestReview. */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the current state of the pull request review. */
    state?: PartialObjects["PullRequestReviewState"];
    /** Identifies when the Pull Request Review was submitted */
    submittedAt?: PartialObjects["DateTime"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL permalink for this PullRequestReview. */
    url?: PartialObjects["URI"];
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: boolean;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
  };
  /** A review comment associated with a given repository pull request. */
  ["PullRequestReviewComment"]: {
    __typename?: "PullRequestReviewComment";
    /** The actor who authored the comment. */
    author?: PartialObjects["Actor"];
    /** Author's association with the subject of the comment. */
    authorAssociation?: PartialObjects["CommentAuthorAssociation"];
    /** The comment body of this review comment. */
    body?: string;
    /** The comment body of this review comment rendered to HTML. */
    bodyHTML?: PartialObjects["HTML"];
    /** The comment body of this review comment rendered as plain text. */
    bodyText?: string;
    /** Identifies the commit associated with the comment. */
    commit?: PartialObjects["Commit"];
    /** Identifies when the comment was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Check if this comment was created via an email reply. */
    createdViaEmail?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The diff hunk to which the comment applies. */
    diffHunk?: string;
    /** Identifies when the comment was created in a draft state. */
    draftedAt?: PartialObjects["DateTime"];
    /** The actor who edited the comment. */
    editor?: PartialObjects["Actor"];
    id?: string;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit?: boolean;
    /** The moment the editor made the last edit */
    lastEditedAt?: PartialObjects["DateTime"];
    /** Identifies the original commit associated with the comment. */
    originalCommit?: PartialObjects["Commit"];
    /** The original line index in the diff to which the comment applies. */
    originalPosition?: number;
    /** The path to which the comment applies. */
    path?: string;
    /** The line index in the diff to which the comment applies. */
    position?: number;
    /** Identifies when the comment was published at. */
    publishedAt?: PartialObjects["DateTime"];
    /** The pull request associated with this review comment. */
    pullRequest?: PartialObjects["PullRequest"];
    /** The pull request review associated with this review comment. */
    pullRequestReview?: PartialObjects["PullRequestReview"];
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: PartialObjects["ReactionGroup"][];
    /** A list of Reactions left on the Issue. */
    reactions?: PartialObjects["ReactionConnection"];
    /** The comment this is a reply to. */
    replyTo?: PartialObjects["PullRequestReviewComment"];
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path permalink for this review comment. */
    resourcePath?: PartialObjects["URI"];
    /** Identifies when the comment was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL permalink for this review comment. */
    url?: PartialObjects["URI"];
    /** A list of edits to this content. */
    userContentEdits?: PartialObjects["UserContentEditConnection"];
    /** Check if the current viewer can delete this object. */
    viewerCanDelete?: boolean;
    /** Can user react to this subject */
    viewerCanReact?: boolean;
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
    /** Did the viewer author this comment. */
    viewerDidAuthor?: boolean;
  };
  /** The connection type for PullRequestReviewComment. */
  ["PullRequestReviewCommentConnection"]: {
    __typename?: "PullRequestReviewCommentConnection";
    /** A list of edges. */
    edges?: (PartialObjects["PullRequestReviewCommentEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["PullRequestReviewComment"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["PullRequestReviewCommentEdge"]: {
    __typename?: "PullRequestReviewCommentEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["PullRequestReviewComment"];
  };
  /** The connection type for PullRequestReview. */
  ["PullRequestReviewConnection"]: {
    __typename?: "PullRequestReviewConnection";
    /** A list of edges. */
    edges?: (PartialObjects["PullRequestReviewEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["PullRequestReview"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["PullRequestReviewEdge"]: {
    __typename?: "PullRequestReviewEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["PullRequestReview"];
  };
  /** The possible events to perform on a pull request review. */
  ["PullRequestReviewEvent"]: PullRequestReviewEvent;
  /** The possible states of a pull request review. */
  ["PullRequestReviewState"]: PullRequestReviewState;
  /** A threaded list of comments for a given pull request. */
  ["PullRequestReviewThread"]: {
    __typename?: "PullRequestReviewThread";
    /** A list of pull request comments associated with the thread. */
    comments?: PartialObjects["PullRequestReviewCommentConnection"];
    id?: string;
    /** Identifies the pull request associated with this thread. */
    pullRequest?: PartialObjects["PullRequest"];
    /** Identifies the repository associated with this thread. */
    repository?: PartialObjects["Repository"];
  };
  /** The possible states of a pull request. */
  ["PullRequestState"]: PullRequestState;
  /** The connection type for PullRequestTimelineItem. */
  ["PullRequestTimelineConnection"]: {
    __typename?: "PullRequestTimelineConnection";
    /** A list of edges. */
    edges?: (PartialObjects["PullRequestTimelineItemEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["PullRequestTimelineItem"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An item in an pull request timeline */
  ["PullRequestTimelineItem"]:
    | PartialObjects["AssignedEvent"]
    | PartialObjects["BaseRefForcePushedEvent"]
    | PartialObjects["ClosedEvent"]
    | PartialObjects["Commit"]
    | PartialObjects["CommitCommentThread"]
    | PartialObjects["CrossReferencedEvent"]
    | PartialObjects["DemilestonedEvent"]
    | PartialObjects["DeployedEvent"]
    | PartialObjects["DeploymentEnvironmentChangedEvent"]
    | PartialObjects["HeadRefDeletedEvent"]
    | PartialObjects["HeadRefForcePushedEvent"]
    | PartialObjects["HeadRefRestoredEvent"]
    | PartialObjects["IssueComment"]
    | PartialObjects["LabeledEvent"]
    | PartialObjects["LockedEvent"]
    | PartialObjects["MergedEvent"]
    | PartialObjects["MilestonedEvent"]
    | PartialObjects["PullRequestReview"]
    | PartialObjects["PullRequestReviewComment"]
    | PartialObjects["PullRequestReviewThread"]
    | PartialObjects["ReferencedEvent"]
    | PartialObjects["RenamedTitleEvent"]
    | PartialObjects["ReopenedEvent"]
    | PartialObjects["ReviewDismissedEvent"]
    | PartialObjects["ReviewRequestRemovedEvent"]
    | PartialObjects["ReviewRequestedEvent"]
    | PartialObjects["SubscribedEvent"]
    | PartialObjects["UnassignedEvent"]
    | PartialObjects["UnlabeledEvent"]
    | PartialObjects["UnlockedEvent"]
    | PartialObjects["UnsubscribedEvent"];
  /** An edge in a connection. */
  ["PullRequestTimelineItemEdge"]: {
    __typename?: "PullRequestTimelineItemEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["PullRequestTimelineItem"];
  };
  /** A team or user who has the ability to push to a protected branch. */
  ["PushAllowance"]: {
    __typename?: "PushAllowance";
    /** The actor that can push. */
    actor?: PartialObjects["PushAllowanceActor"];
    id?: string;
    /** Identifies the protected branch associated with the allowed user or team. */
    protectedBranch?: PartialObjects["ProtectedBranch"];
  };
  /** Types that can be an actor. */
  ["PushAllowanceActor"]: PartialObjects["Team"] | PartialObjects["User"];
  /** The connection type for PushAllowance. */
  ["PushAllowanceConnection"]: {
    __typename?: "PushAllowanceConnection";
    /** A list of edges. */
    edges?: (PartialObjects["PushAllowanceEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["PushAllowance"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["PushAllowanceEdge"]: {
    __typename?: "PushAllowanceEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["PushAllowance"];
  };
  /** The query root of GitHub's GraphQL interface. */
  ["Query"]: {
    __typename?: "Query";
    /** Look up a code of conduct by its key */
    codeOfConduct?: PartialObjects["CodeOfConduct"];
    /** Look up a code of conduct by its key */
    codesOfConduct?: (PartialObjects["CodeOfConduct"] | undefined)[];
    /** Look up an open source license by its key */
    license?: PartialObjects["License"];
    /** Return a list of known open source licenses */
    licenses?: PartialObjects["License"][];
    /** Get alphabetically sorted list of Marketplace categories */
    marketplaceCategories?: PartialObjects["MarketplaceCategory"][];
    /** Look up a Marketplace category by its slug. */
    marketplaceCategory?: PartialObjects["MarketplaceCategory"];
    /** Look up a single Marketplace listing */
    marketplaceListing?: PartialObjects["MarketplaceListing"];
    /** Look up Marketplace listings */
    marketplaceListings?: PartialObjects["MarketplaceListingConnection"];
    /** Return information about the GitHub instance */
    meta?: PartialObjects["GitHubMetadata"];
    /** Fetches an object given its ID. */
    node?: PartialObjects["Node"];
    /** Lookup nodes by a list of IDs. */
    nodes?: PartialObjects["Node"][];
    /** Lookup a organization by login. */
    organization?: PartialObjects["Organization"];
    /** The client's rate limit information. */
    rateLimit?: PartialObjects["RateLimit"];
    /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */
    relay?: PartialObjects["Query"];
    /** Lookup a given repository by the owner and repository name. */
    repository?: PartialObjects["Repository"];
    /** Lookup a repository owner (ie. either a User or an Organization) by login. */
    repositoryOwner?: PartialObjects["RepositoryOwner"];
    /** Lookup resource by a URL. */
    resource?: PartialObjects["UniformResourceLocatable"];
    /** Perform a search across resources. */
    search?: PartialObjects["SearchResultItemConnection"];
    /** Look up a topic by name. */
    topic?: PartialObjects["Topic"];
    /** Lookup a user by login. */
    user?: PartialObjects["User"];
    /** The currently authenticated user. */
    viewer?: PartialObjects["User"];
  };
  /** Represents the client's rate limit. */
  ["RateLimit"]: {
    __typename?: "RateLimit";
    /** The point cost for the current query counting against the rate limit. */
    cost?: number;
    /** The maximum number of points the client is permitted to consume in a 60 minute window. */
    limit?: number;
    /** The maximum number of nodes this query may return */
    nodeCount?: number;
    /** The number of points remaining in the current rate limit window. */
    remaining?: number;
    /** The time at which the current rate limit window resets in UTC epoch seconds. */
    resetAt?: PartialObjects["DateTime"];
  };
  /** Represents a subject that can be reacted on. */
  ["Reactable"]: {
    id?: string;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: PartialObjects["ReactionGroup"][];
    /** A list of Reactions left on the Issue. */
    reactions?: PartialObjects["ReactionConnection"];
    /** Can user react to this subject */
    viewerCanReact?: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
  } & (
    | PartialObjects["CommitComment"]
    | PartialObjects["Issue"]
    | PartialObjects["IssueComment"]
    | PartialObjects["PullRequest"]
    | PartialObjects["PullRequestReviewComment"]
  );
  /** The connection type for User. */
  ["ReactingUserConnection"]: {
    __typename?: "ReactingUserConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ReactingUserEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["User"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a user that's made a reaction. */
  ["ReactingUserEdge"]: {
    __typename?: "ReactingUserEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    node?: PartialObjects["User"];
    /** The moment when the user made the reaction. */
    reactedAt?: PartialObjects["DateTime"];
  };
  /** An emoji reaction to a particular piece of content. */
  ["Reaction"]: {
    __typename?: "Reaction";
    /** Identifies the emoji reaction. */
    content?: PartialObjects["ReactionContent"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
    /** The reactable piece of content */
    reactable?: PartialObjects["Reactable"];
    /** Identifies the user who created this reaction. */
    user?: PartialObjects["User"];
  };
  /** A list of reactions that have been left on the subject. */
  ["ReactionConnection"]: {
    __typename?: "ReactionConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ReactionEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Reaction"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
    /** Whether or not the authenticated user has left a reaction on the subject. */
    viewerHasReacted?: boolean;
  };
  /** Emojis that can be attached to Issues, Pull Requests and Comments. */
  ["ReactionContent"]: ReactionContent;
  /** An edge in a connection. */
  ["ReactionEdge"]: {
    __typename?: "ReactionEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Reaction"];
  };
  /** A group of emoji reactions to a particular piece of content. */
  ["ReactionGroup"]: {
    __typename?: "ReactionGroup";
    /** Identifies the emoji reaction. */
    content?: PartialObjects["ReactionContent"];
    /** Identifies when the reaction was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The subject that was reacted to. */
    subject?: PartialObjects["Reactable"];
    /** Users who have reacted to the reaction subject with the emotion represented by this reaction group */
    users?: PartialObjects["ReactingUserConnection"];
    /** Whether or not the authenticated user has left a reaction on the subject. */
    viewerHasReacted?: boolean;
  };
  /** Ways in which lists of reactions can be ordered upon return. */
  ["ReactionOrder"]: {
    /** The direction in which to order reactions by the specified field. */
    direction: PartialObjects["OrderDirection"];
    /** The field in which to order reactions by. */
    field: PartialObjects["ReactionOrderField"];
  };
  /** A list of fields that reactions can be ordered by. */
  ["ReactionOrderField"]: ReactionOrderField;
  /** Represents a Git reference. */
  ["Ref"]: {
    __typename?: "Ref";
    /** A list of pull requests with this ref as the head ref. */
    associatedPullRequests?: PartialObjects["PullRequestConnection"];
    id?: string;
    /** The ref name. */
    name?: string;
    /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
    prefix?: string;
    /** The repository the ref belongs to. */
    repository?: PartialObjects["Repository"];
    /** The object the ref points to. */
    target?: PartialObjects["GitObject"];
  };
  /** The connection type for Ref. */
  ["RefConnection"]: {
    __typename?: "RefConnection";
    /** A list of edges. */
    edges?: (PartialObjects["RefEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Ref"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["RefEdge"]: {
    __typename?: "RefEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Ref"];
  };
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ["ReferencedEvent"]: {
    __typename?: "ReferencedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the commit associated with the 'referenced' event. */
    commit?: PartialObjects["Commit"];
    /** Identifies the repository associated with the 'referenced' event. */
    commitRepository?: PartialObjects["Repository"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Reference originated in a different repository. */
    isCrossRepository?: boolean;
    /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
    isDirectReference?: boolean;
    /** Object referenced by event. */
    subject?: PartialObjects["ReferencedSubject"];
  };
  /** Any referencable object */
  ["ReferencedSubject"]:
    | PartialObjects["Issue"]
    | PartialObjects["PullRequest"];
  /** Ways in which lists of git refs can be ordered upon return. */
  ["RefOrder"]: {
    /** The direction in which to order refs by the specified field. */
    direction: PartialObjects["OrderDirection"];
    /** The field in which to order refs by. */
    field: PartialObjects["RefOrderField"];
  };
  /** Properties by which ref connections can be ordered. */
  ["RefOrderField"]: RefOrderField;
  /** Represents an owner of a registry package. */
  ["RegistryPackageOwner"]: {
    id?: string;
  } & (
    | PartialObjects["Organization"]
    | PartialObjects["Repository"]
    | PartialObjects["User"]
  );
  /** Represents an interface to search packages on an object. */
  ["RegistryPackageSearch"]: {
    id?: string;
  } & (PartialObjects["Organization"] | PartialObjects["User"]);
  /** A release contains the content for a release. */
  ["Release"]: {
    __typename?: "Release";
    /** The author of the release */
    author?: PartialObjects["User"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the description of the release. */
    description?: string;
    id?: string;
    /** Whether or not the release is a draft */
    isDraft?: boolean;
    /** Whether or not the release is a prerelease */
    isPrerelease?: boolean;
    /** Identifies the title of the release. */
    name?: string;
    /** Identifies the date and time when the release was created. */
    publishedAt?: PartialObjects["DateTime"];
    /** List of releases assets which are dependent on this release. */
    releaseAssets?: PartialObjects["ReleaseAssetConnection"];
    /** The HTTP path for this issue */
    resourcePath?: PartialObjects["URI"];
    /** The Git tag the release points to */
    tag?: PartialObjects["Ref"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this issue */
    url?: PartialObjects["URI"];
  };
  /** A release asset contains the content for a release asset. */
  ["ReleaseAsset"]: {
    __typename?: "ReleaseAsset";
    /** The asset's content-type */
    contentType?: string;
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The number of times this asset was downloaded */
    downloadCount?: number;
    /** Identifies the URL where you can download the release asset via the browser. */
    downloadUrl?: PartialObjects["URI"];
    id?: string;
    /** Identifies the title of the release asset. */
    name?: string;
    /** Release that the asset is associated with */
    release?: PartialObjects["Release"];
    /** The size (in bytes) of the asset */
    size?: number;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The user that performed the upload */
    uploadedBy?: PartialObjects["User"];
    /** Identifies the URL of the release asset. */
    url?: PartialObjects["URI"];
  };
  /** The connection type for ReleaseAsset. */
  ["ReleaseAssetConnection"]: {
    __typename?: "ReleaseAssetConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ReleaseAssetEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["ReleaseAsset"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ReleaseAssetEdge"]: {
    __typename?: "ReleaseAssetEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["ReleaseAsset"];
  };
  /** The connection type for Release. */
  ["ReleaseConnection"]: {
    __typename?: "ReleaseConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ReleaseEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Release"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ReleaseEdge"]: {
    __typename?: "ReleaseEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Release"];
  };
  /** Ways in which lists of releases can be ordered upon return. */
  ["ReleaseOrder"]: {
    /** The direction in which to order releases by the specified field. */
    direction: PartialObjects["OrderDirection"];
    /** The field in which to order releases by. */
    field: PartialObjects["ReleaseOrderField"];
  };
  /** Properties by which release connections can be ordered. */
  ["ReleaseOrderField"]: ReleaseOrderField;
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  ["RemovedFromProjectEvent"]: {
    __typename?: "RemovedFromProjectEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
  };
  /** Autogenerated input type of RemoveOutsideCollaborator */
  ["RemoveOutsideCollaboratorInput"]: {
    /** The ID of the outside collaborator to remove. */
    userId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The ID of the organization to remove the outside collaborator from. */
    organizationId: string;
  };
  /** Autogenerated return type of RemoveOutsideCollaborator */
  ["RemoveOutsideCollaboratorPayload"]: {
    __typename?: "RemoveOutsideCollaboratorPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The user that was removed as an outside collaborator.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `removedUser` will change from `User!` to `User`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    removedUser?: PartialObjects["User"];
  };
  /** Autogenerated input type of RemoveReaction */
  ["RemoveReactionInput"]: {
    /** The Node ID of the subject to modify. */
    subjectId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of the emoji reaction to remove. */
    content: PartialObjects["ReactionContent"];
  };
  /** Autogenerated return type of RemoveReaction */
  ["RemoveReactionPayload"]: {
    __typename?: "RemoveReactionPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The reaction object.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reaction` will change from `Reaction!` to `Reaction`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    reaction?: PartialObjects["Reaction"];
    /** 														The reactable subject.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Reactable!` to `Reactable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subject?: PartialObjects["Reactable"];
  };
  /** Autogenerated input type of RemoveStar */
  ["RemoveStarInput"]: {
    /** The Starrable ID to unstar. */
    starrableId: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of RemoveStar */
  ["RemoveStarPayload"]: {
    __typename?: "RemoveStarPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The starrable.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `starrable` will change from `Starrable!` to `Starrable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    starrable?: PartialObjects["Starrable"];
  };
  /** Represents a 'renamed' event on a given issue or pull request */
  ["RenamedTitleEvent"]: {
    __typename?: "RenamedTitleEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the current title of the issue or pull request. */
    currentTitle?: string;
    id?: string;
    /** Identifies the previous title of the issue or pull request. */
    previousTitle?: string;
    /** Subject that was renamed. */
    subject?: PartialObjects["RenamedTitleSubject"];
  };
  /** An object which has a renamable title */
  ["RenamedTitleSubject"]:
    | PartialObjects["Issue"]
    | PartialObjects["PullRequest"];
  /** Represents a 'reopened' event on any `Closable`. */
  ["ReopenedEvent"]: {
    __typename?: "ReopenedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Object that was reopened. */
    closable?: PartialObjects["Closable"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
  };
  /** A repository contains the content for a project. */
  ["Repository"]: {
    __typename?: "Repository";
    /** A list of users that can be assigned to issues in this repository. */
    assignableUsers?: PartialObjects["UserConnection"];
    /** Returns the code of conduct for this repository */
    codeOfConduct?: PartialObjects["CodeOfConduct"];
    /** A list of collaborators associated with the repository. */
    collaborators?: PartialObjects["RepositoryCollaboratorConnection"];
    /** A list of commit comments associated with the repository. */
    commitComments?: PartialObjects["CommitCommentConnection"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The Ref associated with the repository's default branch. */
    defaultBranchRef?: PartialObjects["Ref"];
    /** A list of deploy keys that are on this repository. */
    deployKeys?: PartialObjects["DeployKeyConnection"];
    /** Deployments associated with the repository */
    deployments?: PartialObjects["DeploymentConnection"];
    /** The description of the repository. */
    description?: string;
    /** The description of the repository rendered to HTML. */
    descriptionHTML?: PartialObjects["HTML"];
    /** The number of kilobytes this repository occupies on disk. */
    diskUsage?: number;
    /** Returns how many forks there are of this repository in the whole network. */
    forkCount?: number;
    /** A list of direct forked repositories. */
    forks?: PartialObjects["RepositoryConnection"];
    /** Indicates if the repository has issues feature enabled. */
    hasIssuesEnabled?: boolean;
    /** Indicates if the repository has wiki feature enabled. */
    hasWikiEnabled?: boolean;
    /** The repository's URL. */
    homepageUrl?: PartialObjects["URI"];
    id?: string;
    /** Indicates if the repository is unmaintained. */
    isArchived?: boolean;
    /** Identifies if the repository is a fork. */
    isFork?: boolean;
    /** Indicates if the repository has been locked or not. */
    isLocked?: boolean;
    /** Identifies if the repository is a mirror. */
    isMirror?: boolean;
    /** Identifies if the repository is private. */
    isPrivate?: boolean;
    /** Returns a single issue from the current repository by number. */
    issue?: PartialObjects["Issue"];
    /** Returns a single issue-like object from the current repository by number. */
    issueOrPullRequest?: PartialObjects["IssueOrPullRequest"];
    /** A list of issues that have been opened in the repository. */
    issues?: PartialObjects["IssueConnection"];
    /** Returns a single label by name */
    label?: PartialObjects["Label"];
    /** A list of labels associated with the repository. */
    labels?: PartialObjects["LabelConnection"];
    /** A list containing a breakdown of the language composition of the repository. */
    languages?: PartialObjects["LanguageConnection"];
    /** The license associated with the repository */
    licenseInfo?: PartialObjects["License"];
    /** The reason the repository has been locked. */
    lockReason?: PartialObjects["RepositoryLockReason"];
    /** A list of Users that can be mentioned in the context of the repository. */
    mentionableUsers?: PartialObjects["UserConnection"];
    /** Whether or not PRs are merged with a merge commit on this repository. */
    mergeCommitAllowed?: boolean;
    /** Returns a single milestone from the current repository by number. */
    milestone?: PartialObjects["Milestone"];
    /** A list of milestones associated with the repository. */
    milestones?: PartialObjects["MilestoneConnection"];
    /** The repository's original mirror URL. */
    mirrorUrl?: PartialObjects["URI"];
    /** The name of the repository. */
    name?: string;
    /** The repository's name with owner. */
    nameWithOwner?: string;
    /** A Git object in the repository */
    object?: PartialObjects["GitObject"];
    /** The User owner of the repository. */
    owner?: PartialObjects["RepositoryOwner"];
    /** The repository parent, if this is a fork. */
    parent?: PartialObjects["Repository"];
    /** The primary language of the repository's code. */
    primaryLanguage?: PartialObjects["Language"];
    /** Find project by number. */
    project?: PartialObjects["Project"];
    /** A list of projects under the owner. */
    projects?: PartialObjects["ProjectConnection"];
    /** The HTTP path listing the repository's projects */
    projectsResourcePath?: PartialObjects["URI"];
    /** The HTTP URL listing the repository's projects */
    projectsUrl?: PartialObjects["URI"];
    /** A list of protected branches that are on this repository. */
    protectedBranches?: PartialObjects["ProtectedBranchConnection"];
    /** Returns a single pull request from the current repository by number. */
    pullRequest?: PartialObjects["PullRequest"];
    /** A list of pull requests that have been opened in the repository. */
    pullRequests?: PartialObjects["PullRequestConnection"];
    /** Identifies when the repository was last pushed to. */
    pushedAt?: PartialObjects["DateTime"];
    /** Whether or not rebase-merging is enabled on this repository. */
    rebaseMergeAllowed?: boolean;
    /** Fetch a given ref from the repository */
    ref?: PartialObjects["Ref"];
    /** Fetch a list of refs from the repository */
    refs?: PartialObjects["RefConnection"];
    /** Lookup a single release given various criteria. */
    release?: PartialObjects["Release"];
    /** List of releases which are dependent on this repository. */
    releases?: PartialObjects["ReleaseConnection"];
    /** A list of applied repository-topic associations for this repository. */
    repositoryTopics?: PartialObjects["RepositoryTopicConnection"];
    /** The HTTP path for this repository */
    resourcePath?: PartialObjects["URI"];
    /** A description of the repository, rendered to HTML without any links in it. */
    shortDescriptionHTML?: PartialObjects["HTML"];
    /** Whether or not squash-merging is enabled on this repository. */
    squashMergeAllowed?: boolean;
    /** The SSH URL to clone this repository */
    sshUrl?: PartialObjects["GitSSHRemote"];
    /** A list of users who have starred this starrable. */
    stargazers?: PartialObjects["StargazerConnection"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this repository */
    url?: PartialObjects["URI"];
    /** Indicates whether the viewer has admin permissions on this repository. */
    viewerCanAdminister?: boolean;
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects?: boolean;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: boolean;
    /** Indicates whether the viewer can update the topics of this repository. */
    viewerCanUpdateTopics?: boolean;
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred?: boolean;
    /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
    viewerPermission?: PartialObjects["RepositoryPermission"];
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: PartialObjects["SubscriptionState"];
    /** A list of users watching the repository. */
    watchers?: PartialObjects["UserConnection"];
  };
  /** The affiliation of a user to a repository */
  ["RepositoryAffiliation"]: RepositoryAffiliation;
  /** The connection type for User. */
  ["RepositoryCollaboratorConnection"]: {
    __typename?: "RepositoryCollaboratorConnection";
    /** A list of edges. */
    edges?: (PartialObjects["RepositoryCollaboratorEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["User"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a user who is a collaborator of a repository. */
  ["RepositoryCollaboratorEdge"]: {
    __typename?: "RepositoryCollaboratorEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    node?: PartialObjects["User"];
    /** The permission the user has on the repository. */
    permission?: PartialObjects["RepositoryPermission"];
  };
  /** A list of repositories owned by the subject. */
  ["RepositoryConnection"]: {
    __typename?: "RepositoryConnection";
    /** A list of edges. */
    edges?: (PartialObjects["RepositoryEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Repository"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
    /** The total size in kilobytes of all repositories in the connection. */
    totalDiskUsage?: number;
  };
  /** The reason a repository is listed as 'contributed'. */
  ["RepositoryContributionType"]: RepositoryContributionType;
  /** An edge in a connection. */
  ["RepositoryEdge"]: {
    __typename?: "RepositoryEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Repository"];
  };
  /** A subset of repository info. */
  ["RepositoryInfo"]: {
    /** Indicates if the repository has issues feature enabled. */
    hasIssuesEnabled?: boolean;
    /** The HTTP path for this repository */
    resourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this repository */
    url?: PartialObjects["URI"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Indicates if the repository has been locked or not. */
    isLocked?: boolean;
    /** The description of the repository. */
    description?: string;
    /** A description of the repository, rendered to HTML without any links in it. */
    shortDescriptionHTML?: PartialObjects["HTML"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** Identifies if the repository is a mirror. */
    isMirror?: boolean;
    /** Identifies if the repository is a fork. */
    isFork?: boolean;
    /** Identifies when the repository was last pushed to. */
    pushedAt?: PartialObjects["DateTime"];
    /** The name of the repository. */
    name?: string;
    /** The repository's name with owner. */
    nameWithOwner?: string;
    /** The description of the repository rendered to HTML. */
    descriptionHTML?: PartialObjects["HTML"];
    /** Indicates if the repository has wiki feature enabled. */
    hasWikiEnabled?: boolean;
    /** The repository's URL. */
    homepageUrl?: PartialObjects["URI"];
    /** The User owner of the repository. */
    owner?: PartialObjects["RepositoryOwner"];
    /** The reason the repository has been locked. */
    lockReason?: PartialObjects["RepositoryLockReason"];
    /** Identifies if the repository is private. */
    isPrivate?: boolean;
    /** The repository's original mirror URL. */
    mirrorUrl?: PartialObjects["URI"];
    /** Returns how many forks there are of this repository in the whole network. */
    forkCount?: number;
    /** Indicates if the repository is unmaintained. */
    isArchived?: boolean;
    /** The license associated with the repository */
    licenseInfo?: PartialObjects["License"];
  } & PartialObjects["Repository"];
  /** An invitation for a user to be added to a repository. */
  ["RepositoryInvitation"]: {
    __typename?: "RepositoryInvitation";
    id?: string;
    /** The user who received the invitation. */
    invitee?: PartialObjects["User"];
    /** The user who created the invitation. */
    inviter?: PartialObjects["User"];
    /** The permission granted on this repository by this invitation. */
    permission?: PartialObjects["RepositoryPermission"];
    /** The Repository the user is invited to. */
    repository?: PartialObjects["RepositoryInfo"];
  };
  /** The possible reasons a given repository could be in a locked state. */
  ["RepositoryLockReason"]: RepositoryLockReason;
  /** Represents a object that belongs to a repository. */
  ["RepositoryNode"]: {
    /** The repository associated with this node. */
    repository?: PartialObjects["Repository"];
  } & (
    | PartialObjects["CommitComment"]
    | PartialObjects["CommitCommentThread"]
    | PartialObjects["Issue"]
    | PartialObjects["IssueComment"]
    | PartialObjects["PullRequest"]
    | PartialObjects["PullRequestReview"]
    | PartialObjects["PullRequestReviewComment"]
  );
  /** Ordering options for repository connections */
  ["RepositoryOrder"]: {
    /** The ordering direction. */
    direction: PartialObjects["OrderDirection"];
    /** The field to order repositories by. */
    field: PartialObjects["RepositoryOrderField"];
  };
  /** Properties by which repository connections can be ordered. */
  ["RepositoryOrderField"]: RepositoryOrderField;
  /** Represents an owner of a Repository. */
  ["RepositoryOwner"]: {
    /** The username used to login. */
    login?: string;
    /** A list of repositories this user has pinned to their profile */
    pinnedRepositories?: PartialObjects["RepositoryConnection"];
    /** A list of repositories that the user owns. */
    repositories?: PartialObjects["RepositoryConnection"];
    /** Find Repository. */
    repository?: PartialObjects["Repository"];
    /** The HTTP URL for the owner. */
    resourcePath?: PartialObjects["URI"];
    /** The HTTP URL for the owner. */
    url?: PartialObjects["URI"];
    /** A URL pointing to the owner's public avatar. */
    avatarUrl?: PartialObjects["URI"];
    id?: string;
  } & (PartialObjects["Organization"] | PartialObjects["User"]);
  /** The access level to a repository */
  ["RepositoryPermission"]: RepositoryPermission;
  /** The privacy of a repository */
  ["RepositoryPrivacy"]: RepositoryPrivacy;
  /** A repository-topic connects a repository to a topic. */
  ["RepositoryTopic"]: {
    __typename?: "RepositoryTopic";
    id?: string;
    /** The HTTP path for this repository-topic. */
    resourcePath?: PartialObjects["URI"];
    /** The topic. */
    topic?: PartialObjects["Topic"];
    /** The HTTP URL for this repository-topic. */
    url?: PartialObjects["URI"];
  };
  /** The connection type for RepositoryTopic. */
  ["RepositoryTopicConnection"]: {
    __typename?: "RepositoryTopicConnection";
    /** A list of edges. */
    edges?: (PartialObjects["RepositoryTopicEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["RepositoryTopic"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["RepositoryTopicEdge"]: {
    __typename?: "RepositoryTopicEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["RepositoryTopic"];
  };
  /** Types that can be requested reviewers. */
  ["RequestedReviewer"]: PartialObjects["Team"] | PartialObjects["User"];
  /** Autogenerated input type of RequestReviews */
  ["RequestReviewsInput"]: {
    /** The Node IDs of the team to request. */
    teamIds?: string[];
    /** Add users to the set rather than replace. */
    union?: boolean;
    /** The Node IDs of the user to request. */
    userIds?: string[];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the pull request to modify. */
    pullRequestId: string;
  };
  /** Autogenerated return type of RequestReviews */
  ["RequestReviewsPayload"]: {
    __typename?: "RequestReviewsPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The pull request that is getting requests.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequest` will change from `PullRequest!` to `PullRequest`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequest?: PartialObjects["PullRequest"];
    /** 														The edge from the pull request to the requested reviewers.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `requestedReviewersEdge` will change from `UserEdge!` to `UserEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    requestedReviewersEdge?: PartialObjects["UserEdge"];
  };
  /** A team or user who has the ability to dismiss a review on a protected branch. */
  ["ReviewDismissalAllowance"]: {
    __typename?: "ReviewDismissalAllowance";
    /** The actor that can dismiss. */
    actor?: PartialObjects["ReviewDismissalAllowanceActor"];
    id?: string;
    /** Identifies the protected branch associated with the allowed user or team. */
    protectedBranch?: PartialObjects["ProtectedBranch"];
  };
  /** Types that can be an actor. */
  ["ReviewDismissalAllowanceActor"]:
    | PartialObjects["Team"]
    | PartialObjects["User"];
  /** The connection type for ReviewDismissalAllowance. */
  ["ReviewDismissalAllowanceConnection"]: {
    __typename?: "ReviewDismissalAllowanceConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ReviewDismissalAllowanceEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["ReviewDismissalAllowance"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["ReviewDismissalAllowanceEdge"]: {
    __typename?: "ReviewDismissalAllowanceEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["ReviewDismissalAllowance"];
  };
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ["ReviewDismissedEvent"]: {
    __typename?: "ReviewDismissedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
    /** Identifies the message associated with the 'review_dismissed' event. */
    message?: string;
    /** The message associated with the event, rendered to HTML. */
    messageHtml?: PartialObjects["HTML"];
    /** Identifies the previous state of the review with the 'review_dismissed' event. */
    previousReviewState?: PartialObjects["PullRequestReviewState"];
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
    /** Identifies the commit which caused the review to become stale. */
    pullRequestCommit?: PartialObjects["PullRequestCommit"];
    /** The HTTP path for this review dismissed event. */
    resourcePath?: PartialObjects["URI"];
    /** Identifies the review associated with the 'review_dismissed' event. */
    review?: PartialObjects["PullRequestReview"];
    /** The HTTP URL for this review dismissed event. */
    url?: PartialObjects["URI"];
  };
  /** A request for a user to review a pull request. */
  ["ReviewRequest"]: {
    __typename?: "ReviewRequest";
    /** Identifies the primary key from the database. */
    databaseId?: number;
    id?: string;
    /** Identifies the pull request associated with this review request. */
    pullRequest?: PartialObjects["PullRequest"];
    /** The reviewer that is requested. */
    requestedReviewer?: PartialObjects["RequestedReviewer"];
  };
  /** The connection type for ReviewRequest. */
  ["ReviewRequestConnection"]: {
    __typename?: "ReviewRequestConnection";
    /** A list of edges. */
    edges?: (PartialObjects["ReviewRequestEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["ReviewRequest"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents an 'review_requested' event on a given pull request. */
  ["ReviewRequestedEvent"]: {
    __typename?: "ReviewRequestedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
    /** Identifies the reviewer whose review was requested. */
    requestedReviewer?: PartialObjects["RequestedReviewer"];
  };
  /** An edge in a connection. */
  ["ReviewRequestEdge"]: {
    __typename?: "ReviewRequestEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["ReviewRequest"];
  };
  /** Represents an 'review_request_removed' event on a given pull request. */
  ["ReviewRequestRemovedEvent"]: {
    __typename?: "ReviewRequestRemovedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** PullRequest referenced by event. */
    pullRequest?: PartialObjects["PullRequest"];
    /** Identifies the reviewer whose review request was removed. */
    requestedReviewer?: PartialObjects["RequestedReviewer"];
  };
  /** The results of a search. */
  ["SearchResultItem"]:
    | PartialObjects["Issue"]
    | PartialObjects["MarketplaceListing"]
    | PartialObjects["Organization"]
    | PartialObjects["PullRequest"]
    | PartialObjects["Repository"]
    | PartialObjects["User"];
  /** A list of results that matched against a search query. */
  ["SearchResultItemConnection"]: {
    __typename?: "SearchResultItemConnection";
    /** The number of pieces of code that matched the search query. */
    codeCount?: number;
    /** A list of edges. */
    edges?: (PartialObjects["SearchResultItemEdge"] | undefined)[];
    /** The number of issues that matched the search query. */
    issueCount?: number;
    /** A list of nodes. */
    nodes?: (PartialObjects["SearchResultItem"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** The number of repositories that matched the search query. */
    repositoryCount?: number;
    /** The number of users that matched the search query. */
    userCount?: number;
    /** The number of wiki pages that matched the search query. */
    wikiCount?: number;
  };
  /** An edge in a connection. */
  ["SearchResultItemEdge"]: {
    __typename?: "SearchResultItemEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["SearchResultItem"];
    /** Text matches on the result found. */
    textMatches?: (PartialObjects["TextMatch"] | undefined)[];
  };
  /** Represents the individual results of a search. */
  ["SearchType"]: SearchType;
  /** Represents an S/MIME signature on a Commit or Tag. */
  ["SmimeSignature"]: {
    __typename?: "SmimeSignature";
    /** Email used to sign this object. */
    email?: string;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: boolean;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: string;
    /** ASCII-armored signature header from object. */
    signature?: string;
    /** GitHub user corresponding to the email signing this commit. */
    signer?: PartialObjects["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: PartialObjects["GitSignatureState"];
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: boolean;
  };
  /** The connection type for User. */
  ["StargazerConnection"]: {
    __typename?: "StargazerConnection";
    /** A list of edges. */
    edges?: (PartialObjects["StargazerEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["User"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a user that's starred a repository. */
  ["StargazerEdge"]: {
    __typename?: "StargazerEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    node?: PartialObjects["User"];
    /** Identifies when the item was starred. */
    starredAt?: PartialObjects["DateTime"];
  };
  /** Ways in which star connections can be ordered. */
  ["StarOrder"]: {
    /** The direction in which to order nodes. */
    direction: PartialObjects["OrderDirection"];
    /** The field in which to order nodes by. */
    field: PartialObjects["StarOrderField"];
  };
  /** Properties by which star connections can be ordered. */
  ["StarOrderField"]: StarOrderField;
  /** Things that can be starred. */
  ["Starrable"]: {
    id?: string;
    /** A list of users who have starred this starrable. */
    stargazers?: PartialObjects["StargazerConnection"];
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred?: boolean;
  } & (PartialObjects["Gist"] | PartialObjects["Repository"]);
  /** The connection type for Repository. */
  ["StarredRepositoryConnection"]: {
    __typename?: "StarredRepositoryConnection";
    /** A list of edges. */
    edges?: (PartialObjects["StarredRepositoryEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Repository"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a starred repository. */
  ["StarredRepositoryEdge"]: {
    __typename?: "StarredRepositoryEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    node?: PartialObjects["Repository"];
    /** Identifies when the item was starred. */
    starredAt?: PartialObjects["DateTime"];
  };
  /** Represents a commit status. */
  ["Status"]: {
    __typename?: "Status";
    /** The commit this status is attached to. */
    commit?: PartialObjects["Commit"];
    /** Looks up an individual status context by context name. */
    context?: PartialObjects["StatusContext"];
    /** The individual status contexts for this commit. */
    contexts?: PartialObjects["StatusContext"][];
    id?: string;
    /** The combined commit status. */
    state?: PartialObjects["StatusState"];
  };
  /** Represents an individual commit status context */
  ["StatusContext"]: {
    __typename?: "StatusContext";
    /** This commit this status context is attached to. */
    commit?: PartialObjects["Commit"];
    /** The name of this status context. */
    context?: string;
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The actor who created this status context. */
    creator?: PartialObjects["Actor"];
    /** The description for this status context. */
    description?: string;
    id?: string;
    /** The state of this status context. */
    state?: PartialObjects["StatusState"];
    /** The URL for this status context. */
    targetUrl?: PartialObjects["URI"];
  };
  /** The possible commit status states. */
  ["StatusState"]: StatusState;
  /** Autogenerated input type of SubmitPullRequestReview */
  ["SubmitPullRequestReviewInput"]: {
    /** The text field to set on the Pull Request Review. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The event to send to the Pull Request Review. */
    event: PartialObjects["PullRequestReviewEvent"];
    /** The Pull Request Review ID to submit. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of SubmitPullRequestReview */
  ["SubmitPullRequestReviewPayload"]: {
    __typename?: "SubmitPullRequestReviewPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The submitted pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: PartialObjects["PullRequestReview"];
  };
  /** Entities that can be subscribed to for web and email notifications. */
  ["Subscribable"]: {
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: boolean;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: PartialObjects["SubscriptionState"];
    id?: string;
  } & (
    | PartialObjects["Commit"]
    | PartialObjects["Issue"]
    | PartialObjects["PullRequest"]
    | PartialObjects["Repository"]
    | PartialObjects["Team"]
  );
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  ["SubscribedEvent"]: {
    __typename?: "SubscribedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Object referenced by event. */
    subscribable?: PartialObjects["Subscribable"];
  };
  /** The possible states of a subscription. */
  ["SubscriptionState"]: SubscriptionState;
  /** A suggestion to review a pull request based on a user's commit history and review comments. */
  ["SuggestedReviewer"]: {
    __typename?: "SuggestedReviewer";
    /** Is this suggestion based on past commits? */
    isAuthor?: boolean;
    /** Is this suggestion based on past review comments? */
    isCommenter?: boolean;
    /** Identifies the user suggested to review the pull request. */
    reviewer?: PartialObjects["User"];
  };
  /** Represents a Git tag. */
  ["Tag"]: {
    __typename?: "Tag";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: string;
    /** The HTTP path for this Git object */
    commitResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this Git object */
    commitUrl?: PartialObjects["URI"];
    id?: string;
    /** The Git tag message. */
    message?: string;
    /** The Git tag name. */
    name?: string;
    /** The Git object ID */
    oid?: PartialObjects["GitObjectID"];
    /** The Repository the Git object belongs to */
    repository?: PartialObjects["Repository"];
    /** Details about the tag author. */
    tagger?: PartialObjects["GitActor"];
    /** The Git object the tag points to. */
    target?: PartialObjects["GitObject"];
  };
  /** A team of users in an organization. */
  ["Team"]: {
    __typename?: "Team";
    /** A list of teams that are ancestors of this team. */
    ancestors?: PartialObjects["TeamConnection"];
    /** A URL pointing to the team's avatar. */
    avatarUrl?: PartialObjects["URI"];
    /** List of child teams belonging to this team */
    childTeams?: PartialObjects["TeamConnection"];
    /** The slug corresponding to the organization and team. */
    combinedSlug?: string;
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** The description of the team. */
    description?: string;
    /** The HTTP path for editing this team */
    editTeamResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for editing this team */
    editTeamUrl?: PartialObjects["URI"];
    id?: string;
    /** A list of pending invitations for users to this team */
    invitations?: PartialObjects["OrganizationInvitationConnection"];
    /** A list of users who are members of this team. */
    members?: PartialObjects["TeamMemberConnection"];
    /** The HTTP path for the team' members */
    membersResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for the team' members */
    membersUrl?: PartialObjects["URI"];
    /** The name of the team. */
    name?: string;
    /** The HTTP path creating a new team */
    newTeamResourcePath?: PartialObjects["URI"];
    /** The HTTP URL creating a new team */
    newTeamUrl?: PartialObjects["URI"];
    /** The organization that owns this team. */
    organization?: PartialObjects["Organization"];
    /** The parent team of the team. */
    parentTeam?: PartialObjects["Team"];
    /** The level of privacy the team has. */
    privacy?: PartialObjects["TeamPrivacy"];
    /** A list of repositories this team has access to. */
    repositories?: PartialObjects["TeamRepositoryConnection"];
    /** The HTTP path for this team's repositories */
    repositoriesResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this team's repositories */
    repositoriesUrl?: PartialObjects["URI"];
    /** The HTTP path for this team */
    resourcePath?: PartialObjects["URI"];
    /** The slug corresponding to the team. */
    slug?: string;
    /** The HTTP path for this team's teams */
    teamsResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this team's teams */
    teamsUrl?: PartialObjects["URI"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this team */
    url?: PartialObjects["URI"];
    /** Team is adminable by the viewer. */
    viewerCanAdminister?: boolean;
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe?: boolean;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: PartialObjects["SubscriptionState"];
  };
  /** The connection type for Team. */
  ["TeamConnection"]: {
    __typename?: "TeamConnection";
    /** A list of edges. */
    edges?: (PartialObjects["TeamEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Team"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["TeamEdge"]: {
    __typename?: "TeamEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["Team"];
  };
  /** The connection type for User. */
  ["TeamMemberConnection"]: {
    __typename?: "TeamMemberConnection";
    /** A list of edges. */
    edges?: (PartialObjects["TeamMemberEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["User"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a user who is a member of a team. */
  ["TeamMemberEdge"]: {
    __typename?: "TeamMemberEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The HTTP path to the organization's member access page. */
    memberAccessResourcePath?: PartialObjects["URI"];
    /** The HTTP URL to the organization's member access page. */
    memberAccessUrl?: PartialObjects["URI"];
    node?: PartialObjects["User"];
    /** The role the member has on the team. */
    role?: PartialObjects["TeamMemberRole"];
  };
  /** Ordering options for team member connections */
  ["TeamMemberOrder"]: {
    /** The field to order team members by. */
    field: PartialObjects["TeamMemberOrderField"];
    /** The ordering direction. */
    direction: PartialObjects["OrderDirection"];
  };
  /** Properties by which team member connections can be ordered. */
  ["TeamMemberOrderField"]: TeamMemberOrderField;
  /** The possible team member roles; either 'maintainer' or 'member'. */
  ["TeamMemberRole"]: TeamMemberRole;
  /** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
  ["TeamMembershipType"]: TeamMembershipType;
  /** Ways in which team connections can be ordered. */
  ["TeamOrder"]: {
    /** The direction in which to order nodes. */
    direction: PartialObjects["OrderDirection"];
    /** The field in which to order nodes by. */
    field: PartialObjects["TeamOrderField"];
  };
  /** Properties by which team connections can be ordered. */
  ["TeamOrderField"]: TeamOrderField;
  /** The possible team privacy values. */
  ["TeamPrivacy"]: TeamPrivacy;
  /** The connection type for Repository. */
  ["TeamRepositoryConnection"]: {
    __typename?: "TeamRepositoryConnection";
    /** A list of edges. */
    edges?: (PartialObjects["TeamRepositoryEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["Repository"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** Represents a team repository. */
  ["TeamRepositoryEdge"]: {
    __typename?: "TeamRepositoryEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    node?: PartialObjects["Repository"];
    /** The permission level the team has on the repository */
    permission?: PartialObjects["RepositoryPermission"];
  };
  /** Ordering options for team repository connections */
  ["TeamRepositoryOrder"]: {
    /** The ordering direction. */
    direction: PartialObjects["OrderDirection"];
    /** The field to order repositories by. */
    field: PartialObjects["TeamRepositoryOrderField"];
  };
  /** Properties by which team repository connections can be ordered. */
  ["TeamRepositoryOrderField"]: TeamRepositoryOrderField;
  /** The role of a user on a team. */
  ["TeamRole"]: TeamRole;
  /** A text match within a search result. */
  ["TextMatch"]: {
    __typename?: "TextMatch";
    /** The specific text fragment within the property matched on. */
    fragment?: string;
    /** Highlights within the matched fragment. */
    highlights?: PartialObjects["TextMatchHighlight"][];
    /** The property matched on. */
    property?: string;
  };
  /** Represents a single highlight in a search result match. */
  ["TextMatchHighlight"]: {
    __typename?: "TextMatchHighlight";
    /** The indice in the fragment where the matched text begins. */
    beginIndice?: number;
    /** The indice in the fragment where the matched text ends. */
    endIndice?: number;
    /** The text matched. */
    text?: string;
  };
  /** A topic aggregates entities that are related to a subject. */
  ["Topic"]: {
    __typename?: "Topic";
    id?: string;
    /** The topic's name. */
    name?: string;
    /** 																A list of related topics, including aliases of this topic, sorted with the most relevant
first. */
    relatedTopics?: PartialObjects["Topic"][];
  };
  /** Reason that the suggested topic is declined. */
  ["TopicSuggestionDeclineReason"]: TopicSuggestionDeclineReason;
  /** Represents a Git tree. */
  ["Tree"]: {
    __typename?: "Tree";
    /** An abbreviated version of the Git object ID */
    abbreviatedOid?: string;
    /** The HTTP path for this Git object */
    commitResourcePath?: PartialObjects["URI"];
    /** The HTTP URL for this Git object */
    commitUrl?: PartialObjects["URI"];
    /** A list of tree entries. */
    entries?: PartialObjects["TreeEntry"][];
    id?: string;
    /** The Git object ID */
    oid?: PartialObjects["GitObjectID"];
    /** The Repository the Git object belongs to */
    repository?: PartialObjects["Repository"];
  };
  /** Represents a Git tree entry. */
  ["TreeEntry"]: {
    __typename?: "TreeEntry";
    /** Entry file mode. */
    mode?: number;
    /** Entry file name. */
    name?: string;
    /** Entry file object. */
    object?: PartialObjects["GitObject"];
    /** Entry file Git object ID. */
    oid?: PartialObjects["GitObjectID"];
    /** The Repository the tree entry belongs to */
    repository?: PartialObjects["Repository"];
    /** Entry file type. */
    type?: string;
  };
  /** Represents an 'unassigned' event on any assignable object. */
  ["UnassignedEvent"]: {
    __typename?: "UnassignedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the assignable associated with the event. */
    assignable?: PartialObjects["Assignable"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Identifies the subject (user) who was unassigned. */
    user?: PartialObjects["User"];
  };
  /** Represents a type that can be retrieved by a URL. */
  ["UniformResourceLocatable"]: {
    /** The HTML path to this resource. */
    resourcePath?: PartialObjects["URI"];
    /** The URL to this resource. */
    url?: PartialObjects["URI"];
  } & (
    | PartialObjects["Bot"]
    | PartialObjects["ClosedEvent"]
    | PartialObjects["CrossReferencedEvent"]
    | PartialObjects["Issue"]
    | PartialObjects["MergedEvent"]
    | PartialObjects["Milestone"]
    | PartialObjects["Organization"]
    | PartialObjects["PullRequest"]
    | PartialObjects["PullRequestCommit"]
    | PartialObjects["Release"]
    | PartialObjects["Repository"]
    | PartialObjects["RepositoryTopic"]
    | PartialObjects["ReviewDismissedEvent"]
    | PartialObjects["User"]
  );
  /** Represents an unknown signature on a Commit or Tag. */
  ["UnknownSignature"]: {
    __typename?: "UnknownSignature";
    /** Email used to sign this object. */
    email?: string;
    /** True if the signature is valid and verified by GitHub. */
    isValid?: boolean;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload?: string;
    /** ASCII-armored signature header from object. */
    signature?: string;
    /** GitHub user corresponding to the email signing this commit. */
    signer?: PartialObjects["User"];
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state?: PartialObjects["GitSignatureState"];
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub?: boolean;
  };
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  ["UnlabeledEvent"]: {
    __typename?: "UnlabeledEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Identifies the label associated with the 'unlabeled' event. */
    label?: PartialObjects["Label"];
    /** Identifies the `Labelable` associated with the event. */
    labelable?: PartialObjects["Labelable"];
  };
  /** Represents an 'unlocked' event on a given issue or pull request. */
  ["UnlockedEvent"]: {
    __typename?: "UnlockedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Object that was unlocked. */
    lockable?: PartialObjects["Lockable"];
  };
  /** Autogenerated input type of UnlockLockable */
  ["UnlockLockableInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** ID of the issue or pull request to be unlocked. */
    lockableId: string;
  };
  /** Autogenerated return type of UnlockLockable */
  ["UnlockLockablePayload"]: {
    __typename?: "UnlockLockablePayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The item that was unlocked. */
    unlockedRecord?: PartialObjects["Lockable"];
  };
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  ["UnsubscribedEvent"]: {
    __typename?: "UnsubscribedEvent";
    /** Identifies the actor who performed the event. */
    actor?: PartialObjects["Actor"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    id?: string;
    /** Object referenced by event. */
    subscribable?: PartialObjects["Subscribable"];
  };
  /** Entities that can be updated. */
  ["Updatable"]: {
    /** Check if the current viewer can update this object. */
    viewerCanUpdate?: boolean;
  } & (
    | PartialObjects["CommitComment"]
    | PartialObjects["GistComment"]
    | PartialObjects["Issue"]
    | PartialObjects["IssueComment"]
    | PartialObjects["Project"]
    | PartialObjects["PullRequest"]
    | PartialObjects["PullRequestReview"]
    | PartialObjects["PullRequestReviewComment"]
  );
  /** Comments that can be updated. */
  ["UpdatableComment"]: {
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons?: PartialObjects["CommentCannotUpdateReason"][];
  } & (
    | PartialObjects["CommitComment"]
    | PartialObjects["GistComment"]
    | PartialObjects["Issue"]
    | PartialObjects["IssueComment"]
    | PartialObjects["PullRequest"]
    | PartialObjects["PullRequestReview"]
    | PartialObjects["PullRequestReviewComment"]
  );
  /** Autogenerated input type of UpdateProjectCard */
  ["UpdateProjectCardInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** Whether or not the ProjectCard should be archived */
    isArchived?: boolean;
    /** The note of ProjectCard. */
    note?: string;
    /** The ProjectCard ID to update. */
    projectCardId: string;
  };
  /** Autogenerated return type of UpdateProjectCard */
  ["UpdateProjectCardPayload"]: {
    __typename?: "UpdateProjectCardPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The updated ProjectCard.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectCard` will change from `ProjectCard!` to `ProjectCard`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    projectCard?: PartialObjects["ProjectCard"];
  };
  /** Autogenerated input type of UpdateProjectColumn */
  ["UpdateProjectColumnInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of project column. */
    name: string;
    /** The ProjectColumn ID to update. */
    projectColumnId: string;
  };
  /** Autogenerated return type of UpdateProjectColumn */
  ["UpdateProjectColumnPayload"]: {
    __typename?: "UpdateProjectColumnPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The updated project column.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectColumn` will change from `ProjectColumn!` to `ProjectColumn`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    projectColumn?: PartialObjects["ProjectColumn"];
  };
  /** Autogenerated input type of UpdateProject */
  ["UpdateProjectInput"]: {
    /** The description of project. */
    body?: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The name of project. */
    name?: string;
    /** The Project ID to update. */
    projectId: string;
    /** Whether the project is public or not. */
    public?: boolean;
    /** Whether the project is open or closed. */
    state?: PartialObjects["ProjectState"];
  };
  /** Autogenerated return type of UpdateProject */
  ["UpdateProjectPayload"]: {
    __typename?: "UpdateProjectPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The updated project.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    project?: PartialObjects["Project"];
  };
  /** Autogenerated input type of UpdatePullRequestReviewComment */
  ["UpdatePullRequestReviewCommentInput"]: {
    /** The text of the comment. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the comment to modify. */
    pullRequestReviewCommentId: string;
  };
  /** Autogenerated return type of UpdatePullRequestReviewComment */
  ["UpdatePullRequestReviewCommentPayload"]: {
    __typename?: "UpdatePullRequestReviewCommentPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The updated comment.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReviewComment` will change from
  `PullRequestReviewComment!` to `PullRequestReviewComment`.
  **Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReviewComment?: PartialObjects["PullRequestReviewComment"];
  };
  /** Autogenerated input type of UpdatePullRequestReview */
  ["UpdatePullRequestReviewInput"]: {
    /** The contents of the pull request review body. */
    body: string;
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The Node ID of the pull request review to modify. */
    pullRequestReviewId: string;
  };
  /** Autogenerated return type of UpdatePullRequestReview */
  ["UpdatePullRequestReviewPayload"]: {
    __typename?: "UpdatePullRequestReviewPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The updated pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    pullRequestReview?: PartialObjects["PullRequestReview"];
  };
  /** Autogenerated input type of UpdateSubscription */
  ["UpdateSubscriptionInput"]: {
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** The new state of the subscription. */
    state: PartialObjects["SubscriptionState"];
    /** The Node ID of the subscribable object to modify. */
    subscribableId: string;
  };
  /** Autogenerated return type of UpdateSubscription */
  ["UpdateSubscriptionPayload"]: {
    __typename?: "UpdateSubscriptionPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** 														The input subscribable entity.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subscribable` will change from `Subscribable!` to `Subscribable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    subscribable?: PartialObjects["Subscribable"];
  };
  /** Autogenerated input type of UpdateTopics */
  ["UpdateTopicsInput"]: {
    /** The Node ID of the repository. */
    repositoryId: string;
    /** An array of topic names. */
    topicNames: string[];
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
  };
  /** Autogenerated return type of UpdateTopics */
  ["UpdateTopicsPayload"]: {
    __typename?: "UpdateTopicsPayload";
    /** A unique identifier for the client performing the mutation. */
    clientMutationId?: string;
    /** Names of the provided topics that are not valid. */
    invalidTopicNames?: string[];
    /** 														The updated repository.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `repository` will change from `Repository!` to `Repository`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
    repository?: PartialObjects["Repository"];
  };
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  ["URI"]: any;
  /** A user is an individual's account on GitHub that owns repositories and can make new content. */
  ["User"]: {
    __typename?: "User";
    /** A URL pointing to the user's public avatar. */
    avatarUrl?: PartialObjects["URI"];
    /** The user's public profile bio. */
    bio?: string;
    /** The user's public profile bio as HTML. */
    bioHTML?: PartialObjects["HTML"];
    /** A list of commit comments made by this user. */
    commitComments?: PartialObjects["CommitCommentConnection"];
    /** The user's public profile company. */
    company?: string;
    /** The user's public profile company as HTML. */
    companyHTML?: PartialObjects["HTML"];
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the primary key from the database. */
    databaseId?: number;
    /** The user's publicly visible profile email. */
    email?: string;
    /** A list of users the given user is followed by. */
    followers?: PartialObjects["FollowerConnection"];
    /** A list of users the given user is following. */
    following?: PartialObjects["FollowingConnection"];
    /** Find gist by repo name. */
    gist?: PartialObjects["Gist"];
    /** A list of gist comments made by this user. */
    gistComments?: PartialObjects["GistCommentConnection"];
    /** A list of the Gists the user has created. */
    gists?: PartialObjects["GistConnection"];
    id?: string;
    /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
    isBountyHunter?: boolean;
    /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
    isCampusExpert?: boolean;
    /** Whether or not this user is a GitHub Developer Program member. */
    isDeveloperProgramMember?: boolean;
    /** Whether or not this user is a GitHub employee. */
    isEmployee?: boolean;
    /** Whether or not the user has marked themselves as for hire. */
    isHireable?: boolean;
    /** Whether or not this user is a site administrator. */
    isSiteAdmin?: boolean;
    /** Whether or not this user is the viewing user. */
    isViewer?: boolean;
    /** A list of issue comments made by this user. */
    issueComments?: PartialObjects["IssueCommentConnection"];
    /** A list of issues associated with this user. */
    issues?: PartialObjects["IssueConnection"];
    /** The user's public profile location. */
    location?: string;
    /** The username used to login. */
    login?: string;
    /** The user's public profile name. */
    name?: string;
    /** Find an organization by its login that the user belongs to. */
    organization?: PartialObjects["Organization"];
    /** A list of organizations the user belongs to. */
    organizations?: PartialObjects["OrganizationConnection"];
    /** A list of repositories this user has pinned to their profile */
    pinnedRepositories?: PartialObjects["RepositoryConnection"];
    /** A list of public keys associated with this user. */
    publicKeys?: PartialObjects["PublicKeyConnection"];
    /** A list of pull requests associated with this user. */
    pullRequests?: PartialObjects["PullRequestConnection"];
    /** A list of repositories that the user owns. */
    repositories?: PartialObjects["RepositoryConnection"];
    /** A list of repositories that the user recently contributed to. */
    repositoriesContributedTo?: PartialObjects["RepositoryConnection"];
    /** Find Repository. */
    repository?: PartialObjects["Repository"];
    /** The HTTP path for this user */
    resourcePath?: PartialObjects["URI"];
    /** Repositories the user has starred. */
    starredRepositories?: PartialObjects["StarredRepositoryConnection"];
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
    /** The HTTP URL for this user */
    url?: PartialObjects["URI"];
    /** Whether or not the viewer is able to follow the user. */
    viewerCanFollow?: boolean;
    /** Whether or not this user is followed by the viewer. */
    viewerIsFollowing?: boolean;
    /** A list of repositories the given user is watching. */
    watching?: PartialObjects["RepositoryConnection"];
    /** A URL pointing to the user's public website/blog. */
    websiteUrl?: PartialObjects["URI"];
  };
  /** The connection type for User. */
  ["UserConnection"]: {
    __typename?: "UserConnection";
    /** A list of edges. */
    edges?: (PartialObjects["UserEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["User"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edit on user content */
  ["UserContentEdit"]: {
    __typename?: "UserContentEdit";
    /** Identifies the date and time when the object was created. */
    createdAt?: PartialObjects["DateTime"];
    /** Identifies the date and time when the object was deleted. */
    deletedAt?: PartialObjects["DateTime"];
    /** The actor who deleted this content */
    deletedBy?: PartialObjects["Actor"];
    /** A summary of the changes for this edit */
    diff?: string;
    /** When this content was edited */
    editedAt?: PartialObjects["DateTime"];
    /** The actor who edited this content */
    editor?: PartialObjects["Actor"];
    id?: string;
    /** Identifies the date and time when the object was last updated. */
    updatedAt?: PartialObjects["DateTime"];
  };
  /** A list of edits to content. */
  ["UserContentEditConnection"]: {
    __typename?: "UserContentEditConnection";
    /** A list of edges. */
    edges?: (PartialObjects["UserContentEditEdge"] | undefined)[];
    /** A list of nodes. */
    nodes?: (PartialObjects["UserContentEdit"] | undefined)[];
    /** Information to aid in pagination. */
    pageInfo?: PartialObjects["PageInfo"];
    /** Identifies the total count of items in the connection. */
    totalCount?: number;
  };
  /** An edge in a connection. */
  ["UserContentEditEdge"]: {
    __typename?: "UserContentEditEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["UserContentEdit"];
  };
  /** An edge in a connection. */
  ["UserEdge"]: {
    __typename?: "UserEdge";
    /** A cursor for use in pagination. */
    cursor?: string;
    /** The item at the end of the edge. */
    node?: PartialObjects["User"];
  };
  /** A valid x509 certificate string */
  ["X509Certificate"]: any;
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of the suggested topic. */
  name: string;
  /** The Node ID of the repository. */
  repositoryId: string;
};

/** Autogenerated return type of AcceptTopicSuggestion */
export type AcceptTopicSuggestionPayload = {
  __typename?: "AcceptTopicSuggestionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The accepted topic.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `topic` will change from `Topic!` to `Topic`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  topic: Topic;
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type Actor = {
  __interface: {
    /** The username of the actor. */
    login: string;
    /** The HTTP path for this actor. */
    resourcePath: URI;
    /** The HTTP URL for this actor. */
    url: URI;
    /** A URL pointing to the actor's public avatar. */
    avatarUrl: URI;
  };
  __resolve: {
    ["...on Bot"]: Bot;
    ["...on Organization"]: Organization;
    ["...on User"]: User;
  };
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** The Node ID of the subject to modify. */
  subjectId: string;
  /** The contents of the comment. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
};

/** Autogenerated return type of AddComment */
export type AddCommentPayload = {
  __typename?: "AddCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The edge from the subject's comment connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `commentEdge` will change from `IssueCommentEdge!` to `IssueCommentEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  commentEdge: IssueCommentEdge;
  /** 														The subject
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Node!` to `Node`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  subject: Node;
  /** 														The edge from the subject's timeline connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `timelineEdge` will change from `IssueTimelineItemEdge!` to `IssueTimelineItemEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  timelineEdge: IssueTimelineItemEdge;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type AddedToProjectEvent = {
  __typename?: "AddedToProjectEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
};

/** Autogenerated input type of AddProjectCard */
export type AddProjectCardInput = {
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: string;
  /** The note on the card. */
  note?: string;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
};

/** Autogenerated return type of AddProjectCard */
export type AddProjectCardPayload = {
  __typename?: "AddProjectCardPayload";
  /** 														The edge from the ProjectColumn's card connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `cardEdge` will change from `ProjectCardEdge!` to `ProjectCardEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  cardEdge: ProjectCardEdge;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The ProjectColumn
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectColumn` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  projectColumn: Project;
};

/** Autogenerated input type of AddProjectColumn */
export type AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of the column. */
  name: string;
  /** The Node ID of the project. */
  projectId: string;
};

/** Autogenerated return type of AddProjectColumn */
export type AddProjectColumnPayload = {
  __typename?: "AddProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The edge from the project's column connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `columnEdge` will change from `ProjectColumnEdge!` to `ProjectColumnEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  columnEdge: ProjectColumnEdge;
  /** 														The project
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  project: Project;
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentInput = {
  /** The comment id to reply to. */
  inReplyTo?: string;
  /** The relative path of the file to comment on. */
  path?: string;
  /** The line index in the diff to comment on. */
  position?: number;
  /** The Node ID of the review to modify. */
  pullRequestReviewId: string;
  /** The text of the comment. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The SHA of the commit to comment on. */
  commitOID?: GitObjectID;
};

/** Autogenerated return type of AddPullRequestReviewComment */
export type AddPullRequestReviewCommentPayload = {
  __typename?: "AddPullRequestReviewCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The newly created comment.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `comment` will change from `PullRequestReviewComment!` to `PullRequestReviewComment`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  comment: PullRequestReviewComment;
  /** 														The edge from the review's comment connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `commentEdge` will change from
  `PullRequestReviewCommentEdge!` to `PullRequestReviewCommentEdge`.
  **Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  commentEdge: PullRequestReviewCommentEdge;
};

/** Autogenerated input type of AddPullRequestReview */
export type AddPullRequestReviewInput = {
  /** The Node ID of the pull request to modify. */
  pullRequestId: string;
  /** The contents of the review body comment. */
  body?: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The review line comments. */
  comments?: (DraftPullRequestReviewComment | undefined)[];
  /** The commit OID the review pertains to. */
  commitOID?: GitObjectID;
  /** The event to perform on the pull request review. */
  event?: PullRequestReviewEvent;
};

/** Autogenerated return type of AddPullRequestReview */
export type AddPullRequestReviewPayload = {
  __typename?: "AddPullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The newly created pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  pullRequestReview: PullRequestReview;
  /** 														The edge from the pull request's review connection.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reviewEdge` will change from `PullRequestReviewEdge!` to `PullRequestReviewEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  reviewEdge: PullRequestReviewEdge;
};

/** Autogenerated input type of AddReaction */
export type AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of the emoji to react with. */
  content: ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: string;
};

/** Autogenerated return type of AddReaction */
export type AddReactionPayload = {
  __typename?: "AddReactionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The reaction object.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reaction` will change from `Reaction!` to `Reaction`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  reaction: Reaction;
  /** 														The reactable subject.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Reactable!` to `Reactable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  subject: Reactable;
};

/** Autogenerated input type of AddStar */
export type AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The Starrable ID to star. */
  starrableId: string;
};

/** Autogenerated return type of AddStar */
export type AddStarPayload = {
  __typename?: "AddStarPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The starrable.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `starrable` will change from `Starrable!` to `Starrable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  starrable: Starrable;
};

/** A GitHub App. */
export type App = {
  __typename?: "App";
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The description of the app. */
  description?: string;
  id: string;
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: string;
  /** A URL pointing to the app's logo. */
  logoUrl: URI;
  /** The name of the app. */
  name: string;
  /** A slug based on the name of the app for use in URLs. */
  slug: string;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The URL to the app's homepage. */
  url: URI;
};

/** An object that can have users assigned to it. */
export type Assignable = {
  __interface: {
    /** A list of Users assigned to this object. */
    assignees: UserConnection;
  };
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** Represents an 'assigned' event on any assignable object. */
export type AssignedEvent = {
  __typename?: "AssignedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the assignable associated with the event. */
  assignable: Assignable;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Identifies the user who was assigned. */
  user?: User;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type BaseRefChangedEvent = {
  __typename?: "BaseRefChangedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type BaseRefForcePushedEvent = {
  __typename?: "BaseRefForcePushedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Commit;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Commit;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Ref;
};

/** Represents a Git blame. */
export type Blame = {
  __typename?: "Blame";
  /** The list of ranges from a Git blame. */
  ranges: BlameRange[];
};

/** Represents a range of information from a Git blame. */
export type BlameRange = {
  __typename?: "BlameRange";
  /** 																Identifies the recency of the change, from 1 (new) to 10 (old). This is
calculated as a 2-quantile and determines the length of distance between the
median age of all the changes in the file and the recency of the current
range's change. */
  age: number;
  /** Identifies the line author */
  commit: Commit;
  /** The ending line for the range */
  endingLine: number;
  /** The starting line for the range */
  startingLine: number;
};

/** Represents a Git blob. */
export type Blob = {
  __typename?: "Blob";
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: string;
  /** Byte size of Blob object */
  byteSize: number;
  /** The HTTP path for this Git object */
  commitResourcePath: URI;
  /** The HTTP URL for this Git object */
  commitUrl: URI;
  id: string;
  /** Indicates whether the Blob is binary or text */
  isBinary: boolean;
  /** Indicates whether the contents is truncated */
  isTruncated: boolean;
  /** The Git object ID */
  oid: GitObjectID;
  /** The Repository the Git object belongs to */
  repository: Repository;
  /** UTF8 text data or null if the Blob is binary */
  text?: string;
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type Bot = {
  __typename?: "Bot";
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: URI;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
  /** The username of the actor. */
  login: string;
  /** The HTTP path for this bot */
  resourcePath: URI;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this bot */
  url: URI;
};

/** An object that can be closed */
export type Closable = {
  __interface: {
    /** Identifies the date and time when the object was closed. */
    closedAt?: DateTime;
    /** `true` if the object is closed (definition of closed may depend on type) */
    closed: boolean;
  };
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on Milestone"]: Milestone;
    ["...on Project"]: Project;
    ["...on PullRequest"]: PullRequest;
  };
};

/** Represents a 'closed' event on any `Closable`. */
export type ClosedEvent = {
  __typename?: "ClosedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Object that was closed. */
  closable: Closable;
  /** Object which triggered the creation of this event. */
  closer?: Closer;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** The HTTP path for this closed event. */
  resourcePath: URI;
  /** The HTTP URL for this closed event. */
  url: URI;
};

/** The object which triggered a `ClosedEvent`. */
export type Closer = {
  __union: Commit | PullRequest;
  __resolve: {
    ["...on Commit"]: Commit;
    ["...on PullRequest"]: PullRequest;
  };
};

/** The Code of Conduct for a repository */
export type CodeOfConduct = {
  __typename?: "CodeOfConduct";
  /** The body of the CoC */
  body?: string;
  /** The key for the CoC */
  key: string;
  /** The formal name of the CoC */
  name: string;
  /** The path to the CoC */
  url?: URI;
};

/** Collaborators affiliation level with a subject. */
export enum CollaboratorAffiliation {
  ALL = "ALL",
  DIRECT = "DIRECT",
  OUTSIDE = "OUTSIDE",
}

/** Represents a comment. */
export type Comment = {
  __interface: {
    /** Identifies the date and time when the object was created. */
    createdAt: DateTime;
    /** Did the viewer author this comment. */
    viewerDidAuthor: boolean;
    /** The actor who authored the comment. */
    author?: Actor;
    /** The moment the editor made the last edit */
    lastEditedAt?: DateTime;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: DateTime;
    /** The body rendered to HTML. */
    bodyHTML: HTML;
    /** Identifies when the comment was published at. */
    publishedAt?: DateTime;
    /** The body as Markdown. */
    body: string;
    id: string;
    /** The body rendered to text. */
    bodyText: string;
    /** The actor who edited the comment. */
    editor?: Actor;
    /** Check if this comment was created via an email reply. */
    createdViaEmail: boolean;
    /** A list of edits to this content. */
    userContentEdits?: UserContentEditConnection;
    /** Check if this comment was edited and includes an edit with the creation data */
    includesCreatedEdit: boolean;
    /** Author's association with the subject of the comment. */
    authorAssociation: CommentAuthorAssociation;
  };
  __resolve: {
    ["...on CommitComment"]: CommitComment;
    ["...on GistComment"]: GistComment;
    ["...on Issue"]: Issue;
    ["...on IssueComment"]: IssueComment;
    ["...on PullRequest"]: PullRequest;
    ["...on PullRequestReview"]: PullRequestReview;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
  };
};

/** A comment author association with repository. */
export enum CommentAuthorAssociation {
  CONTRIBUTOR = "CONTRIBUTOR",
  FIRST_TIMER = "FIRST_TIMER",
  FIRST_TIME_CONTRIBUTOR = "FIRST_TIME_CONTRIBUTOR",
  MEMBER = "MEMBER",
  NONE = "NONE",
  OWNER = "OWNER",
  COLLABORATOR = "COLLABORATOR",
}

/** The possible errors that will prevent a user from updating a comment. */
export enum CommentCannotUpdateReason {
  MAINTENANCE = "MAINTENANCE",
  VERIFIED_EMAIL_REQUIRED = "VERIFIED_EMAIL_REQUIRED",
  INSUFFICIENT_ACCESS = "INSUFFICIENT_ACCESS",
  LOCKED = "LOCKED",
  LOGIN_REQUIRED = "LOGIN_REQUIRED",
}

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type CommentDeletedEvent = {
  __typename?: "CommentDeletedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
};

/** Represents a Git commit. */
export type Commit = {
  __typename?: "Commit";
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: string;
  /** The number of additions in this commit. */
  additions: number;
  /** Authorship details of the commit. */
  author?: GitActor;
  /** Check if the committer and the author match. */
  authoredByCommitter: boolean;
  /** The datetime when this commit was authored. */
  authoredDate: DateTime;
  /** Fetches `git blame` information. */
  blame: Blame;
  /** The number of changed files in this commit. */
  changedFiles: number;
  /** Comments made on the commit. */
  comments: CommitCommentConnection;
  /** The HTTP path for this Git object */
  commitResourcePath: URI;
  /** The HTTP URL for this Git object */
  commitUrl: URI;
  /** The datetime when this commit was committed. */
  committedDate: DateTime;
  /** Check if commited via GitHub web UI. */
  committedViaWeb: boolean;
  /** Committership details of the commit. */
  committer?: GitActor;
  /** The number of deletions in this commit. */
  deletions: number;
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  history: CommitHistoryConnection;
  id: string;
  /** The Git commit message */
  message: string;
  /** The Git commit message body */
  messageBody: string;
  /** The commit message body rendered to HTML. */
  messageBodyHTML: HTML;
  /** The Git commit message headline */
  messageHeadline: string;
  /** The commit message headline rendered to HTML. */
  messageHeadlineHTML: HTML;
  /** The Git object ID */
  oid: GitObjectID;
  /** The parents of a commit. */
  parents: CommitConnection;
  /** The datetime when this commit was pushed. */
  pushedDate?: DateTime;
  /** The Repository this commit belongs to */
  repository: Repository;
  /** The HTTP path for this commit */
  resourcePath: URI;
  /** Commit signing information, if present. */
  signature?: GitSignature;
  /** Status information for this commit */
  status?: Status;
  /** 																Returns a URL to download a tarball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes. */
  tarballUrl: URI;
  /** Commit's root Tree */
  tree: Tree;
  /** The HTTP path for the tree of this commit */
  treeResourcePath: URI;
  /** The HTTP URL for the tree of this commit */
  treeUrl: URI;
  /** The HTTP URL for this commit */
  url: URI;
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: boolean;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: SubscriptionState;
  /** 																Returns a URL to download a zipball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes. */
  zipballUrl: URI;
};

/** Specifies an author for filtering Git commits. */
export type CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: string[];
  /** 																ID of a User to filter by. If non-null, only commits authored by this user
will be returned. This field takes precedence over emails. */
  id?: string;
};

/** Represents a comment on a given Commit. */
export type CommitComment = {
  __typename?: "CommitComment";
  /** The actor who authored the comment. */
  author?: Actor;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: string;
  /** Identifies the comment body rendered to HTML. */
  bodyHTML: HTML;
  /** The body rendered to text. */
  bodyText: string;
  /** Identifies the commit associated with the comment, if the commit exists. */
  commit?: Commit;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Check if this comment was created via an email reply. */
  createdViaEmail: boolean;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The actor who edited the comment. */
  editor?: Actor;
  id: string;
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: boolean;
  /** The moment the editor made the last edit */
  lastEditedAt?: DateTime;
  /** Identifies the file path associated with the comment. */
  path?: string;
  /** Identifies the line position associated with the comment. */
  position?: number;
  /** Identifies when the comment was published at. */
  publishedAt?: DateTime;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: ReactionGroup[];
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path permalink for this commit comment. */
  resourcePath: URI;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL permalink for this commit comment. */
  url: URI;
  /** A list of edits to this content. */
  userContentEdits?: UserContentEditConnection;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: boolean;
  /** Can user react to this subject */
  viewerCanReact: boolean;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  /** Did the viewer author this comment. */
  viewerDidAuthor: boolean;
};

/** The connection type for CommitComment. */
export type CommitCommentConnection = {
  __typename?: "CommitCommentConnection";
  /** A list of edges. */
  edges?: (CommitCommentEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (CommitComment | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type CommitCommentEdge = {
  __typename?: "CommitCommentEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: CommitComment;
};

/** A thread of comments on a commit. */
export type CommitCommentThread = {
  __typename?: "CommitCommentThread";
  /** The comments that exist in this thread. */
  comments: CommitCommentConnection;
  /** The commit the comments were made on. */
  commit: Commit;
  id: string;
  /** The file the comments were made on. */
  path?: string;
  /** The position in the diff for the commit that the comment was made on. */
  position?: number;
  /** The repository associated with this node. */
  repository: Repository;
};

/** The connection type for Commit. */
export type CommitConnection = {
  __typename?: "CommitConnection";
  /** A list of edges. */
  edges?: (CommitEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Commit | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type CommitEdge = {
  __typename?: "CommitEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Commit;
};

/** The connection type for Commit. */
export type CommitHistoryConnection = {
  __typename?: "CommitHistoryConnection";
  edges?: (CommitEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Commit | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type ConvertedNoteToIssueEvent = {
  __typename?: "ConvertedNoteToIssueEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  /** The description of project. */
  body?: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of project. */
  name: string;
  /** The owner ID to create the project under. */
  ownerId: string;
};

/** Autogenerated return type of CreateProject */
export type CreateProjectPayload = {
  __typename?: "CreateProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The new project.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  project: Project;
};

/** Represents a mention made by one issue or pull request to another. */
export type CrossReferencedEvent = {
  __typename?: "CrossReferencedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Reference originated in a different repository. */
  isCrossRepository: boolean;
  /** Identifies when the reference was made. */
  referencedAt: DateTime;
  /** The HTTP path for this pull request. */
  resourcePath: URI;
  /** Issue or pull request that made the reference. */
  source: ReferencedSubject;
  /** Issue or pull request to which the reference was made. */
  target: ReferencedSubject;
  /** The HTTP URL for this pull request. */
  url: URI;
  /** Checks if the target will be closed when the source is merged. */
  willCloseTarget: boolean;
};

/** An ISO-8601 encoded UTC date string. */
export type DateTime = any;

/** Autogenerated input type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of the suggested topic. */
  name: string;
  /** The reason why the suggested topic is declined. */
  reason: TopicSuggestionDeclineReason;
  /** The Node ID of the repository. */
  repositoryId: string;
};

/** Autogenerated return type of DeclineTopicSuggestion */
export type DeclineTopicSuggestionPayload = {
  __typename?: "DeclineTopicSuggestionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The declined topic.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `topic` will change from `Topic!` to `Topic`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  topic: Topic;
};

/** Entities that can be deleted. */
export type Deletable = {
  __interface: {
    /** Check if the current viewer can delete this object. */
    viewerCanDelete: boolean;
  };
  __resolve: {
    ["...on CommitComment"]: CommitComment;
    ["...on GistComment"]: GistComment;
    ["...on IssueComment"]: IssueComment;
    ["...on PullRequestReview"]: PullRequestReview;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
  };
};

/** Autogenerated input type of DeleteProjectCard */
export type DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
};

/** Autogenerated return type of DeleteProjectCard */
export type DeleteProjectCardPayload = {
  __typename?: "DeleteProjectCardPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The column the deleted card was in.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `column` will change from `ProjectColumn!` to `ProjectColumn`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  column: ProjectColumn;
  /** 														The deleted card ID.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `deletedCardId` will change from `ID!` to `ID`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  deletedCardId: string;
};

/** Autogenerated input type of DeleteProjectColumn */
export type DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The id of the column to delete. */
  columnId: string;
};

/** Autogenerated return type of DeleteProjectColumn */
export type DeleteProjectColumnPayload = {
  __typename?: "DeleteProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The deleted column ID.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `deletedColumnId` will change from `ID!` to `ID`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  deletedColumnId: string;
  /** 														The project the deleted column was in.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  project: Project;
};

/** Autogenerated input type of DeleteProject */
export type DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The Project ID to update. */
  projectId: string;
};

/** Autogenerated return type of DeleteProject */
export type DeleteProjectPayload = {
  __typename?: "DeleteProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The repository or organization the project was removed from.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `owner` will change from `ProjectOwner!` to `ProjectOwner`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  owner: ProjectOwner;
};

/** Autogenerated input type of DeletePullRequestReview */
export type DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: string;
};

/** Autogenerated return type of DeletePullRequestReview */
export type DeletePullRequestReviewPayload = {
  __typename?: "DeletePullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The deleted pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  pullRequestReview: PullRequestReview;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type DemilestonedEvent = {
  __typename?: "DemilestonedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: string;
  /** Object referenced by event. */
  subject: MilestoneItem;
};

/** Represents a 'deployed' event on a given pull request. */
export type DeployedEvent = {
  __typename?: "DeployedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The deployment associated with the 'deployed' event. */
  deployment: Deployment;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** The ref associated with the 'deployed' event. */
  ref?: Ref;
};

/** A repository deploy key. */
export type DeployKey = {
  __typename?: "DeployKey";
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** The deploy key. */
  key: string;
  /** Whether or not the deploy key is read only. */
  readOnly: boolean;
  /** The deploy key title. */
  title: string;
  /** Whether or not the deploy key has been verified. */
  verified: boolean;
};

/** The connection type for DeployKey. */
export type DeployKeyConnection = {
  __typename?: "DeployKeyConnection";
  /** A list of edges. */
  edges?: (DeployKeyEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (DeployKey | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type DeployKeyEdge = {
  __typename?: "DeployKeyEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: DeployKey;
};

/** Represents triggered deployment instance. */
export type Deployment = {
  __typename?: "Deployment";
  /** Identifies the commit sha of the deployment. */
  commit?: Commit;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the actor who triggered the deployment. */
  creator?: Actor;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The deployment description. */
  description?: string;
  /** The environment to which this deployment was made. */
  environment?: string;
  id: string;
  /** The latest status of this deployment. */
  latestStatus?: DeploymentStatus;
  /** Extra information that a deployment system might need. */
  payload?: string;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Ref;
  /** Identifies the repository associated with the deployment. */
  repository: Repository;
  /** The current state of the deployment. */
  state?: DeploymentState;
  /** A list of statuses associated with the deployment. */
  statuses?: DeploymentStatusConnection;
  /** The deployment task. */
  task?: string;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
};

/** The connection type for Deployment. */
export type DeploymentConnection = {
  __typename?: "DeploymentConnection";
  /** A list of edges. */
  edges?: (DeploymentEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Deployment | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type DeploymentEdge = {
  __typename?: "DeploymentEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Deployment;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type DeploymentEnvironmentChangedEvent = {
  __typename?: "DeploymentEnvironmentChangedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: DeploymentStatus;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** The possible states in which a deployment can be. */
export enum DeploymentState {
  ERROR = "ERROR",
  FAILURE = "FAILURE",
  INACTIVE = "INACTIVE",
  PENDING = "PENDING",
  ABANDONED = "ABANDONED",
  ACTIVE = "ACTIVE",
  DESTROYED = "DESTROYED",
}

/** Describes the status of a given deployment attempt. */
export type DeploymentStatus = {
  __typename?: "DeploymentStatus";
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the actor who triggered the deployment. */
  creator?: Actor;
  /** Identifies the deployment associated with status. */
  deployment: Deployment;
  /** Identifies the description of the deployment. */
  description?: string;
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: URI;
  id: string;
  /** Identifies the log URL of the deployment. */
  logUrl?: URI;
  /** Identifies the current state of the deployment. */
  state: DeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
};

/** The connection type for DeploymentStatus. */
export type DeploymentStatusConnection = {
  __typename?: "DeploymentStatusConnection";
  /** A list of edges. */
  edges?: (DeploymentStatusEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (DeploymentStatus | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type DeploymentStatusEdge = {
  __typename?: "DeploymentStatusEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: DeploymentStatus;
};

/** The possible states for a deployment status. */
export enum DeploymentStatusState {
  SUCCESS = "SUCCESS",
  ERROR = "ERROR",
  FAILURE = "FAILURE",
  INACTIVE = "INACTIVE",
  PENDING = "PENDING",
}

/** Autogenerated input type of DismissPullRequestReview */
export type DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The contents of the pull request review dismissal message. */
  message: string;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: string;
};

/** Autogenerated return type of DismissPullRequestReview */
export type DismissPullRequestReviewPayload = {
  __typename?: "DismissPullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The dismissed pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  pullRequestReview: PullRequestReview;
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type DraftPullRequestReviewComment = {
  /** Path to the file being commented on. */
  path: string;
  /** Position in the file to leave a comment on. */
  position: number;
  /** Body of the comment to leave. */
  body: string;
};

/** An external identity provisioned by SAML SSO or SCIM. */
export type ExternalIdentity = {
  __typename?: "ExternalIdentity";
  /** The GUID for this identity */
  guid: string;
  id: string;
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: OrganizationInvitation;
  /** SAML Identity attributes */
  samlIdentity?: ExternalIdentitySamlAttributes;
  /** SCIM Identity attributes */
  scimIdentity?: ExternalIdentityScimAttributes;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: User;
};

/** The connection type for ExternalIdentity. */
export type ExternalIdentityConnection = {
  __typename?: "ExternalIdentityConnection";
  /** A list of edges. */
  edges?: (ExternalIdentityEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (ExternalIdentity | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ExternalIdentityEdge = {
  __typename?: "ExternalIdentityEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: ExternalIdentity;
};

/** SAML attributes for the External Identity */
export type ExternalIdentitySamlAttributes = {
  __typename?: "ExternalIdentitySamlAttributes";
  /** The NameID of the SAML identity */
  nameId?: string;
};

/** SCIM attributes for the External Identity */
export type ExternalIdentityScimAttributes = {
  __typename?: "ExternalIdentityScimAttributes";
  /** The userName of the SCIM identity */
  username?: string;
};

/** The connection type for User. */
export type FollowerConnection = {
  __typename?: "FollowerConnection";
  /** A list of edges. */
  edges?: (UserEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (User | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** The connection type for User. */
export type FollowingConnection = {
  __typename?: "FollowingConnection";
  /** A list of edges. */
  edges?: (UserEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (User | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** A Gist. */
export type Gist = {
  __typename?: "Gist";
  /** A list of comments associated with the gist */
  comments: GistCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The gist description. */
  description?: string;
  id: string;
  /** Whether the gist is public or not. */
  isPublic: boolean;
  /** The gist name. */
  name: string;
  /** The gist owner. */
  owner?: RepositoryOwner;
  /** Identifies when the gist was last pushed to. */
  pushedAt?: DateTime;
  /** A list of users who have starred this starrable. */
  stargazers: StargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: boolean;
};

/** Represents a comment on an Gist. */
export type GistComment = {
  __typename?: "GistComment";
  /** The actor who authored the comment. */
  author?: Actor;
  /** Author's association with the gist. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: string;
  /** The comment body rendered to HTML. */
  bodyHTML: HTML;
  /** The body rendered to text. */
  bodyText: string;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Check if this comment was created via an email reply. */
  createdViaEmail: boolean;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The actor who edited the comment. */
  editor?: Actor;
  /** The associated gist. */
  gist: Gist;
  id: string;
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: boolean;
  /** The moment the editor made the last edit */
  lastEditedAt?: DateTime;
  /** Identifies when the comment was published at. */
  publishedAt?: DateTime;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** A list of edits to this content. */
  userContentEdits?: UserContentEditConnection;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: boolean;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  /** Did the viewer author this comment. */
  viewerDidAuthor: boolean;
};

/** The connection type for GistComment. */
export type GistCommentConnection = {
  __typename?: "GistCommentConnection";
  /** A list of edges. */
  edges?: (GistCommentEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (GistComment | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type GistCommentEdge = {
  __typename?: "GistCommentEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: GistComment;
};

/** The connection type for Gist. */
export type GistConnection = {
  __typename?: "GistConnection";
  /** A list of edges. */
  edges?: (GistEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Gist | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type GistEdge = {
  __typename?: "GistEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Gist;
};

/** Ordering options for gist connections */
export type GistOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export enum GistOrderField {
  CREATED_AT = "CREATED_AT",
  PUSHED_AT = "PUSHED_AT",
  UPDATED_AT = "UPDATED_AT",
}

/** The privacy of a Gist */
export enum GistPrivacy {
  ALL = "ALL",
  PUBLIC = "PUBLIC",
  SECRET = "SECRET",
}

/** Represents an actor in a Git commit (ie. an author or committer). */
export type GitActor = {
  __typename?: "GitActor";
  /** A URL pointing to the author's public avatar. */
  avatarUrl: URI;
  /** The timestamp of the Git action (authoring or committing). */
  date?: GitTimestamp;
  /** The email in the Git commit. */
  email?: string;
  /** The name in the Git commit. */
  name?: string;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: User;
};

/** Represents information about the GitHub instance. */
export type GitHubMetadata = {
  __typename?: "GitHubMetadata";
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: GitObjectID;
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: string[];
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: string[];
  /** IP addresses that the importer connects from */
  importerIpAddresses?: string[];
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: boolean;
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: string[];
};

/** Represents a Git object. */
export type GitObject = {
  __interface: {
    /** An abbreviated version of the Git object ID */
    abbreviatedOid: string;
    /** The HTTP path for this Git object */
    commitResourcePath: URI;
    /** The HTTP URL for this Git object */
    commitUrl: URI;
    id: string;
    /** The Git object ID */
    oid: GitObjectID;
    /** The Repository the Git object belongs to */
    repository: Repository;
  };
  __resolve: {
    ["...on Blob"]: Blob;
    ["...on Commit"]: Commit;
    ["...on Tag"]: Tag;
    ["...on Tree"]: Tree;
  };
};

/** A Git object ID. */
export type GitObjectID = any;

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type GitSignature = {
  __interface: {
    /** GitHub user corresponding to the email signing this commit. */
    signer?: User;
    /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
    state: GitSignatureState;
    /** True if the signature was made with GitHub's signing key. */
    wasSignedByGitHub: boolean;
    /** Email used to sign this object. */
    email: string;
    /** True if the signature is valid and verified by GitHub. */
    isValid: boolean;
    /** Payload for GPG signing object. Raw ODB object without the signature header. */
    payload: string;
    /** ASCII-armored signature header from object. */
    signature: string;
  };
  __resolve: {
    ["...on GpgSignature"]: GpgSignature;
    ["...on SmimeSignature"]: SmimeSignature;
    ["...on UnknownSignature"]: UnknownSignature;
  };
};

/** The state of a Git signature. */
export enum GitSignatureState {
  UNVERIFIED_EMAIL = "UNVERIFIED_EMAIL",
  OCSP_REVOKED = "OCSP_REVOKED",
  UNKNOWN_KEY = "UNKNOWN_KEY",
  MALFORMED_SIG = "MALFORMED_SIG",
  NO_USER = "NO_USER",
  OCSP_ERROR = "OCSP_ERROR",
  BAD_CERT = "BAD_CERT",
  EXPIRED_KEY = "EXPIRED_KEY",
  GPGVERIFY_UNAVAILABLE = "GPGVERIFY_UNAVAILABLE",
  NOT_SIGNING_KEY = "NOT_SIGNING_KEY",
  UNSIGNED = "UNSIGNED",
  VALID = "VALID",
  BAD_EMAIL = "BAD_EMAIL",
  GPGVERIFY_ERROR = "GPGVERIFY_ERROR",
  UNKNOWN_SIG_TYPE = "UNKNOWN_SIG_TYPE",
  INVALID = "INVALID",
  OCSP_PENDING = "OCSP_PENDING",
}

/** Git SSH string */
export type GitSSHRemote = any;

/** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
export type GitTimestamp = any;

/** Represents a GPG signature on a Commit or Tag. */
export type GpgSignature = {
  __typename?: "GpgSignature";
  /** Email used to sign this object. */
  email: string;
  /** True if the signature is valid and verified by GitHub. */
  isValid: boolean;
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: string;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: string;
  /** ASCII-armored signature header from object. */
  signature: string;
  /** GitHub user corresponding to the email signing this commit. */
  signer?: User;
  /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: boolean;
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
export type HeadRefDeletedEvent = {
  __typename?: "HeadRefDeletedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Ref;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: string;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type HeadRefForcePushedEvent = {
  __typename?: "HeadRefForcePushedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Commit;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Commit;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Ref;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type HeadRefRestoredEvent = {
  __typename?: "HeadRefRestoredEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
};

/** A string containing HTML code. */
export type HTML = any;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Issue = {
  __typename?: "Issue";
  /** Reason that the conversation was locked. */
  activeLockReason?: LockReason;
  /** A list of Users assigned to this object. */
  assignees: UserConnection;
  /** The actor who authored the comment. */
  author?: Actor;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the body of the issue. */
  body: string;
  /** Identifies the body of the issue rendered to HTML. */
  bodyHTML: HTML;
  /** Identifies the body of the issue rendered to text. */
  bodyText: string;
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: boolean;
  /** Identifies the date and time when the object was closed. */
  closedAt?: DateTime;
  /** A list of comments associated with the Issue. */
  comments: IssueCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Check if this comment was created via an email reply. */
  createdViaEmail: boolean;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The actor who edited the comment. */
  editor?: Actor;
  id: string;
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: boolean;
  /** A list of labels associated with the object. */
  labels?: LabelConnection;
  /** The moment the editor made the last edit */
  lastEditedAt?: DateTime;
  /** `true` if the object is locked */
  locked: boolean;
  /** Identifies the milestone associated with the issue. */
  milestone?: Milestone;
  /** Identifies the issue number. */
  number: number;
  /** A list of Users that are participating in the Issue conversation. */
  participants: UserConnection;
  /** List of project cards associated with this issue. */
  projectCards: ProjectCardConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: DateTime;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: ReactionGroup[];
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path for this issue */
  resourcePath: URI;
  /** Identifies the state of the issue. */
  state: IssueState;
  /** A list of events, comments, commits, etc. associated with the issue. */
  timeline: IssueTimelineConnection;
  /** Identifies the issue title. */
  title: string;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this issue */
  url: URI;
  /** A list of edits to this content. */
  userContentEdits?: UserContentEditConnection;
  /** Can user react to this subject */
  viewerCanReact: boolean;
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: boolean;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  /** Did the viewer author this comment. */
  viewerDidAuthor: boolean;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: SubscriptionState;
};

/** Represents a comment on an Issue. */
export type IssueComment = {
  __typename?: "IssueComment";
  /** The actor who authored the comment. */
  author?: Actor;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The body as Markdown. */
  body: string;
  /** The body rendered to HTML. */
  bodyHTML: HTML;
  /** The body rendered to text. */
  bodyText: string;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Check if this comment was created via an email reply. */
  createdViaEmail: boolean;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The actor who edited the comment. */
  editor?: Actor;
  id: string;
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: boolean;
  /** Identifies the issue associated with the comment. */
  issue: Issue;
  /** The moment the editor made the last edit */
  lastEditedAt?: DateTime;
  /** Identifies when the comment was published at. */
  publishedAt?: DateTime;
  /** 																Returns the pull request associated with the comment, if this comment was made on a
pull request. */
  pullRequest?: PullRequest;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: ReactionGroup[];
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path for this issue comment */
  resourcePath: URI;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this issue comment */
  url: URI;
  /** A list of edits to this content. */
  userContentEdits?: UserContentEditConnection;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: boolean;
  /** Can user react to this subject */
  viewerCanReact: boolean;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  /** Did the viewer author this comment. */
  viewerDidAuthor: boolean;
};

/** The connection type for IssueComment. */
export type IssueCommentConnection = {
  __typename?: "IssueCommentConnection";
  /** A list of edges. */
  edges?: (IssueCommentEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (IssueComment | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type IssueCommentEdge = {
  __typename?: "IssueCommentEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: IssueComment;
};

/** The connection type for Issue. */
export type IssueConnection = {
  __typename?: "IssueConnection";
  /** A list of edges. */
  edges?: (IssueEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Issue | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type IssueEdge = {
  __typename?: "IssueEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Issue;
};

/** Ways in which lists of issues can be ordered upon return. */
export type IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: OrderDirection;
  /** The field in which to order issues by. */
  field: IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export enum IssueOrderField {
  COMMENTS = "COMMENTS",
  CREATED_AT = "CREATED_AT",
  UPDATED_AT = "UPDATED_AT",
}

/** Used for return value of Repository.issueOrPullRequest. */
export type IssueOrPullRequest = {
  __union: Issue | PullRequest;
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** The possible states of an issue. */
export enum IssueState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

/** The connection type for IssueTimelineItem. */
export type IssueTimelineConnection = {
  __typename?: "IssueTimelineConnection";
  /** A list of edges. */
  edges?: (IssueTimelineItemEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (IssueTimelineItem | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An item in an issue timeline */
export type IssueTimelineItem = {
  __union:
    | AssignedEvent
    | ClosedEvent
    | Commit
    | CrossReferencedEvent
    | DemilestonedEvent
    | IssueComment
    | LabeledEvent
    | LockedEvent
    | MilestonedEvent
    | ReferencedEvent
    | RenamedTitleEvent
    | ReopenedEvent
    | SubscribedEvent
    | UnassignedEvent
    | UnlabeledEvent
    | UnlockedEvent
    | UnsubscribedEvent;
  __resolve: {
    ["...on AssignedEvent"]: AssignedEvent;
    ["...on ClosedEvent"]: ClosedEvent;
    ["...on Commit"]: Commit;
    ["...on CrossReferencedEvent"]: CrossReferencedEvent;
    ["...on DemilestonedEvent"]: DemilestonedEvent;
    ["...on IssueComment"]: IssueComment;
    ["...on LabeledEvent"]: LabeledEvent;
    ["...on LockedEvent"]: LockedEvent;
    ["...on MilestonedEvent"]: MilestonedEvent;
    ["...on ReferencedEvent"]: ReferencedEvent;
    ["...on RenamedTitleEvent"]: RenamedTitleEvent;
    ["...on ReopenedEvent"]: ReopenedEvent;
    ["...on SubscribedEvent"]: SubscribedEvent;
    ["...on UnassignedEvent"]: UnassignedEvent;
    ["...on UnlabeledEvent"]: UnlabeledEvent;
    ["...on UnlockedEvent"]: UnlockedEvent;
    ["...on UnsubscribedEvent"]: UnsubscribedEvent;
  };
};

/** An edge in a connection. */
export type IssueTimelineItemEdge = {
  __typename?: "IssueTimelineItemEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: IssueTimelineItem;
};

/** A label for categorizing Issues or Milestones with a given Repository. */
export type Label = {
  __typename?: "Label";
  /** Identifies the label color. */
  color: string;
  /** Identifies the date and time when the label was created. */
  createdAt?: DateTime;
  /** A brief description of this label. */
  description?: string;
  id: string;
  /** Indicates whether or not this is a default label. */
  isDefault: boolean;
  /** A list of issues associated with this label. */
  issues: IssueConnection;
  /** Identifies the label name. */
  name: string;
  /** A list of pull requests associated with this label. */
  pullRequests: PullRequestConnection;
  /** The repository associated with this label. */
  repository: Repository;
  /** The HTTP path for this label. */
  resourcePath: URI;
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: DateTime;
  /** The HTTP URL for this label. */
  url: URI;
};

/** An object that can have labels assigned to it. */
export type Labelable = {
  __interface: {
    /** A list of labels associated with the object. */
    labels?: LabelConnection;
  };
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** The connection type for Label. */
export type LabelConnection = {
  __typename?: "LabelConnection";
  /** A list of edges. */
  edges?: (LabelEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Label | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type LabeledEvent = {
  __typename?: "LabeledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Identifies the label associated with the 'labeled' event. */
  label: Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Labelable;
};

/** An edge in a connection. */
export type LabelEdge = {
  __typename?: "LabelEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Label;
};

/** Represents a given language found in repositories. */
export type Language = {
  __typename?: "Language";
  /** The color defined for the current language. */
  color?: string;
  id: string;
  /** The name of the current language. */
  name: string;
};

/** A list of languages associated with the parent. */
export type LanguageConnection = {
  __typename?: "LanguageConnection";
  /** A list of edges. */
  edges?: (LanguageEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Language | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
  /** The total size in bytes of files written in that language. */
  totalSize: number;
};

/** Represents the language of a repository. */
export type LanguageEdge = {
  __typename?: "LanguageEdge";
  cursor: string;
  node: Language;
  /** The number of bytes of code written in the language. */
  size: number;
};

/** Ordering options for language connections. */
export type LanguageOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order languages by. */
  field: LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export enum LanguageOrderField {
  SIZE = "SIZE",
}

/** A repository's open source license */
export type License = {
  __typename?: "License";
  /** The full text of the license */
  body: string;
  /** The conditions set by the license */
  conditions?: LicenseRule[];
  /** A human-readable description of the license */
  description?: string;
  /** Whether the license should be featured */
  featured: boolean;
  /** Whether the license should be displayed in license pickers */
  hidden: boolean;
  id: string;
  /** Instructions on how to implement the license */
  implementation?: string;
  /** The lowercased SPDX ID of the license */
  key: string;
  /** The limitations set by the license */
  limitations?: LicenseRule[];
  /** The license full name specified by <https: spdx.org="" licenses=""></https:> */
  name: string;
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: string;
  /** The permissions set by the license */
  permissions?: LicenseRule[];
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: boolean;
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: string;
  /** URL to the license on <https://choosealicense.com> */
  url?: URI;
};

/** Describes a License's conditions, permissions, and limitations */
export type LicenseRule = {
  __typename?: "LicenseRule";
  /** A description of the rule */
  description: string;
  /** The machine-readable rule key */
  key: string;
  /** The human-readable rule label */
  label: string;
};

/** An object that can be locked. */
export type Lockable = {
  __interface: {
    /** Reason that the conversation was locked. */
    activeLockReason?: LockReason;
    /** `true` if the object is locked */
    locked: boolean;
  };
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** Represents a 'locked' event on a given issue or pull request. */
export type LockedEvent = {
  __typename?: "LockedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Reason that the conversation was locked (optional). */
  lockReason?: LockReason;
  /** Object that was locked. */
  lockable: Lockable;
};

/** Autogenerated input type of LockLockable */
export type LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** A reason for why the issue or pull request will be locked. */
  lockReason?: LockReason;
  /** ID of the issue or pull request to be locked. */
  lockableId: string;
};

/** Autogenerated return type of LockLockable */
export type LockLockablePayload = {
  __typename?: "LockLockablePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The item that was locked. */
  lockedRecord?: Lockable;
};

/** The possible reasons that an issue or pull request was locked. */
export enum LockReason {
  OFF_TOPIC = "OFF_TOPIC",
  RESOLVED = "RESOLVED",
  SPAM = "SPAM",
  TOO_HEATED = "TOO_HEATED",
}

/** A public description of a Marketplace category. */
export type MarketplaceCategory = {
  __typename?: "MarketplaceCategory";
  /** The category's description. */
  description?: string;
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: string;
  id: string;
  /** The category's name. */
  name: string;
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: number;
  /** The HTTP path for this Marketplace category. */
  resourcePath: URI;
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: number;
  /** The short name of the category used in its URL. */
  slug: string;
  /** The HTTP URL for this Marketplace category. */
  url: URI;
};

/** A listing in the GitHub integration marketplace. */
export type MarketplaceListing = {
  __typename?: "MarketplaceListing";
  /** The GitHub App this listing represents. */
  app?: App;
  /** URL to the listing owner's company site. */
  companyUrl?: URI;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: URI;
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: URI;
  /** URL to the listing's documentation. */
  documentationUrl?: URI;
  /** The listing's detailed description. */
  extendedDescription?: string;
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: HTML;
  /** The listing's introductory description. */
  fullDescription: string;
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: HTML;
  /** Whether this listing has been submitted for review from GitHub for approval to be displayed in the Marketplace. */
  hasApprovalBeenRequested: boolean;
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: boolean;
  /** Does this listing have a terms of service link? */
  hasTermsOfService: boolean;
  /** A technical description of how this app works with GitHub. */
  howItWorks?: string;
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: HTML;
  id: string;
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: URI;
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: boolean;
  /** Whether this listing has been approved for display in the Marketplace. */
  isApproved: boolean;
  /** Whether this listing has been removed from the Marketplace. */
  isDelisted: boolean;
  /** 																Whether this listing is still an editable draft that has not been submitted
for review and is not publicly visible in the Marketplace. */
  isDraft: boolean;
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: boolean;
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: boolean;
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: string;
  /** URL for the listing's logo image. */
  logoUrl?: URI;
  /** The listing's full name. */
  name: string;
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: string;
  /** URL to the listing's detailed pricing. */
  pricingUrl?: URI;
  /** The category that best describes the listing. */
  primaryCategory: MarketplaceCategory;
  /** URL to the listing's privacy policy. */
  privacyPolicyUrl: URI;
  /** The HTTP path for the Marketplace listing. */
  resourcePath: URI;
  /** The URLs for the listing's screenshots. */
  screenshotUrls?: string[];
  /** An alternate category that describes the listing. */
  secondaryCategory?: MarketplaceCategory;
  /** The listing's very short description. */
  shortDescription: string;
  /** The short name of the listing used in its URL. */
  slug: string;
  /** URL to the listing's status page. */
  statusUrl?: URI;
  /** An email address for support for this listing's app. */
  supportEmail?: string;
  /** Either a URL or an email address for support for this listing's app. */
  supportUrl: URI;
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: URI;
  /** The HTTP URL for the Marketplace listing. */
  url: URI;
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: boolean;
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: boolean;
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: boolean;
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: boolean;
  /** 																Can the current viewer edit the primary and secondary category of this
Marketplace listing. */
  viewerCanEditCategories: boolean;
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: boolean;
  /** 																Can the current viewer return this Marketplace listing to draft state
so it becomes editable again. */
  viewerCanRedraft: boolean;
  /** 																Can the current viewer reject this Marketplace listing by returning it to
an editable draft state or rejecting it entirely. */
  viewerCanReject: boolean;
  /** 																Can the current viewer request this listing be reviewed for display in
the Marketplace. */
  viewerCanRequestApproval: boolean;
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: boolean;
  /** 																Indicates if the current user has purchased a subscription to this Marketplace listing
for all of the organizations the user owns. */
  viewerHasPurchasedForAllOrganizations: boolean;
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: boolean;
};

/** Look up Marketplace Listings */
export type MarketplaceListingConnection = {
  __typename?: "MarketplaceListingConnection";
  /** A list of edges. */
  edges?: (MarketplaceListingEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (MarketplaceListing | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type MarketplaceListingEdge = {
  __typename?: "MarketplaceListingEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: MarketplaceListing;
};

/** Represents a 'mentioned' event on a given issue or pull request. */
export type MentionedEvent = {
  __typename?: "MentionedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
};

/** Whether or not a PullRequest can be merged. */
export enum MergeableState {
  CONFLICTING = "CONFLICTING",
  MERGEABLE = "MERGEABLE",
  UNKNOWN = "UNKNOWN",
}

/** Represents a 'merged' event on a given pull request. */
export type MergedEvent = {
  __typename?: "MergedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the commit associated with the `merge` event. */
  commit?: Commit;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Identifies the Ref associated with the `merge` event. */
  mergeRef?: Ref;
  /** Identifies the name of the Ref associated with the `merge` event. */
  mergeRefName: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** The HTTP path for this merged event. */
  resourcePath: URI;
  /** The HTTP URL for this merged event. */
  url: URI;
};

/** Represents a Milestone object on a given repository. */
export type Milestone = {
  __typename?: "Milestone";
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: boolean;
  /** Identifies the date and time when the object was closed. */
  closedAt?: DateTime;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the actor who created the milestone. */
  creator?: Actor;
  /** Identifies the description of the milestone. */
  description?: string;
  /** Identifies the due date of the milestone. */
  dueOn?: DateTime;
  id: string;
  /** A list of issues associated with the milestone. */
  issues: IssueConnection;
  /** Identifies the number of the milestone. */
  number: number;
  /** A list of pull requests associated with the milestone. */
  pullRequests: PullRequestConnection;
  /** The repository associated with this milestone. */
  repository: Repository;
  /** The HTTP path for this milestone */
  resourcePath: URI;
  /** Identifies the state of the milestone. */
  state: MilestoneState;
  /** Identifies the title of the milestone. */
  title: string;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this milestone */
  url: URI;
};

/** The connection type for Milestone. */
export type MilestoneConnection = {
  __typename?: "MilestoneConnection";
  /** A list of edges. */
  edges?: (MilestoneEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Milestone | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a 'milestoned' event on a given issue or pull request. */
export type MilestonedEvent = {
  __typename?: "MilestonedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: string;
  /** Object referenced by event. */
  subject: MilestoneItem;
};

/** An edge in a connection. */
export type MilestoneEdge = {
  __typename?: "MilestoneEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Milestone;
};

/** Types that can be inside a Milestone. */
export type MilestoneItem = {
  __union: Issue | PullRequest;
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** Ordering options for milestone connections. */
export type MilestoneOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order milestones by. */
  field: MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export enum MilestoneOrderField {
  CREATED_AT = "CREATED_AT",
  DUE_DATE = "DUE_DATE",
  NUMBER = "NUMBER",
  UPDATED_AT = "UPDATED_AT",
}

/** The possible states of a milestone. */
export enum MilestoneState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type MovedColumnsInProjectEvent = {
  __typename?: "MovedColumnsInProjectEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
};

/** Autogenerated input type of MoveProjectCard */
export type MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: string;
  /** The id of the card to move. */
  cardId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The id of the column to move it into. */
  columnId: string;
};

/** Autogenerated return type of MoveProjectCard */
export type MoveProjectCardPayload = {
  __typename?: "MoveProjectCardPayload";
  /** 														The new edge of the moved card.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `cardEdge` will change from `ProjectCardEdge!` to `ProjectCardEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  cardEdge: ProjectCardEdge;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
};

/** Autogenerated input type of MoveProjectColumn */
export type MoveProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The id of the column to move. */
  columnId: string;
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: string;
};

/** Autogenerated return type of MoveProjectColumn */
export type MoveProjectColumnPayload = {
  __typename?: "MoveProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The new edge of the moved column.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `columnEdge` will change from `ProjectColumnEdge!` to `ProjectColumnEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  columnEdge: ProjectColumnEdge;
};

/** The root query for implementing GraphQL mutations. */
export type Mutation = {
  __typename?: "Mutation";
  /** Applies a suggested topic to the repository. */
  acceptTopicSuggestion?: AcceptTopicSuggestionPayload;
  /** Adds a comment to an Issue or Pull Request. */
  addComment?: AddCommentPayload;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  addProjectCard?: AddProjectCardPayload;
  /** Adds a column to a Project. */
  addProjectColumn?: AddProjectColumnPayload;
  /** Adds a review to a Pull Request. */
  addPullRequestReview?: AddPullRequestReviewPayload;
  /** Adds a comment to a review. */
  addPullRequestReviewComment?: AddPullRequestReviewCommentPayload;
  /** Adds a reaction to a subject. */
  addReaction?: AddReactionPayload;
  /** Adds a star to a Starrable. */
  addStar?: AddStarPayload;
  /** Creates a new project. */
  createProject?: CreateProjectPayload;
  /** Rejects a suggested topic for the repository. */
  declineTopicSuggestion?: DeclineTopicSuggestionPayload;
  /** Deletes a project. */
  deleteProject?: DeleteProjectPayload;
  /** Deletes a project card. */
  deleteProjectCard?: DeleteProjectCardPayload;
  /** Deletes a project column. */
  deleteProjectColumn?: DeleteProjectColumnPayload;
  /** Deletes a pull request review. */
  deletePullRequestReview?: DeletePullRequestReviewPayload;
  /** Dismisses an approved or rejected pull request review. */
  dismissPullRequestReview?: DismissPullRequestReviewPayload;
  /** Lock a lockable object */
  lockLockable?: LockLockablePayload;
  /** Moves a project card to another place. */
  moveProjectCard?: MoveProjectCardPayload;
  /** Moves a project column to another place. */
  moveProjectColumn?: MoveProjectColumnPayload;
  /** Removes outside collaborator from all repositories in an organization. */
  removeOutsideCollaborator?: RemoveOutsideCollaboratorPayload;
  /** Removes a reaction from a subject. */
  removeReaction?: RemoveReactionPayload;
  /** Removes a star from a Starrable. */
  removeStar?: RemoveStarPayload;
  /** Set review requests on a pull request. */
  requestReviews?: RequestReviewsPayload;
  /** Submits a pending pull request review. */
  submitPullRequestReview?: SubmitPullRequestReviewPayload;
  /** Unlock a lockable object */
  unlockLockable?: UnlockLockablePayload;
  /** Updates an existing project. */
  updateProject?: UpdateProjectPayload;
  /** Updates an existing project card. */
  updateProjectCard?: UpdateProjectCardPayload;
  /** Updates an existing project column. */
  updateProjectColumn?: UpdateProjectColumnPayload;
  /** Updates the body of a pull request review. */
  updatePullRequestReview?: UpdatePullRequestReviewPayload;
  /** Updates a pull request review comment. */
  updatePullRequestReviewComment?: UpdatePullRequestReviewCommentPayload;
  /** Updates the state for subscribable subjects. */
  updateSubscription?: UpdateSubscriptionPayload;
  /** Replaces the repository's topics with the given topics. */
  updateTopics?: UpdateTopicsPayload;
};

/** An object with an ID. */
export type Node = {
  __interface: {
    /** ID of the object. */
    id: string;
  };
  __resolve: {
    ["...on AddedToProjectEvent"]: AddedToProjectEvent;
    ["...on App"]: App;
    ["...on AssignedEvent"]: AssignedEvent;
    ["...on BaseRefChangedEvent"]: BaseRefChangedEvent;
    ["...on BaseRefForcePushedEvent"]: BaseRefForcePushedEvent;
    ["...on Blob"]: Blob;
    ["...on Bot"]: Bot;
    ["...on ClosedEvent"]: ClosedEvent;
    ["...on CommentDeletedEvent"]: CommentDeletedEvent;
    ["...on Commit"]: Commit;
    ["...on CommitComment"]: CommitComment;
    ["...on CommitCommentThread"]: CommitCommentThread;
    ["...on ConvertedNoteToIssueEvent"]: ConvertedNoteToIssueEvent;
    ["...on CrossReferencedEvent"]: CrossReferencedEvent;
    ["...on DemilestonedEvent"]: DemilestonedEvent;
    ["...on DeployedEvent"]: DeployedEvent;
    ["...on DeployKey"]: DeployKey;
    ["...on Deployment"]: Deployment;
    ["...on DeploymentEnvironmentChangedEvent"]: DeploymentEnvironmentChangedEvent;
    ["...on DeploymentStatus"]: DeploymentStatus;
    ["...on ExternalIdentity"]: ExternalIdentity;
    ["...on Gist"]: Gist;
    ["...on GistComment"]: GistComment;
    ["...on HeadRefDeletedEvent"]: HeadRefDeletedEvent;
    ["...on HeadRefForcePushedEvent"]: HeadRefForcePushedEvent;
    ["...on HeadRefRestoredEvent"]: HeadRefRestoredEvent;
    ["...on Issue"]: Issue;
    ["...on IssueComment"]: IssueComment;
    ["...on Label"]: Label;
    ["...on LabeledEvent"]: LabeledEvent;
    ["...on Language"]: Language;
    ["...on License"]: License;
    ["...on LockedEvent"]: LockedEvent;
    ["...on MarketplaceCategory"]: MarketplaceCategory;
    ["...on MarketplaceListing"]: MarketplaceListing;
    ["...on MentionedEvent"]: MentionedEvent;
    ["...on MergedEvent"]: MergedEvent;
    ["...on Milestone"]: Milestone;
    ["...on MilestonedEvent"]: MilestonedEvent;
    ["...on MovedColumnsInProjectEvent"]: MovedColumnsInProjectEvent;
    ["...on Organization"]: Organization;
    ["...on OrganizationIdentityProvider"]: OrganizationIdentityProvider;
    ["...on OrganizationInvitation"]: OrganizationInvitation;
    ["...on Project"]: Project;
    ["...on ProjectCard"]: ProjectCard;
    ["...on ProjectColumn"]: ProjectColumn;
    ["...on ProtectedBranch"]: ProtectedBranch;
    ["...on PublicKey"]: PublicKey;
    ["...on PullRequest"]: PullRequest;
    ["...on PullRequestCommit"]: PullRequestCommit;
    ["...on PullRequestReview"]: PullRequestReview;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
    ["...on PullRequestReviewThread"]: PullRequestReviewThread;
    ["...on PushAllowance"]: PushAllowance;
    ["...on Reaction"]: Reaction;
    ["...on Ref"]: Ref;
    ["...on ReferencedEvent"]: ReferencedEvent;
    ["...on Release"]: Release;
    ["...on ReleaseAsset"]: ReleaseAsset;
    ["...on RemovedFromProjectEvent"]: RemovedFromProjectEvent;
    ["...on RenamedTitleEvent"]: RenamedTitleEvent;
    ["...on ReopenedEvent"]: ReopenedEvent;
    ["...on Repository"]: Repository;
    ["...on RepositoryInvitation"]: RepositoryInvitation;
    ["...on RepositoryTopic"]: RepositoryTopic;
    ["...on ReviewDismissalAllowance"]: ReviewDismissalAllowance;
    ["...on ReviewDismissedEvent"]: ReviewDismissedEvent;
    ["...on ReviewRequest"]: ReviewRequest;
    ["...on ReviewRequestedEvent"]: ReviewRequestedEvent;
    ["...on ReviewRequestRemovedEvent"]: ReviewRequestRemovedEvent;
    ["...on Status"]: Status;
    ["...on StatusContext"]: StatusContext;
    ["...on SubscribedEvent"]: SubscribedEvent;
    ["...on Tag"]: Tag;
    ["...on Team"]: Team;
    ["...on Topic"]: Topic;
    ["...on Tree"]: Tree;
    ["...on UnassignedEvent"]: UnassignedEvent;
    ["...on UnlabeledEvent"]: UnlabeledEvent;
    ["...on UnlockedEvent"]: UnlockedEvent;
    ["...on UnsubscribedEvent"]: UnsubscribedEvent;
    ["...on User"]: User;
    ["...on UserContentEdit"]: UserContentEdit;
  };
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  ASC = "ASC",
  DESC = "DESC",
}

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Organization = {
  __typename?: "Organization";
  /** A URL pointing to the organization's public avatar. */
  avatarUrl: URI;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The organization's public profile description. */
  description?: string;
  /** The organization's public email. */
  email?: string;
  id: string;
  /** Whether the organization has verified its profile email and website. */
  isVerified: boolean;
  /** The organization's public profile location. */
  location?: string;
  /** The organization's login name. */
  login: string;
  /** A list of users who are members of this organization. */
  members: UserConnection;
  /** The organization's public profile name. */
  name?: string;
  /** The HTTP path creating a new team */
  newTeamResourcePath: URI;
  /** The HTTP URL creating a new team */
  newTeamUrl: URI;
  /** The billing email for the organization. */
  organizationBillingEmail?: string;
  /** A list of repositories this user has pinned to their profile */
  pinnedRepositories: RepositoryConnection;
  /** Find project by number. */
  project?: Project;
  /** A list of projects under the owner. */
  projects: ProjectConnection;
  /** The HTTP path listing organization's projects */
  projectsResourcePath: URI;
  /** The HTTP URL listing organization's projects */
  projectsUrl: URI;
  /** A list of repositories that the user owns. */
  repositories: RepositoryConnection;
  /** Find Repository. */
  repository?: Repository;
  /** 																When true the organization requires all members, billing managers, and outside
collaborators to enable two-factor authentication. */
  requiresTwoFactorAuthentication?: boolean;
  /** The HTTP path for this organization. */
  resourcePath: URI;
  /** The Organization's SAML Identity Providers */
  samlIdentityProvider?: OrganizationIdentityProvider;
  /** Find an organization's team by its slug. */
  team?: Team;
  /** A list of teams in this organization. */
  teams: TeamConnection;
  /** The HTTP path listing organization's teams */
  teamsResourcePath: URI;
  /** The HTTP URL listing organization's teams */
  teamsUrl: URI;
  /** The HTTP URL for this organization. */
  url: URI;
  /** Organization is adminable by the viewer. */
  viewerCanAdminister: boolean;
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: boolean;
  /** Viewer can create repositories on this organization */
  viewerCanCreateRepositories: boolean;
  /** Viewer can create teams on this organization. */
  viewerCanCreateTeams: boolean;
  /** Viewer is an active member of this organization. */
  viewerIsAMember: boolean;
  /** The organization's public profile URL. */
  websiteUrl?: URI;
};

/** The connection type for Organization. */
export type OrganizationConnection = {
  __typename?: "OrganizationConnection";
  /** A list of edges. */
  edges?: (OrganizationEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Organization | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename?: "OrganizationEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Organization;
};

/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type OrganizationIdentityProvider = {
  __typename?: "OrganizationIdentityProvider";
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: URI;
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: ExternalIdentityConnection;
  id: string;
  /** The x509 certificate used by the Identity Provder to sign assertions and responses. */
  idpCertificate?: X509Certificate;
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: string;
  /** Organization this Identity Provider belongs to */
  organization?: Organization;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: URI;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: URI;
};

/** An Invitation for a user to an organization. */
export type OrganizationInvitation = {
  __typename?: "OrganizationInvitation";
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The email address of the user invited to the organization. */
  email?: string;
  id: string;
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: OrganizationInvitationType;
  /** The user who was invited to the organization. */
  invitee?: User;
  /** The user who created the invitation. */
  inviter: User;
  /** The organization the invite is for */
  organization: Organization;
  /** The user's pending role in the organization (e.g. member, owner). */
  role: OrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
export type OrganizationInvitationConnection = {
  __typename?: "OrganizationInvitationConnection";
  /** A list of edges. */
  edges?: (OrganizationInvitationEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (OrganizationInvitation | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type OrganizationInvitationEdge = {
  __typename?: "OrganizationInvitationEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: OrganizationInvitation;
};

/** The possible organization invitation roles. */
export enum OrganizationInvitationRole {
  DIRECT_MEMBER = "DIRECT_MEMBER",
  REINSTATE = "REINSTATE",
  ADMIN = "ADMIN",
  BILLING_MANAGER = "BILLING_MANAGER",
}

/** The possible organization invitation types. */
export enum OrganizationInvitationType {
  EMAIL = "EMAIL",
  USER = "USER",
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: string;
  /** When paginating forwards, are there more items? */
  hasNextPage: boolean;
  /** When paginating backwards, are there more items? */
  hasPreviousPage: boolean;
  /** When paginating backwards, the cursor to continue. */
  startCursor?: string;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type Project = {
  __typename?: "Project";
  /** The project's description body. */
  body?: string;
  /** The projects description body rendered to HTML. */
  bodyHTML: HTML;
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: boolean;
  /** Identifies the date and time when the object was closed. */
  closedAt?: DateTime;
  /** List of columns in the project */
  columns: ProjectColumnConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The actor who originally created the project. */
  creator?: Actor;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
  /** The project's name. */
  name: string;
  /** The project's number. */
  number: number;
  /** The project's owner. Currently limited to repositories and organizations. */
  owner: ProjectOwner;
  /** List of pending cards in this project */
  pendingCards: ProjectCardConnection;
  /** The HTTP path for this project */
  resourcePath: URI;
  /** Whether the project is open or closed. */
  state: ProjectState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this project */
  url: URI;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
};

/** A card in a project. */
export type ProjectCard = {
  __typename?: "ProjectCard";
  /** 																The project column this card is associated under. A card may only belong to one
project column at a time. The column field will be null if the card is created
in a pending state and has yet to be associated with a column. Once cards are
associated with a column, they will not become pending in the future. */
  column?: ProjectColumn;
  /** The card content item */
  content?: ProjectCardItem;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The actor who created this card */
  creator?: Actor;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
  /** Whether the card is archived */
  isArchived: boolean;
  /** The card note */
  note?: string;
  /** The project that contains this card. */
  project: Project;
  /** The HTTP path for this card */
  resourcePath: URI;
  /** The state of ProjectCard */
  state?: ProjectCardState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this card */
  url: URI;
};

/** The possible archived states of a project card. */
export enum ProjectCardArchivedState {
  ARCHIVED = "ARCHIVED",
  NOT_ARCHIVED = "NOT_ARCHIVED",
}

/** The connection type for ProjectCard. */
export type ProjectCardConnection = {
  __typename?: "ProjectCardConnection";
  /** A list of edges. */
  edges?: (ProjectCardEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (ProjectCard | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ProjectCardEdge = {
  __typename?: "ProjectCardEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: ProjectCard;
};

/** Types that can be inside Project Cards. */
export type ProjectCardItem = {
  __union: Issue | PullRequest;
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** Various content states of a ProjectCard */
export enum ProjectCardState {
  CONTENT_ONLY = "CONTENT_ONLY",
  NOTE_ONLY = "NOTE_ONLY",
  REDACTED = "REDACTED",
}

/** A column inside a project. */
export type ProjectColumn = {
  __typename?: "ProjectColumn";
  /** List of cards in the column */
  cards: ProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
  /** The project column's name. */
  name: string;
  /** The project that contains this column. */
  project: Project;
  /** The semantic purpose of the column */
  purpose?: ProjectColumnPurpose;
  /** The HTTP path for this project column */
  resourcePath: URI;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this project column */
  url: URI;
};

/** The connection type for ProjectColumn. */
export type ProjectColumnConnection = {
  __typename?: "ProjectColumnConnection";
  /** A list of edges. */
  edges?: (ProjectColumnEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (ProjectColumn | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ProjectColumnEdge = {
  __typename?: "ProjectColumnEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: ProjectColumn;
};

/** The semantic purpose of the column - todo, in progress, or done. */
export enum ProjectColumnPurpose {
  DONE = "DONE",
  IN_PROGRESS = "IN_PROGRESS",
  TODO = "TODO",
}

/** A list of projects associated with the owner. */
export type ProjectConnection = {
  __typename?: "ProjectConnection";
  /** A list of edges. */
  edges?: (ProjectEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Project | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: "ProjectEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Project;
};

/** Ways in which lists of projects can be ordered upon return. */
export type ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
  /** The field in which to order projects by. */
  field: ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export enum ProjectOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  UPDATED_AT = "UPDATED_AT",
}

/** Represents an owner of a Project. */
export type ProjectOwner = {
  __interface: {
    /** A list of projects under the owner. */
    projects: ProjectConnection;
    /** The HTTP path listing owners projects */
    projectsResourcePath: URI;
    /** The HTTP URL listing owners projects */
    projectsUrl: URI;
    /** Can the current viewer create new projects on this owner. */
    viewerCanCreateProjects: boolean;
    id: string;
    /** Find project by number. */
    project?: Project;
  };
  __resolve: {
    ["...on Organization"]: Organization;
    ["...on Repository"]: Repository;
  };
};

/** State of the project; either 'open' or 'closed' */
export enum ProjectState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

/** A repository protected branch. */
export type ProtectedBranch = {
  __typename?: "ProtectedBranch";
  /** The actor who created this protected branch. */
  creator?: Actor;
  /** Will new commits pushed to this branch dismiss pull request review approvals. */
  hasDismissableStaleReviews: boolean;
  /** Are reviews required to update this branch. */
  hasRequiredReviews: boolean;
  /** Are status checks required to update this branch. */
  hasRequiredStatusChecks: boolean;
  /** Is pushing to this branch restricted. */
  hasRestrictedPushes: boolean;
  /** Is dismissal of pull request reviews restricted. */
  hasRestrictedReviewDismissals: boolean;
  /** Are branches required to be up to date before merging. */
  hasStrictRequiredStatusChecks: boolean;
  id: string;
  /** Can admins overwrite branch protection. */
  isAdminEnforced: boolean;
  /** The name of the protected branch rule. */
  name: string;
  /** A list push allowances for this protected branch. */
  pushAllowances: PushAllowanceConnection;
  /** The repository associated with this protected branch. */
  repository: Repository;
  /** List of required status check contexts that must pass for commits to be accepted to this branch. */
  requiredStatusCheckContexts?: (string | undefined)[];
  /** A list review dismissal allowances for this protected branch. */
  reviewDismissalAllowances: ReviewDismissalAllowanceConnection;
};

/** The connection type for ProtectedBranch. */
export type ProtectedBranchConnection = {
  __typename?: "ProtectedBranchConnection";
  /** A list of edges. */
  edges?: (ProtectedBranchEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (ProtectedBranch | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ProtectedBranchEdge = {
  __typename?: "ProtectedBranchEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: ProtectedBranch;
};

/** A user's public key. */
export type PublicKey = {
  __typename?: "PublicKey";
  id: string;
  /** The public key string */
  key: string;
};

/** The connection type for PublicKey. */
export type PublicKeyConnection = {
  __typename?: "PublicKeyConnection";
  /** A list of edges. */
  edges?: (PublicKeyEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (PublicKey | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type PublicKeyEdge = {
  __typename?: "PublicKeyEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: PublicKey;
};

/** A repository pull request. */
export type PullRequest = {
  __typename?: "PullRequest";
  /** Reason that the conversation was locked. */
  activeLockReason?: LockReason;
  /** The number of additions in this pull request. */
  additions: number;
  /** A list of Users assigned to this object. */
  assignees: UserConnection;
  /** The actor who authored the comment. */
  author?: Actor;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the base Ref associated with the pull request. */
  baseRef?: Ref;
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  baseRefName: string;
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  baseRefOid: GitObjectID;
  /** The body as Markdown. */
  body: string;
  /** The body rendered to HTML. */
  bodyHTML: HTML;
  /** The body rendered to text. */
  bodyText: string;
  /** The number of changed files in this pull request. */
  changedFiles: number;
  /** `true` if the pull request is closed */
  closed: boolean;
  /** Identifies the date and time when the object was closed. */
  closedAt?: DateTime;
  /** A list of comments associated with the pull request. */
  comments: IssueCommentConnection;
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  commits: PullRequestCommitConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Check if this comment was created via an email reply. */
  createdViaEmail: boolean;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The number of deletions in this pull request. */
  deletions: number;
  /** The actor who edited this pull request's body. */
  editor?: Actor;
  /** Identifies the head Ref associated with the pull request. */
  headRef?: Ref;
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  headRefName: string;
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  headRefOid: GitObjectID;
  /** The repository associated with this pull request's head Ref. */
  headRepository?: Repository;
  /** The owner of the repository associated with this pull request's head Ref. */
  headRepositoryOwner?: RepositoryOwner;
  id: string;
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: boolean;
  /** The head and base repositories are different. */
  isCrossRepository: boolean;
  /** A list of labels associated with the object. */
  labels?: LabelConnection;
  /** The moment the editor made the last edit */
  lastEditedAt?: DateTime;
  /** `true` if the pull request is locked */
  locked: boolean;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify: boolean;
  /** The commit that was created when this pull request was merged. */
  mergeCommit?: Commit;
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  mergeable: MergeableState;
  /** Whether or not the pull request was merged. */
  merged: boolean;
  /** The date and time that the pull request was merged. */
  mergedAt?: DateTime;
  /** The actor who merged the pull request. */
  mergedBy?: Actor;
  /** Identifies the milestone associated with the pull request. */
  milestone?: Milestone;
  /** Identifies the pull request number. */
  number: number;
  /** A list of Users that are participating in the Pull Request conversation. */
  participants: UserConnection;
  /** The permalink to the pull request. */
  permalink: URI;
  /** 																The commit that GitHub automatically generated to test if this pull request
could be merged. This field will not return a value if the pull request is
merged, or if the test merge commit is still being generated. See the
`mergeable` field for more details on the mergeability of the pull request. */
  potentialMergeCommit?: Commit;
  /** List of project cards associated with this pull request. */
  projectCards: ProjectCardConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: DateTime;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: ReactionGroup[];
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path for this pull request. */
  resourcePath: URI;
  /** The HTTP path for reverting this pull request. */
  revertResourcePath: URI;
  /** The HTTP URL for reverting this pull request. */
  revertUrl: URI;
  /** A list of review requests associated with the pull request. */
  reviewRequests?: ReviewRequestConnection;
  /** A list of reviews associated with the pull request. */
  reviews?: PullRequestReviewConnection;
  /** Identifies the state of the pull request. */
  state: PullRequestState;
  /** A list of reviewer suggestions based on commit history and past review comments. */
  suggestedReviewers?: SuggestedReviewer[];
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timeline: PullRequestTimelineConnection;
  /** Identifies the pull request title. */
  title: string;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this pull request. */
  url: URI;
  /** A list of edits to this content. */
  userContentEdits?: UserContentEditConnection;
  /** Whether or not the viewer can apply suggestion. */
  viewerCanApplySuggestion: boolean;
  /** Can user react to this subject */
  viewerCanReact: boolean;
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: boolean;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  /** Did the viewer author this comment. */
  viewerDidAuthor: boolean;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: SubscriptionState;
};

/** Represents a Git commit part of a pull request. */
export type PullRequestCommit = {
  __typename?: "PullRequestCommit";
  /** The Git commit object */
  commit: Commit;
  id: string;
  /** The pull request this commit belongs to */
  pullRequest: PullRequest;
  /** The HTTP path for this pull request commit */
  resourcePath: URI;
  /** The HTTP URL for this pull request commit */
  url: URI;
};

/** The connection type for PullRequestCommit. */
export type PullRequestCommitConnection = {
  __typename?: "PullRequestCommitConnection";
  /** A list of edges. */
  edges?: (PullRequestCommitEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (PullRequestCommit | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type PullRequestCommitEdge = {
  __typename?: "PullRequestCommitEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: PullRequestCommit;
};

/** The connection type for PullRequest. */
export type PullRequestConnection = {
  __typename?: "PullRequestConnection";
  /** A list of edges. */
  edges?: (PullRequestEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (PullRequest | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type PullRequestEdge = {
  __typename?: "PullRequestEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: PullRequest;
};

/** A review object for a given pull request. */
export type PullRequestReview = {
  __typename?: "PullRequestReview";
  /** The actor who authored the comment. */
  author?: Actor;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** Identifies the pull request review body. */
  body: string;
  /** The body of this review rendered to HTML. */
  bodyHTML: HTML;
  /** The body of this review rendered as plain text. */
  bodyText: string;
  /** A list of review comments for the current pull request review. */
  comments: PullRequestReviewCommentConnection;
  /** Identifies the commit associated with this pull request review. */
  commit?: Commit;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Check if this comment was created via an email reply. */
  createdViaEmail: boolean;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The actor who edited the comment. */
  editor?: Actor;
  id: string;
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: boolean;
  /** The moment the editor made the last edit */
  lastEditedAt?: DateTime;
  /** Identifies when the comment was published at. */
  publishedAt?: DateTime;
  /** Identifies the pull request associated with this pull request review. */
  pullRequest: PullRequest;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path permalink for this PullRequestReview. */
  resourcePath: URI;
  /** Identifies the current state of the pull request review. */
  state: PullRequestReviewState;
  /** Identifies when the Pull Request Review was submitted */
  submittedAt?: DateTime;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL permalink for this PullRequestReview. */
  url: URI;
  /** A list of edits to this content. */
  userContentEdits?: UserContentEditConnection;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: boolean;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  /** Did the viewer author this comment. */
  viewerDidAuthor: boolean;
};

/** A review comment associated with a given repository pull request. */
export type PullRequestReviewComment = {
  __typename?: "PullRequestReviewComment";
  /** The actor who authored the comment. */
  author?: Actor;
  /** Author's association with the subject of the comment. */
  authorAssociation: CommentAuthorAssociation;
  /** The comment body of this review comment. */
  body: string;
  /** The comment body of this review comment rendered to HTML. */
  bodyHTML: HTML;
  /** The comment body of this review comment rendered as plain text. */
  bodyText: string;
  /** Identifies the commit associated with the comment. */
  commit: Commit;
  /** Identifies when the comment was created. */
  createdAt: DateTime;
  /** Check if this comment was created via an email reply. */
  createdViaEmail: boolean;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The diff hunk to which the comment applies. */
  diffHunk: string;
  /** Identifies when the comment was created in a draft state. */
  draftedAt: DateTime;
  /** The actor who edited the comment. */
  editor?: Actor;
  id: string;
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: boolean;
  /** The moment the editor made the last edit */
  lastEditedAt?: DateTime;
  /** Identifies the original commit associated with the comment. */
  originalCommit?: Commit;
  /** The original line index in the diff to which the comment applies. */
  originalPosition: number;
  /** The path to which the comment applies. */
  path: string;
  /** The line index in the diff to which the comment applies. */
  position?: number;
  /** Identifies when the comment was published at. */
  publishedAt?: DateTime;
  /** The pull request associated with this review comment. */
  pullRequest: PullRequest;
  /** The pull request review associated with this review comment. */
  pullRequestReview?: PullRequestReview;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: ReactionGroup[];
  /** A list of Reactions left on the Issue. */
  reactions: ReactionConnection;
  /** The comment this is a reply to. */
  replyTo?: PullRequestReviewComment;
  /** The repository associated with this node. */
  repository: Repository;
  /** The HTTP path permalink for this review comment. */
  resourcePath: URI;
  /** Identifies when the comment was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL permalink for this review comment. */
  url: URI;
  /** A list of edits to this content. */
  userContentEdits?: UserContentEditConnection;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: boolean;
  /** Can user react to this subject */
  viewerCanReact: boolean;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: boolean;
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  /** Did the viewer author this comment. */
  viewerDidAuthor: boolean;
};

/** The connection type for PullRequestReviewComment. */
export type PullRequestReviewCommentConnection = {
  __typename?: "PullRequestReviewCommentConnection";
  /** A list of edges. */
  edges?: (PullRequestReviewCommentEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (PullRequestReviewComment | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type PullRequestReviewCommentEdge = {
  __typename?: "PullRequestReviewCommentEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: PullRequestReviewComment;
};

/** The connection type for PullRequestReview. */
export type PullRequestReviewConnection = {
  __typename?: "PullRequestReviewConnection";
  /** A list of edges. */
  edges?: (PullRequestReviewEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (PullRequestReview | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type PullRequestReviewEdge = {
  __typename?: "PullRequestReviewEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: PullRequestReview;
};

/** The possible events to perform on a pull request review. */
export enum PullRequestReviewEvent {
  DISMISS = "DISMISS",
  REQUEST_CHANGES = "REQUEST_CHANGES",
  APPROVE = "APPROVE",
  COMMENT = "COMMENT",
}

/** The possible states of a pull request review. */
export enum PullRequestReviewState {
  CHANGES_REQUESTED = "CHANGES_REQUESTED",
  COMMENTED = "COMMENTED",
  DISMISSED = "DISMISSED",
  PENDING = "PENDING",
  APPROVED = "APPROVED",
}

/** A threaded list of comments for a given pull request. */
export type PullRequestReviewThread = {
  __typename?: "PullRequestReviewThread";
  /** A list of pull request comments associated with the thread. */
  comments: PullRequestReviewCommentConnection;
  id: string;
  /** Identifies the pull request associated with this thread. */
  pullRequest: PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Repository;
};

/** The possible states of a pull request. */
export enum PullRequestState {
  CLOSED = "CLOSED",
  MERGED = "MERGED",
  OPEN = "OPEN",
}

/** The connection type for PullRequestTimelineItem. */
export type PullRequestTimelineConnection = {
  __typename?: "PullRequestTimelineConnection";
  /** A list of edges. */
  edges?: (PullRequestTimelineItemEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (PullRequestTimelineItem | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An item in an pull request timeline */
export type PullRequestTimelineItem = {
  __union:
    | AssignedEvent
    | BaseRefForcePushedEvent
    | ClosedEvent
    | Commit
    | CommitCommentThread
    | CrossReferencedEvent
    | DemilestonedEvent
    | DeployedEvent
    | DeploymentEnvironmentChangedEvent
    | HeadRefDeletedEvent
    | HeadRefForcePushedEvent
    | HeadRefRestoredEvent
    | IssueComment
    | LabeledEvent
    | LockedEvent
    | MergedEvent
    | MilestonedEvent
    | PullRequestReview
    | PullRequestReviewComment
    | PullRequestReviewThread
    | ReferencedEvent
    | RenamedTitleEvent
    | ReopenedEvent
    | ReviewDismissedEvent
    | ReviewRequestRemovedEvent
    | ReviewRequestedEvent
    | SubscribedEvent
    | UnassignedEvent
    | UnlabeledEvent
    | UnlockedEvent
    | UnsubscribedEvent;
  __resolve: {
    ["...on AssignedEvent"]: AssignedEvent;
    ["...on BaseRefForcePushedEvent"]: BaseRefForcePushedEvent;
    ["...on ClosedEvent"]: ClosedEvent;
    ["...on Commit"]: Commit;
    ["...on CommitCommentThread"]: CommitCommentThread;
    ["...on CrossReferencedEvent"]: CrossReferencedEvent;
    ["...on DemilestonedEvent"]: DemilestonedEvent;
    ["...on DeployedEvent"]: DeployedEvent;
    ["...on DeploymentEnvironmentChangedEvent"]: DeploymentEnvironmentChangedEvent;
    ["...on HeadRefDeletedEvent"]: HeadRefDeletedEvent;
    ["...on HeadRefForcePushedEvent"]: HeadRefForcePushedEvent;
    ["...on HeadRefRestoredEvent"]: HeadRefRestoredEvent;
    ["...on IssueComment"]: IssueComment;
    ["...on LabeledEvent"]: LabeledEvent;
    ["...on LockedEvent"]: LockedEvent;
    ["...on MergedEvent"]: MergedEvent;
    ["...on MilestonedEvent"]: MilestonedEvent;
    ["...on PullRequestReview"]: PullRequestReview;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
    ["...on PullRequestReviewThread"]: PullRequestReviewThread;
    ["...on ReferencedEvent"]: ReferencedEvent;
    ["...on RenamedTitleEvent"]: RenamedTitleEvent;
    ["...on ReopenedEvent"]: ReopenedEvent;
    ["...on ReviewDismissedEvent"]: ReviewDismissedEvent;
    ["...on ReviewRequestRemovedEvent"]: ReviewRequestRemovedEvent;
    ["...on ReviewRequestedEvent"]: ReviewRequestedEvent;
    ["...on SubscribedEvent"]: SubscribedEvent;
    ["...on UnassignedEvent"]: UnassignedEvent;
    ["...on UnlabeledEvent"]: UnlabeledEvent;
    ["...on UnlockedEvent"]: UnlockedEvent;
    ["...on UnsubscribedEvent"]: UnsubscribedEvent;
  };
};

/** An edge in a connection. */
export type PullRequestTimelineItemEdge = {
  __typename?: "PullRequestTimelineItemEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: PullRequestTimelineItem;
};

/** A team or user who has the ability to push to a protected branch. */
export type PushAllowance = {
  __typename?: "PushAllowance";
  /** The actor that can push. */
  actor?: PushAllowanceActor;
  id: string;
  /** Identifies the protected branch associated with the allowed user or team. */
  protectedBranch: ProtectedBranch;
};

/** Types that can be an actor. */
export type PushAllowanceActor = {
  __union: Team | User;
  __resolve: {
    ["...on Team"]: Team;
    ["...on User"]: User;
  };
};

/** The connection type for PushAllowance. */
export type PushAllowanceConnection = {
  __typename?: "PushAllowanceConnection";
  /** A list of edges. */
  edges?: (PushAllowanceEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (PushAllowance | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type PushAllowanceEdge = {
  __typename?: "PushAllowanceEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: PushAllowance;
};

/** The query root of GitHub's GraphQL interface. */
export type Query = {
  __typename?: "Query";
  /** Look up a code of conduct by its key */
  codeOfConduct?: CodeOfConduct;
  /** Look up a code of conduct by its key */
  codesOfConduct?: (CodeOfConduct | undefined)[];
  /** Look up an open source license by its key */
  license?: License;
  /** Return a list of known open source licenses */
  licenses?: License[];
  /** Get alphabetically sorted list of Marketplace categories */
  marketplaceCategories: MarketplaceCategory[];
  /** Look up a Marketplace category by its slug. */
  marketplaceCategory?: MarketplaceCategory;
  /** Look up a single Marketplace listing */
  marketplaceListing?: MarketplaceListing;
  /** Look up Marketplace listings */
  marketplaceListings: MarketplaceListingConnection;
  /** Return information about the GitHub instance */
  meta: GitHubMetadata;
  /** Fetches an object given its ID. */
  node?: Node;
  /** Lookup nodes by a list of IDs. */
  nodes?: Node[];
  /** Lookup a organization by login. */
  organization?: Organization;
  /** The client's rate limit information. */
  rateLimit?: RateLimit;
  /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */
  relay: Query;
  /** Lookup a given repository by the owner and repository name. */
  repository?: Repository;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  repositoryOwner?: RepositoryOwner;
  /** Lookup resource by a URL. */
  resource?: UniformResourceLocatable;
  /** Perform a search across resources. */
  search: SearchResultItemConnection;
  /** Look up a topic by name. */
  topic?: Topic;
  /** Lookup a user by login. */
  user?: User;
  /** The currently authenticated user. */
  viewer: User;
};

/** Represents the client's rate limit. */
export type RateLimit = {
  __typename?: "RateLimit";
  /** The point cost for the current query counting against the rate limit. */
  cost: number;
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: number;
  /** The maximum number of nodes this query may return */
  nodeCount: number;
  /** The number of points remaining in the current rate limit window. */
  remaining: number;
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: DateTime;
};

/** Represents a subject that can be reacted on. */
export type Reactable = {
  __interface: {
    id: string;
    /** A list of reactions grouped by content left on the subject. */
    reactionGroups?: ReactionGroup[];
    /** A list of Reactions left on the Issue. */
    reactions: ReactionConnection;
    /** Can user react to this subject */
    viewerCanReact: boolean;
    /** Identifies the primary key from the database. */
    databaseId?: number;
  };
  __resolve: {
    ["...on CommitComment"]: CommitComment;
    ["...on Issue"]: Issue;
    ["...on IssueComment"]: IssueComment;
    ["...on PullRequest"]: PullRequest;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
  };
};

/** The connection type for User. */
export type ReactingUserConnection = {
  __typename?: "ReactingUserConnection";
  /** A list of edges. */
  edges?: (ReactingUserEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (User | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a user that's made a reaction. */
export type ReactingUserEdge = {
  __typename?: "ReactingUserEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  node: User;
  /** The moment when the user made the reaction. */
  reactedAt: DateTime;
};

/** An emoji reaction to a particular piece of content. */
export type Reaction = {
  __typename?: "Reaction";
  /** Identifies the emoji reaction. */
  content: ReactionContent;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
  /** The reactable piece of content */
  reactable: Reactable;
  /** Identifies the user who created this reaction. */
  user?: User;
};

/** A list of reactions that have been left on the subject. */
export type ReactionConnection = {
  __typename?: "ReactionConnection";
  /** A list of edges. */
  edges?: (ReactionEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Reaction | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: boolean;
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum ReactionContent {
  THUMBS_UP = "THUMBS_UP",
  CONFUSED = "CONFUSED",
  HEART = "HEART",
  HOORAY = "HOORAY",
  LAUGH = "LAUGH",
  THUMBS_DOWN = "THUMBS_DOWN",
}

/** An edge in a connection. */
export type ReactionEdge = {
  __typename?: "ReactionEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Reaction;
};

/** A group of emoji reactions to a particular piece of content. */
export type ReactionGroup = {
  __typename?: "ReactionGroup";
  /** Identifies the emoji reaction. */
  content: ReactionContent;
  /** Identifies when the reaction was created. */
  createdAt?: DateTime;
  /** The subject that was reacted to. */
  subject: Reactable;
  /** Users who have reacted to the reaction subject with the emotion represented by this reaction group */
  users: ReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: boolean;
};

/** Ways in which lists of reactions can be ordered upon return. */
export type ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: OrderDirection;
  /** The field in which to order reactions by. */
  field: ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export enum ReactionOrderField {
  CREATED_AT = "CREATED_AT",
}

/** Represents a Git reference. */
export type Ref = {
  __typename?: "Ref";
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: PullRequestConnection;
  id: string;
  /** The ref name. */
  name: string;
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: string;
  /** The repository the ref belongs to. */
  repository: Repository;
  /** The object the ref points to. */
  target: GitObject;
};

/** The connection type for Ref. */
export type RefConnection = {
  __typename?: "RefConnection";
  /** A list of edges. */
  edges?: (RefEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Ref | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type RefEdge = {
  __typename?: "RefEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Ref;
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type ReferencedEvent = {
  __typename?: "ReferencedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Commit;
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: Repository;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Reference originated in a different repository. */
  isCrossRepository: boolean;
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: boolean;
  /** Object referenced by event. */
  subject: ReferencedSubject;
};

/** Any referencable object */
export type ReferencedSubject = {
  __union: Issue | PullRequest;
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** Ways in which lists of git refs can be ordered upon return. */
export type RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: OrderDirection;
  /** The field in which to order refs by. */
  field: RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export enum RefOrderField {
  ALPHABETICAL = "ALPHABETICAL",
  TAG_COMMIT_DATE = "TAG_COMMIT_DATE",
}

/** Represents an owner of a registry package. */
export type RegistryPackageOwner = {
  __interface: {
    id: string;
  };
  __resolve: {
    ["...on Organization"]: Organization;
    ["...on Repository"]: Repository;
    ["...on User"]: User;
  };
};

/** Represents an interface to search packages on an object. */
export type RegistryPackageSearch = {
  __interface: {
    id: string;
  };
  __resolve: {
    ["...on Organization"]: Organization;
    ["...on User"]: User;
  };
};

/** A release contains the content for a release. */
export type Release = {
  __typename?: "Release";
  /** The author of the release */
  author?: User;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the description of the release. */
  description?: string;
  id: string;
  /** Whether or not the release is a draft */
  isDraft: boolean;
  /** Whether or not the release is a prerelease */
  isPrerelease: boolean;
  /** Identifies the title of the release. */
  name?: string;
  /** Identifies the date and time when the release was created. */
  publishedAt?: DateTime;
  /** List of releases assets which are dependent on this release. */
  releaseAssets: ReleaseAssetConnection;
  /** The HTTP path for this issue */
  resourcePath: URI;
  /** The Git tag the release points to */
  tag?: Ref;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this issue */
  url: URI;
};

/** A release asset contains the content for a release asset. */
export type ReleaseAsset = {
  __typename?: "ReleaseAsset";
  /** The asset's content-type */
  contentType: string;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The number of times this asset was downloaded */
  downloadCount: number;
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: URI;
  id: string;
  /** Identifies the title of the release asset. */
  name: string;
  /** Release that the asset is associated with */
  release?: Release;
  /** The size (in bytes) of the asset */
  size: number;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The user that performed the upload */
  uploadedBy: User;
  /** Identifies the URL of the release asset. */
  url: URI;
};

/** The connection type for ReleaseAsset. */
export type ReleaseAssetConnection = {
  __typename?: "ReleaseAssetConnection";
  /** A list of edges. */
  edges?: (ReleaseAssetEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (ReleaseAsset | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ReleaseAssetEdge = {
  __typename?: "ReleaseAssetEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: ReleaseAsset;
};

/** The connection type for Release. */
export type ReleaseConnection = {
  __typename?: "ReleaseConnection";
  /** A list of edges. */
  edges?: (ReleaseEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Release | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ReleaseEdge = {
  __typename?: "ReleaseEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Release;
};

/** Ways in which lists of releases can be ordered upon return. */
export type ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: OrderDirection;
  /** The field in which to order releases by. */
  field: ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export enum ReleaseOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
}

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type RemovedFromProjectEvent = {
  __typename?: "RemovedFromProjectEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorInput = {
  /** The ID of the outside collaborator to remove. */
  userId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: string;
};

/** Autogenerated return type of RemoveOutsideCollaborator */
export type RemoveOutsideCollaboratorPayload = {
  __typename?: "RemoveOutsideCollaboratorPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The user that was removed as an outside collaborator.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `removedUser` will change from `User!` to `User`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  removedUser: User;
};

/** Autogenerated input type of RemoveReaction */
export type RemoveReactionInput = {
  /** The Node ID of the subject to modify. */
  subjectId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of the emoji reaction to remove. */
  content: ReactionContent;
};

/** Autogenerated return type of RemoveReaction */
export type RemoveReactionPayload = {
  __typename?: "RemoveReactionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The reaction object.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `reaction` will change from `Reaction!` to `Reaction`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  reaction: Reaction;
  /** 														The reactable subject.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subject` will change from `Reactable!` to `Reactable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  subject: Reactable;
};

/** Autogenerated input type of RemoveStar */
export type RemoveStarInput = {
  /** The Starrable ID to unstar. */
  starrableId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
};

/** Autogenerated return type of RemoveStar */
export type RemoveStarPayload = {
  __typename?: "RemoveStarPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The starrable.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `starrable` will change from `Starrable!` to `Starrable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  starrable: Starrable;
};

/** Represents a 'renamed' event on a given issue or pull request */
export type RenamedTitleEvent = {
  __typename?: "RenamedTitleEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the current title of the issue or pull request. */
  currentTitle: string;
  id: string;
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: string;
  /** Subject that was renamed. */
  subject: RenamedTitleSubject;
};

/** An object which has a renamable title */
export type RenamedTitleSubject = {
  __union: Issue | PullRequest;
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
  };
};

/** Represents a 'reopened' event on any `Closable`. */
export type ReopenedEvent = {
  __typename?: "ReopenedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Object that was reopened. */
  closable: Closable;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
};

/** A repository contains the content for a project. */
export type Repository = {
  __typename?: "Repository";
  /** A list of users that can be assigned to issues in this repository. */
  assignableUsers: UserConnection;
  /** Returns the code of conduct for this repository */
  codeOfConduct?: CodeOfConduct;
  /** A list of collaborators associated with the repository. */
  collaborators?: RepositoryCollaboratorConnection;
  /** A list of commit comments associated with the repository. */
  commitComments: CommitCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The Ref associated with the repository's default branch. */
  defaultBranchRef?: Ref;
  /** A list of deploy keys that are on this repository. */
  deployKeys: DeployKeyConnection;
  /** Deployments associated with the repository */
  deployments: DeploymentConnection;
  /** The description of the repository. */
  description?: string;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: HTML;
  /** The number of kilobytes this repository occupies on disk. */
  diskUsage?: number;
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: number;
  /** A list of direct forked repositories. */
  forks: RepositoryConnection;
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: boolean;
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: boolean;
  /** The repository's URL. */
  homepageUrl?: URI;
  id: string;
  /** Indicates if the repository is unmaintained. */
  isArchived: boolean;
  /** Identifies if the repository is a fork. */
  isFork: boolean;
  /** Indicates if the repository has been locked or not. */
  isLocked: boolean;
  /** Identifies if the repository is a mirror. */
  isMirror: boolean;
  /** Identifies if the repository is private. */
  isPrivate: boolean;
  /** Returns a single issue from the current repository by number. */
  issue?: Issue;
  /** Returns a single issue-like object from the current repository by number. */
  issueOrPullRequest?: IssueOrPullRequest;
  /** A list of issues that have been opened in the repository. */
  issues: IssueConnection;
  /** Returns a single label by name */
  label?: Label;
  /** A list of labels associated with the repository. */
  labels?: LabelConnection;
  /** A list containing a breakdown of the language composition of the repository. */
  languages?: LanguageConnection;
  /** The license associated with the repository */
  licenseInfo?: License;
  /** The reason the repository has been locked. */
  lockReason?: RepositoryLockReason;
  /** A list of Users that can be mentioned in the context of the repository. */
  mentionableUsers: UserConnection;
  /** Whether or not PRs are merged with a merge commit on this repository. */
  mergeCommitAllowed: boolean;
  /** Returns a single milestone from the current repository by number. */
  milestone?: Milestone;
  /** A list of milestones associated with the repository. */
  milestones?: MilestoneConnection;
  /** The repository's original mirror URL. */
  mirrorUrl?: URI;
  /** The name of the repository. */
  name: string;
  /** The repository's name with owner. */
  nameWithOwner: string;
  /** A Git object in the repository */
  object?: GitObject;
  /** The User owner of the repository. */
  owner: RepositoryOwner;
  /** The repository parent, if this is a fork. */
  parent?: Repository;
  /** The primary language of the repository's code. */
  primaryLanguage?: Language;
  /** Find project by number. */
  project?: Project;
  /** A list of projects under the owner. */
  projects: ProjectConnection;
  /** The HTTP path listing the repository's projects */
  projectsResourcePath: URI;
  /** The HTTP URL listing the repository's projects */
  projectsUrl: URI;
  /** A list of protected branches that are on this repository. */
  protectedBranches: ProtectedBranchConnection;
  /** Returns a single pull request from the current repository by number. */
  pullRequest?: PullRequest;
  /** A list of pull requests that have been opened in the repository. */
  pullRequests: PullRequestConnection;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: DateTime;
  /** Whether or not rebase-merging is enabled on this repository. */
  rebaseMergeAllowed: boolean;
  /** Fetch a given ref from the repository */
  ref?: Ref;
  /** Fetch a list of refs from the repository */
  refs?: RefConnection;
  /** Lookup a single release given various criteria. */
  release?: Release;
  /** List of releases which are dependent on this repository. */
  releases: ReleaseConnection;
  /** A list of applied repository-topic associations for this repository. */
  repositoryTopics: RepositoryTopicConnection;
  /** The HTTP path for this repository */
  resourcePath: URI;
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: HTML;
  /** Whether or not squash-merging is enabled on this repository. */
  squashMergeAllowed: boolean;
  /** The SSH URL to clone this repository */
  sshUrl: GitSSHRemote;
  /** A list of users who have starred this starrable. */
  stargazers: StargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this repository */
  url: URI;
  /** Indicates whether the viewer has admin permissions on this repository. */
  viewerCanAdminister: boolean;
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: boolean;
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: boolean;
  /** Indicates whether the viewer can update the topics of this repository. */
  viewerCanUpdateTopics: boolean;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: boolean;
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  viewerPermission?: RepositoryPermission;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: SubscriptionState;
  /** A list of users watching the repository. */
  watchers: UserConnection;
};

/** The affiliation of a user to a repository */
export enum RepositoryAffiliation {
  COLLABORATOR = "COLLABORATOR",
  ORGANIZATION_MEMBER = "ORGANIZATION_MEMBER",
  OWNER = "OWNER",
}

/** The connection type for User. */
export type RepositoryCollaboratorConnection = {
  __typename?: "RepositoryCollaboratorConnection";
  /** A list of edges. */
  edges?: (RepositoryCollaboratorEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (User | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a user who is a collaborator of a repository. */
export type RepositoryCollaboratorEdge = {
  __typename?: "RepositoryCollaboratorEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  node: User;
  /** The permission the user has on the repository. */
  permission: RepositoryPermission;
};

/** A list of repositories owned by the subject. */
export type RepositoryConnection = {
  __typename?: "RepositoryConnection";
  /** A list of edges. */
  edges?: (RepositoryEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Repository | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
  /** The total size in kilobytes of all repositories in the connection. */
  totalDiskUsage: number;
};

/** The reason a repository is listed as 'contributed'. */
export enum RepositoryContributionType {
  COMMIT = "COMMIT",
  ISSUE = "ISSUE",
  PULL_REQUEST = "PULL_REQUEST",
  PULL_REQUEST_REVIEW = "PULL_REQUEST_REVIEW",
  REPOSITORY = "REPOSITORY",
}

/** An edge in a connection. */
export type RepositoryEdge = {
  __typename?: "RepositoryEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Repository;
};

/** A subset of repository info. */
export type RepositoryInfo = {
  __interface: {
    /** Indicates if the repository has issues feature enabled. */
    hasIssuesEnabled: boolean;
    /** The HTTP path for this repository */
    resourcePath: URI;
    /** The HTTP URL for this repository */
    url: URI;
    /** Identifies the date and time when the object was created. */
    createdAt: DateTime;
    /** Indicates if the repository has been locked or not. */
    isLocked: boolean;
    /** The description of the repository. */
    description?: string;
    /** A description of the repository, rendered to HTML without any links in it. */
    shortDescriptionHTML: HTML;
    /** Identifies the date and time when the object was last updated. */
    updatedAt: DateTime;
    /** Identifies if the repository is a mirror. */
    isMirror: boolean;
    /** Identifies if the repository is a fork. */
    isFork: boolean;
    /** Identifies when the repository was last pushed to. */
    pushedAt?: DateTime;
    /** The name of the repository. */
    name: string;
    /** The repository's name with owner. */
    nameWithOwner: string;
    /** The description of the repository rendered to HTML. */
    descriptionHTML: HTML;
    /** Indicates if the repository has wiki feature enabled. */
    hasWikiEnabled: boolean;
    /** The repository's URL. */
    homepageUrl?: URI;
    /** The User owner of the repository. */
    owner: RepositoryOwner;
    /** The reason the repository has been locked. */
    lockReason?: RepositoryLockReason;
    /** Identifies if the repository is private. */
    isPrivate: boolean;
    /** The repository's original mirror URL. */
    mirrorUrl?: URI;
    /** Returns how many forks there are of this repository in the whole network. */
    forkCount: number;
    /** Indicates if the repository is unmaintained. */
    isArchived: boolean;
    /** The license associated with the repository */
    licenseInfo?: License;
  };
  __resolve: {
    ["...on Repository"]: Repository;
  };
};

/** An invitation for a user to be added to a repository. */
export type RepositoryInvitation = {
  __typename?: "RepositoryInvitation";
  id: string;
  /** The user who received the invitation. */
  invitee: User;
  /** The user who created the invitation. */
  inviter: User;
  /** The permission granted on this repository by this invitation. */
  permission: RepositoryPermission;
  /** The Repository the user is invited to. */
  repository?: RepositoryInfo;
};

/** The possible reasons a given repository could be in a locked state. */
export enum RepositoryLockReason {
  RENAME = "RENAME",
  BILLING = "BILLING",
  MIGRATING = "MIGRATING",
  MOVING = "MOVING",
}

/** Represents a object that belongs to a repository. */
export type RepositoryNode = {
  __interface: {
    /** The repository associated with this node. */
    repository: Repository;
  };
  __resolve: {
    ["...on CommitComment"]: CommitComment;
    ["...on CommitCommentThread"]: CommitCommentThread;
    ["...on Issue"]: Issue;
    ["...on IssueComment"]: IssueComment;
    ["...on PullRequest"]: PullRequest;
    ["...on PullRequestReview"]: PullRequestReview;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
  };
};

/** Ordering options for repository connections */
export type RepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export enum RepositoryOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  PUSHED_AT = "PUSHED_AT",
  STARGAZERS = "STARGAZERS",
  UPDATED_AT = "UPDATED_AT",
}

/** Represents an owner of a Repository. */
export type RepositoryOwner = {
  __interface: {
    /** The username used to login. */
    login: string;
    /** A list of repositories this user has pinned to their profile */
    pinnedRepositories: RepositoryConnection;
    /** A list of repositories that the user owns. */
    repositories: RepositoryConnection;
    /** Find Repository. */
    repository?: Repository;
    /** The HTTP URL for the owner. */
    resourcePath: URI;
    /** The HTTP URL for the owner. */
    url: URI;
    /** A URL pointing to the owner's public avatar. */
    avatarUrl: URI;
    id: string;
  };
  __resolve: {
    ["...on Organization"]: Organization;
    ["...on User"]: User;
  };
};

/** The access level to a repository */
export enum RepositoryPermission {
  ADMIN = "ADMIN",
  READ = "READ",
  WRITE = "WRITE",
}

/** The privacy of a repository */
export enum RepositoryPrivacy {
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

/** A repository-topic connects a repository to a topic. */
export type RepositoryTopic = {
  __typename?: "RepositoryTopic";
  id: string;
  /** The HTTP path for this repository-topic. */
  resourcePath: URI;
  /** The topic. */
  topic: Topic;
  /** The HTTP URL for this repository-topic. */
  url: URI;
};

/** The connection type for RepositoryTopic. */
export type RepositoryTopicConnection = {
  __typename?: "RepositoryTopicConnection";
  /** A list of edges. */
  edges?: (RepositoryTopicEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (RepositoryTopic | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type RepositoryTopicEdge = {
  __typename?: "RepositoryTopicEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: RepositoryTopic;
};

/** Types that can be requested reviewers. */
export type RequestedReviewer = {
  __union: Team | User;
  __resolve: {
    ["...on Team"]: Team;
    ["...on User"]: User;
  };
};

/** Autogenerated input type of RequestReviews */
export type RequestReviewsInput = {
  /** The Node IDs of the team to request. */
  teamIds?: string[];
  /** Add users to the set rather than replace. */
  union?: boolean;
  /** The Node IDs of the user to request. */
  userIds?: string[];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The Node ID of the pull request to modify. */
  pullRequestId: string;
};

/** Autogenerated return type of RequestReviews */
export type RequestReviewsPayload = {
  __typename?: "RequestReviewsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The pull request that is getting requests.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequest` will change from `PullRequest!` to `PullRequest`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  pullRequest: PullRequest;
  /** 														The edge from the pull request to the requested reviewers.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `requestedReviewersEdge` will change from `UserEdge!` to `UserEdge`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  requestedReviewersEdge: UserEdge;
};

/** A team or user who has the ability to dismiss a review on a protected branch. */
export type ReviewDismissalAllowance = {
  __typename?: "ReviewDismissalAllowance";
  /** The actor that can dismiss. */
  actor?: ReviewDismissalAllowanceActor;
  id: string;
  /** Identifies the protected branch associated with the allowed user or team. */
  protectedBranch: ProtectedBranch;
};

/** Types that can be an actor. */
export type ReviewDismissalAllowanceActor = {
  __union: Team | User;
  __resolve: {
    ["...on Team"]: Team;
    ["...on User"]: User;
  };
};

/** The connection type for ReviewDismissalAllowance. */
export type ReviewDismissalAllowanceConnection = {
  __typename?: "ReviewDismissalAllowanceConnection";
  /** A list of edges. */
  edges?: (ReviewDismissalAllowanceEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (ReviewDismissalAllowance | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type ReviewDismissalAllowanceEdge = {
  __typename?: "ReviewDismissalAllowanceEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: ReviewDismissalAllowance;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type ReviewDismissedEvent = {
  __typename?: "ReviewDismissedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
  /** Identifies the message associated with the 'review_dismissed' event. */
  message: string;
  /** The message associated with the event, rendered to HTML. */
  messageHtml: HTML;
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  previousReviewState: PullRequestReviewState;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the commit which caused the review to become stale. */
  pullRequestCommit?: PullRequestCommit;
  /** The HTTP path for this review dismissed event. */
  resourcePath: URI;
  /** Identifies the review associated with the 'review_dismissed' event. */
  review?: PullRequestReview;
  /** The HTTP URL for this review dismissed event. */
  url: URI;
};

/** A request for a user to review a pull request. */
export type ReviewRequest = {
  __typename?: "ReviewRequest";
  /** Identifies the primary key from the database. */
  databaseId?: number;
  id: string;
  /** Identifies the pull request associated with this review request. */
  pullRequest: PullRequest;
  /** The reviewer that is requested. */
  requestedReviewer?: RequestedReviewer;
};

/** The connection type for ReviewRequest. */
export type ReviewRequestConnection = {
  __typename?: "ReviewRequestConnection";
  /** A list of edges. */
  edges?: (ReviewRequestEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (ReviewRequest | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents an 'review_requested' event on a given pull request. */
export type ReviewRequestedEvent = {
  __typename?: "ReviewRequestedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: RequestedReviewer;
};

/** An edge in a connection. */
export type ReviewRequestEdge = {
  __typename?: "ReviewRequestEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: ReviewRequest;
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type ReviewRequestRemovedEvent = {
  __typename?: "ReviewRequestRemovedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** PullRequest referenced by event. */
  pullRequest: PullRequest;
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: RequestedReviewer;
};

/** The results of a search. */
export type SearchResultItem = {
  __union:
    | Issue
    | MarketplaceListing
    | Organization
    | PullRequest
    | Repository
    | User;
  __resolve: {
    ["...on Issue"]: Issue;
    ["...on MarketplaceListing"]: MarketplaceListing;
    ["...on Organization"]: Organization;
    ["...on PullRequest"]: PullRequest;
    ["...on Repository"]: Repository;
    ["...on User"]: User;
  };
};

/** A list of results that matched against a search query. */
export type SearchResultItemConnection = {
  __typename?: "SearchResultItemConnection";
  /** The number of pieces of code that matched the search query. */
  codeCount: number;
  /** A list of edges. */
  edges?: (SearchResultItemEdge | undefined)[];
  /** The number of issues that matched the search query. */
  issueCount: number;
  /** A list of nodes. */
  nodes?: (SearchResultItem | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The number of repositories that matched the search query. */
  repositoryCount: number;
  /** The number of users that matched the search query. */
  userCount: number;
  /** The number of wiki pages that matched the search query. */
  wikiCount: number;
};

/** An edge in a connection. */
export type SearchResultItemEdge = {
  __typename?: "SearchResultItemEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: SearchResultItem;
  /** Text matches on the result found. */
  textMatches?: (TextMatch | undefined)[];
};

/** Represents the individual results of a search. */
export enum SearchType {
  ISSUE = "ISSUE",
  REPOSITORY = "REPOSITORY",
  USER = "USER",
}

/** Represents an S/MIME signature on a Commit or Tag. */
export type SmimeSignature = {
  __typename?: "SmimeSignature";
  /** Email used to sign this object. */
  email: string;
  /** True if the signature is valid and verified by GitHub. */
  isValid: boolean;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: string;
  /** ASCII-armored signature header from object. */
  signature: string;
  /** GitHub user corresponding to the email signing this commit. */
  signer?: User;
  /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: boolean;
};

/** The connection type for User. */
export type StargazerConnection = {
  __typename?: "StargazerConnection";
  /** A list of edges. */
  edges?: (StargazerEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (User | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a user that's starred a repository. */
export type StargazerEdge = {
  __typename?: "StargazerEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  node: User;
  /** Identifies when the item was starred. */
  starredAt: DateTime;
};

/** Ways in which star connections can be ordered. */
export type StarOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: StarOrderField;
};

/** Properties by which star connections can be ordered. */
export enum StarOrderField {
  STARRED_AT = "STARRED_AT",
}

/** Things that can be starred. */
export type Starrable = {
  __interface: {
    id: string;
    /** A list of users who have starred this starrable. */
    stargazers: StargazerConnection;
    /** Returns a boolean indicating whether the viewing user has starred this starrable. */
    viewerHasStarred: boolean;
  };
  __resolve: {
    ["...on Gist"]: Gist;
    ["...on Repository"]: Repository;
  };
};

/** The connection type for Repository. */
export type StarredRepositoryConnection = {
  __typename?: "StarredRepositoryConnection";
  /** A list of edges. */
  edges?: (StarredRepositoryEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Repository | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a starred repository. */
export type StarredRepositoryEdge = {
  __typename?: "StarredRepositoryEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  node: Repository;
  /** Identifies when the item was starred. */
  starredAt: DateTime;
};

/** Represents a commit status. */
export type Status = {
  __typename?: "Status";
  /** The commit this status is attached to. */
  commit?: Commit;
  /** Looks up an individual status context by context name. */
  context?: StatusContext;
  /** The individual status contexts for this commit. */
  contexts: StatusContext[];
  id: string;
  /** The combined commit status. */
  state: StatusState;
};

/** Represents an individual commit status context */
export type StatusContext = {
  __typename?: "StatusContext";
  /** This commit this status context is attached to. */
  commit?: Commit;
  /** The name of this status context. */
  context: string;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The actor who created this status context. */
  creator?: Actor;
  /** The description for this status context. */
  description?: string;
  id: string;
  /** The state of this status context. */
  state: StatusState;
  /** The URL for this status context. */
  targetUrl?: URI;
};

/** The possible commit status states. */
export enum StatusState {
  EXPECTED = "EXPECTED",
  FAILURE = "FAILURE",
  PENDING = "PENDING",
  SUCCESS = "SUCCESS",
  ERROR = "ERROR",
}

/** Autogenerated input type of SubmitPullRequestReview */
export type SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The event to send to the Pull Request Review. */
  event: PullRequestReviewEvent;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId: string;
};

/** Autogenerated return type of SubmitPullRequestReview */
export type SubmitPullRequestReviewPayload = {
  __typename?: "SubmitPullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The submitted pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  pullRequestReview: PullRequestReview;
};

/** Entities that can be subscribed to for web and email notifications. */
export type Subscribable = {
  __interface: {
    /** Check if the viewer is able to change their subscription status for the repository. */
    viewerCanSubscribe: boolean;
    /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
    viewerSubscription?: SubscriptionState;
    id: string;
  };
  __resolve: {
    ["...on Commit"]: Commit;
    ["...on Issue"]: Issue;
    ["...on PullRequest"]: PullRequest;
    ["...on Repository"]: Repository;
    ["...on Team"]: Team;
  };
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type SubscribedEvent = {
  __typename?: "SubscribedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Object referenced by event. */
  subscribable: Subscribable;
};

/** The possible states of a subscription. */
export enum SubscriptionState {
  IGNORED = "IGNORED",
  SUBSCRIBED = "SUBSCRIBED",
  UNSUBSCRIBED = "UNSUBSCRIBED",
}

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type SuggestedReviewer = {
  __typename?: "SuggestedReviewer";
  /** Is this suggestion based on past commits? */
  isAuthor: boolean;
  /** Is this suggestion based on past review comments? */
  isCommenter: boolean;
  /** Identifies the user suggested to review the pull request. */
  reviewer: User;
};

/** Represents a Git tag. */
export type Tag = {
  __typename?: "Tag";
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: string;
  /** The HTTP path for this Git object */
  commitResourcePath: URI;
  /** The HTTP URL for this Git object */
  commitUrl: URI;
  id: string;
  /** The Git tag message. */
  message?: string;
  /** The Git tag name. */
  name: string;
  /** The Git object ID */
  oid: GitObjectID;
  /** The Repository the Git object belongs to */
  repository: Repository;
  /** Details about the tag author. */
  tagger?: GitActor;
  /** The Git object the tag points to. */
  target: GitObject;
};

/** A team of users in an organization. */
export type Team = {
  __typename?: "Team";
  /** A list of teams that are ancestors of this team. */
  ancestors: TeamConnection;
  /** A URL pointing to the team's avatar. */
  avatarUrl?: URI;
  /** List of child teams belonging to this team */
  childTeams: TeamConnection;
  /** The slug corresponding to the organization and team. */
  combinedSlug: string;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** The description of the team. */
  description?: string;
  /** The HTTP path for editing this team */
  editTeamResourcePath: URI;
  /** The HTTP URL for editing this team */
  editTeamUrl: URI;
  id: string;
  /** A list of pending invitations for users to this team */
  invitations?: OrganizationInvitationConnection;
  /** A list of users who are members of this team. */
  members: TeamMemberConnection;
  /** The HTTP path for the team' members */
  membersResourcePath: URI;
  /** The HTTP URL for the team' members */
  membersUrl: URI;
  /** The name of the team. */
  name: string;
  /** The HTTP path creating a new team */
  newTeamResourcePath: URI;
  /** The HTTP URL creating a new team */
  newTeamUrl: URI;
  /** The organization that owns this team. */
  organization: Organization;
  /** The parent team of the team. */
  parentTeam?: Team;
  /** The level of privacy the team has. */
  privacy: TeamPrivacy;
  /** A list of repositories this team has access to. */
  repositories: TeamRepositoryConnection;
  /** The HTTP path for this team's repositories */
  repositoriesResourcePath: URI;
  /** The HTTP URL for this team's repositories */
  repositoriesUrl: URI;
  /** The HTTP path for this team */
  resourcePath: URI;
  /** The slug corresponding to the team. */
  slug: string;
  /** The HTTP path for this team's teams */
  teamsResourcePath: URI;
  /** The HTTP URL for this team's teams */
  teamsUrl: URI;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this team */
  url: URI;
  /** Team is adminable by the viewer. */
  viewerCanAdminister: boolean;
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: boolean;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: SubscriptionState;
};

/** The connection type for Team. */
export type TeamConnection = {
  __typename?: "TeamConnection";
  /** A list of edges. */
  edges?: (TeamEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Team | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type TeamEdge = {
  __typename?: "TeamEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: Team;
};

/** The connection type for User. */
export type TeamMemberConnection = {
  __typename?: "TeamMemberConnection";
  /** A list of edges. */
  edges?: (TeamMemberEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (User | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a user who is a member of a team. */
export type TeamMemberEdge = {
  __typename?: "TeamMemberEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: URI;
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: URI;
  node: User;
  /** The role the member has on the team. */
  role: TeamMemberRole;
};

/** Ordering options for team member connections */
export type TeamMemberOrder = {
  /** The field to order team members by. */
  field: TeamMemberOrderField;
  /** The ordering direction. */
  direction: OrderDirection;
};

/** Properties by which team member connections can be ordered. */
export enum TeamMemberOrderField {
  CREATED_AT = "CREATED_AT",
  LOGIN = "LOGIN",
}

/** The possible team member roles; either 'maintainer' or 'member'. */
export enum TeamMemberRole {
  MAINTAINER = "MAINTAINER",
  MEMBER = "MEMBER",
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum TeamMembershipType {
  ALL = "ALL",
  CHILD_TEAM = "CHILD_TEAM",
  IMMEDIATE = "IMMEDIATE",
}

/** Ways in which team connections can be ordered. */
export type TeamOrder = {
  /** The direction in which to order nodes. */
  direction: OrderDirection;
  /** The field in which to order nodes by. */
  field: TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export enum TeamOrderField {
  NAME = "NAME",
}

/** The possible team privacy values. */
export enum TeamPrivacy {
  SECRET = "SECRET",
  VISIBLE = "VISIBLE",
}

/** The connection type for Repository. */
export type TeamRepositoryConnection = {
  __typename?: "TeamRepositoryConnection";
  /** A list of edges. */
  edges?: (TeamRepositoryEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (Repository | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** Represents a team repository. */
export type TeamRepositoryEdge = {
  __typename?: "TeamRepositoryEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  node: Repository;
  /** The permission level the team has on the repository */
  permission: RepositoryPermission;
};

/** Ordering options for team repository connections */
export type TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: OrderDirection;
  /** The field to order repositories by. */
  field: TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export enum TeamRepositoryOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  PERMISSION = "PERMISSION",
  PUSHED_AT = "PUSHED_AT",
  STARGAZERS = "STARGAZERS",
  UPDATED_AT = "UPDATED_AT",
}

/** The role of a user on a team. */
export enum TeamRole {
  ADMIN = "ADMIN",
  MEMBER = "MEMBER",
}

/** A text match within a search result. */
export type TextMatch = {
  __typename?: "TextMatch";
  /** The specific text fragment within the property matched on. */
  fragment: string;
  /** Highlights within the matched fragment. */
  highlights: TextMatchHighlight[];
  /** The property matched on. */
  property: string;
};

/** Represents a single highlight in a search result match. */
export type TextMatchHighlight = {
  __typename?: "TextMatchHighlight";
  /** The indice in the fragment where the matched text begins. */
  beginIndice: number;
  /** The indice in the fragment where the matched text ends. */
  endIndice: number;
  /** The text matched. */
  text: string;
};

/** A topic aggregates entities that are related to a subject. */
export type Topic = {
  __typename?: "Topic";
  id: string;
  /** The topic's name. */
  name: string;
  /** 																A list of related topics, including aliases of this topic, sorted with the most relevant
first. */
  relatedTopics: Topic[];
};

/** Reason that the suggested topic is declined. */
export enum TopicSuggestionDeclineReason {
  NOT_RELEVANT = "NOT_RELEVANT",
  PERSONAL_PREFERENCE = "PERSONAL_PREFERENCE",
  TOO_GENERAL = "TOO_GENERAL",
  TOO_SPECIFIC = "TOO_SPECIFIC",
}

/** Represents a Git tree. */
export type Tree = {
  __typename?: "Tree";
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: string;
  /** The HTTP path for this Git object */
  commitResourcePath: URI;
  /** The HTTP URL for this Git object */
  commitUrl: URI;
  /** A list of tree entries. */
  entries?: TreeEntry[];
  id: string;
  /** The Git object ID */
  oid: GitObjectID;
  /** The Repository the Git object belongs to */
  repository: Repository;
};

/** Represents a Git tree entry. */
export type TreeEntry = {
  __typename?: "TreeEntry";
  /** Entry file mode. */
  mode: number;
  /** Entry file name. */
  name: string;
  /** Entry file object. */
  object?: GitObject;
  /** Entry file Git object ID. */
  oid: GitObjectID;
  /** The Repository the tree entry belongs to */
  repository: Repository;
  /** Entry file type. */
  type: string;
};

/** Represents an 'unassigned' event on any assignable object. */
export type UnassignedEvent = {
  __typename?: "UnassignedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the assignable associated with the event. */
  assignable: Assignable;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Identifies the subject (user) who was unassigned. */
  user?: User;
};

/** Represents a type that can be retrieved by a URL. */
export type UniformResourceLocatable = {
  __interface: {
    /** The HTML path to this resource. */
    resourcePath: URI;
    /** The URL to this resource. */
    url: URI;
  };
  __resolve: {
    ["...on Bot"]: Bot;
    ["...on ClosedEvent"]: ClosedEvent;
    ["...on CrossReferencedEvent"]: CrossReferencedEvent;
    ["...on Issue"]: Issue;
    ["...on MergedEvent"]: MergedEvent;
    ["...on Milestone"]: Milestone;
    ["...on Organization"]: Organization;
    ["...on PullRequest"]: PullRequest;
    ["...on PullRequestCommit"]: PullRequestCommit;
    ["...on Release"]: Release;
    ["...on Repository"]: Repository;
    ["...on RepositoryTopic"]: RepositoryTopic;
    ["...on ReviewDismissedEvent"]: ReviewDismissedEvent;
    ["...on User"]: User;
  };
};

/** Represents an unknown signature on a Commit or Tag. */
export type UnknownSignature = {
  __typename?: "UnknownSignature";
  /** Email used to sign this object. */
  email: string;
  /** True if the signature is valid and verified by GitHub. */
  isValid: boolean;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: string;
  /** ASCII-armored signature header from object. */
  signature: string;
  /** GitHub user corresponding to the email signing this commit. */
  signer?: User;
  /** 																The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid. */
  state: GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: boolean;
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type UnlabeledEvent = {
  __typename?: "UnlabeledEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Identifies the label associated with the 'unlabeled' event. */
  label: Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Labelable;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type UnlockedEvent = {
  __typename?: "UnlockedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Object that was unlocked. */
  lockable: Lockable;
};

/** Autogenerated input type of UnlockLockable */
export type UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** ID of the issue or pull request to be unlocked. */
  lockableId: string;
};

/** Autogenerated return type of UnlockLockable */
export type UnlockLockablePayload = {
  __typename?: "UnlockLockablePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The item that was unlocked. */
  unlockedRecord?: Lockable;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type UnsubscribedEvent = {
  __typename?: "UnsubscribedEvent";
  /** Identifies the actor who performed the event. */
  actor?: Actor;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  id: string;
  /** Object referenced by event. */
  subscribable: Subscribable;
};

/** Entities that can be updated. */
export type Updatable = {
  __interface: {
    /** Check if the current viewer can update this object. */
    viewerCanUpdate: boolean;
  };
  __resolve: {
    ["...on CommitComment"]: CommitComment;
    ["...on GistComment"]: GistComment;
    ["...on Issue"]: Issue;
    ["...on IssueComment"]: IssueComment;
    ["...on Project"]: Project;
    ["...on PullRequest"]: PullRequest;
    ["...on PullRequestReview"]: PullRequestReview;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
  };
};

/** Comments that can be updated. */
export type UpdatableComment = {
  __interface: {
    /** Reasons why the current viewer can not update this comment. */
    viewerCannotUpdateReasons: CommentCannotUpdateReason[];
  };
  __resolve: {
    ["...on CommitComment"]: CommitComment;
    ["...on GistComment"]: GistComment;
    ["...on Issue"]: Issue;
    ["...on IssueComment"]: IssueComment;
    ["...on PullRequest"]: PullRequest;
    ["...on PullRequestReview"]: PullRequestReview;
    ["...on PullRequestReviewComment"]: PullRequestReviewComment;
  };
};

/** Autogenerated input type of UpdateProjectCard */
export type UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: boolean;
  /** The note of ProjectCard. */
  note?: string;
  /** The ProjectCard ID to update. */
  projectCardId: string;
};

/** Autogenerated return type of UpdateProjectCard */
export type UpdateProjectCardPayload = {
  __typename?: "UpdateProjectCardPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The updated ProjectCard.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectCard` will change from `ProjectCard!` to `ProjectCard`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  projectCard: ProjectCard;
};

/** Autogenerated input type of UpdateProjectColumn */
export type UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of project column. */
  name: string;
  /** The ProjectColumn ID to update. */
  projectColumnId: string;
};

/** Autogenerated return type of UpdateProjectColumn */
export type UpdateProjectColumnPayload = {
  __typename?: "UpdateProjectColumnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The updated project column.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `projectColumn` will change from `ProjectColumn!` to `ProjectColumn`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  projectColumn: ProjectColumn;
};

/** Autogenerated input type of UpdateProject */
export type UpdateProjectInput = {
  /** The description of project. */
  body?: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The name of project. */
  name?: string;
  /** The Project ID to update. */
  projectId: string;
  /** Whether the project is public or not. */
  public?: boolean;
  /** Whether the project is open or closed. */
  state?: ProjectState;
};

/** Autogenerated return type of UpdateProject */
export type UpdateProjectPayload = {
  __typename?: "UpdateProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The updated project.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `project` will change from `Project!` to `Project`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  project: Project;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: string;
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
export type UpdatePullRequestReviewCommentPayload = {
  __typename?: "UpdatePullRequestReviewCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The updated comment.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReviewComment` will change from
  `PullRequestReviewComment!` to `PullRequestReviewComment`.
  **Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  pullRequestReviewComment: PullRequestReviewComment;
};

/** Autogenerated input type of UpdatePullRequestReview */
export type UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: string;
};

/** Autogenerated return type of UpdatePullRequestReview */
export type UpdatePullRequestReviewPayload = {
  __typename?: "UpdatePullRequestReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The updated pull request review.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `pullRequestReview` will change from `PullRequestReview!` to `PullRequestReview`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  pullRequestReview: PullRequestReview;
};

/** Autogenerated input type of UpdateSubscription */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** The new state of the subscription. */
  state: SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: string;
};

/** Autogenerated return type of UpdateSubscription */
export type UpdateSubscriptionPayload = {
  __typename?: "UpdateSubscriptionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** 														The input subscribable entity.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `subscribable` will change from `Subscribable!` to `Subscribable`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  subscribable: Subscribable;
};

/** Autogenerated input type of UpdateTopics */
export type UpdateTopicsInput = {
  /** The Node ID of the repository. */
  repositoryId: string;
  /** An array of topic names. */
  topicNames: string[];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
};

/** Autogenerated return type of UpdateTopics */
export type UpdateTopicsPayload = {
  __typename?: "UpdateTopicsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: string;
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: string[];
  /** 														The updated repository.
**Upcoming Change on 2019-01-01 UTC**
**Description:** Type for `repository` will change from `Repository!` to `Repository`.
**Reason:** In preparation for an upcoming change to the way we report
mutation errors, non-nullable payload fields are becoming nullable. */
  repository: Repository;
};

/** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
export type URI = any;

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type User = {
  __typename?: "User";
  /** A URL pointing to the user's public avatar. */
  avatarUrl: URI;
  /** The user's public profile bio. */
  bio?: string;
  /** The user's public profile bio as HTML. */
  bioHTML: HTML;
  /** A list of commit comments made by this user. */
  commitComments: CommitCommentConnection;
  /** The user's public profile company. */
  company?: string;
  /** The user's public profile company as HTML. */
  companyHTML: HTML;
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the primary key from the database. */
  databaseId?: number;
  /** The user's publicly visible profile email. */
  email: string;
  /** A list of users the given user is followed by. */
  followers: FollowerConnection;
  /** A list of users the given user is following. */
  following: FollowingConnection;
  /** Find gist by repo name. */
  gist?: Gist;
  /** A list of gist comments made by this user. */
  gistComments: GistCommentConnection;
  /** A list of the Gists the user has created. */
  gists: GistConnection;
  id: string;
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  isBountyHunter: boolean;
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  isCampusExpert: boolean;
  /** Whether or not this user is a GitHub Developer Program member. */
  isDeveloperProgramMember: boolean;
  /** Whether or not this user is a GitHub employee. */
  isEmployee: boolean;
  /** Whether or not the user has marked themselves as for hire. */
  isHireable: boolean;
  /** Whether or not this user is a site administrator. */
  isSiteAdmin: boolean;
  /** Whether or not this user is the viewing user. */
  isViewer: boolean;
  /** A list of issue comments made by this user. */
  issueComments: IssueCommentConnection;
  /** A list of issues associated with this user. */
  issues: IssueConnection;
  /** The user's public profile location. */
  location?: string;
  /** The username used to login. */
  login: string;
  /** The user's public profile name. */
  name?: string;
  /** Find an organization by its login that the user belongs to. */
  organization?: Organization;
  /** A list of organizations the user belongs to. */
  organizations: OrganizationConnection;
  /** A list of repositories this user has pinned to their profile */
  pinnedRepositories: RepositoryConnection;
  /** A list of public keys associated with this user. */
  publicKeys: PublicKeyConnection;
  /** A list of pull requests associated with this user. */
  pullRequests: PullRequestConnection;
  /** A list of repositories that the user owns. */
  repositories: RepositoryConnection;
  /** A list of repositories that the user recently contributed to. */
  repositoriesContributedTo: RepositoryConnection;
  /** Find Repository. */
  repository?: Repository;
  /** The HTTP path for this user */
  resourcePath: URI;
  /** Repositories the user has starred. */
  starredRepositories: StarredRepositoryConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
  /** The HTTP URL for this user */
  url: URI;
  /** Whether or not the viewer is able to follow the user. */
  viewerCanFollow: boolean;
  /** Whether or not this user is followed by the viewer. */
  viewerIsFollowing: boolean;
  /** A list of repositories the given user is watching. */
  watching: RepositoryConnection;
  /** A URL pointing to the user's public website/blog. */
  websiteUrl?: URI;
};

/** The connection type for User. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: (UserEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (User | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edit on user content */
export type UserContentEdit = {
  __typename?: "UserContentEdit";
  /** Identifies the date and time when the object was created. */
  createdAt: DateTime;
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: DateTime;
  /** The actor who deleted this content */
  deletedBy?: Actor;
  /** A summary of the changes for this edit */
  diff?: string;
  /** When this content was edited */
  editedAt: DateTime;
  /** The actor who edited this content */
  editor?: Actor;
  id: string;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: DateTime;
};

/** A list of edits to content. */
export type UserContentEditConnection = {
  __typename?: "UserContentEditConnection";
  /** A list of edges. */
  edges?: (UserContentEditEdge | undefined)[];
  /** A list of nodes. */
  nodes?: (UserContentEdit | undefined)[];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: number;
};

/** An edge in a connection. */
export type UserContentEditEdge = {
  __typename?: "UserContentEditEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: UserContentEdit;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: string;
  /** The item at the end of the edge. */
  node?: User;
};

/** A valid x509 certificate string */
export type X509Certificate = any;

export const AllTypesProps: Record<string, any> = {
  AcceptTopicSuggestionInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    name: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    repositoryId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  Actor: {
    avatarUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  AddCommentInput: {
    subjectId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  AddProjectCardInput: {
    contentId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: false,
    },
    note: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    projectColumnId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  AddProjectColumnInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    name: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    projectId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  AddPullRequestReviewCommentInput: {
    inReplyTo: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: false,
    },
    path: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    position: {
      type: "Int",
      array: false,
      arrayRequired: false,
      required: false,
    },
    pullRequestReviewId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    commitOID: {
      type: "GitObjectID",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  AddPullRequestReviewInput: {
    pullRequestId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    comments: {
      type: "DraftPullRequestReviewComment",
      array: true,
      arrayRequired: false,
      required: false,
    },
    commitOID: {
      type: "GitObjectID",
      array: false,
      arrayRequired: false,
      required: false,
    },
    event: {
      type: "PullRequestReviewEvent",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  AddReactionInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    content: {
      type: "ReactionContent",
      array: false,
      arrayRequired: false,
      required: true,
    },
    subjectId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  AddStarInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    starrableId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  App: {
    logoUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  Assignable: {
    assignees: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  Bot: {
    avatarUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  CollaboratorAffiliation: "enum",
  Comment: {
    userContentEdits: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  CommentAuthorAssociation: "enum",
  CommentCannotUpdateReason: "enum",
  Commit: {
    blame: {
      path: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    comments: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    history: {
      author: {
        type: "CommitAuthor",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      path: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      since: {
        type: "GitTimestamp",
        array: false,
        arrayRequired: false,
        required: false,
      },
      until: {
        type: "GitTimestamp",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    parents: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  CommitAuthor: {
    emails: {
      type: "String",
      array: true,
      arrayRequired: false,
      required: true,
    },
    id: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  CommitComment: {
    reactions: {
      orderBy: {
        type: "ReactionOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      content: {
        type: "ReactionContent",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    userContentEdits: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  CommitCommentThread: {
    comments: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  CreateProjectInput: {
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    name: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    ownerId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  DateTime: "String",
  DeclineTopicSuggestionInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    name: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    reason: {
      type: "TopicSuggestionDeclineReason",
      array: false,
      arrayRequired: false,
      required: true,
    },
    repositoryId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  DeleteProjectCardInput: {
    cardId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  DeleteProjectColumnInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    columnId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  DeleteProjectInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    projectId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  DeletePullRequestReviewInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    pullRequestReviewId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  Deployment: {
    statuses: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  DeploymentState: "enum",
  DeploymentStatusState: "enum",
  DismissPullRequestReviewInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    message: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    pullRequestReviewId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  DraftPullRequestReviewComment: {
    path: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    position: {
      type: "Int",
      array: false,
      arrayRequired: false,
      required: true,
    },
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  Gist: {
    comments: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    stargazers: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "StarOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  GistComment: {
    userContentEdits: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  GistOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "GistOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  GistOrderField: "enum",
  GistPrivacy: "enum",
  GitActor: {
    avatarUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  GitObjectID: "String",
  GitSignatureState: "enum",
  GitSSHRemote: "String",
  GitTimestamp: "String",
  HTML: "String",
  Issue: {
    assignees: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    comments: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    labels: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    participants: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    projectCards: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      archivedStates: {
        type: "ProjectCardArchivedState",
        array: true,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    reactions: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      content: {
        type: "ReactionContent",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "ReactionOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    timeline: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      since: {
        type: "DateTime",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    userContentEdits: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  IssueComment: {
    reactions: {
      orderBy: {
        type: "ReactionOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      content: {
        type: "ReactionContent",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    userContentEdits: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  IssueOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "IssueOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  IssueOrderField: "enum",
  IssueState: "enum",
  Label: {
    issues: {
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "IssueState",
        array: true,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    pullRequests: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      baseRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      headRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "PullRequestState",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
  },
  Labelable: {
    labels: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  LanguageOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "LanguageOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  LanguageOrderField: "enum",
  LockLockableInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    lockReason: {
      type: "LockReason",
      array: false,
      arrayRequired: false,
      required: false,
    },
    lockableId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  LockReason: "enum",
  MarketplaceListing: {
    logoUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  MergeableState: "enum",
  Milestone: {
    issues: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "IssueState",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
    pullRequests: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      baseRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      headRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "PullRequestState",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
  },
  MilestoneOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "MilestoneOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  MilestoneOrderField: "enum",
  MilestoneState: "enum",
  MoveProjectCardInput: {
    afterCardId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: false,
    },
    cardId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    columnId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  MoveProjectColumnInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    columnId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    afterColumnId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  Mutation: {
    acceptTopicSuggestion: {
      input: {
        type: "AcceptTopicSuggestionInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    addComment: {
      input: {
        type: "AddCommentInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    addProjectCard: {
      input: {
        type: "AddProjectCardInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    addProjectColumn: {
      input: {
        type: "AddProjectColumnInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    addPullRequestReview: {
      input: {
        type: "AddPullRequestReviewInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    addPullRequestReviewComment: {
      input: {
        type: "AddPullRequestReviewCommentInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    addReaction: {
      input: {
        type: "AddReactionInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    addStar: {
      input: {
        type: "AddStarInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    createProject: {
      input: {
        type: "CreateProjectInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    declineTopicSuggestion: {
      input: {
        type: "DeclineTopicSuggestionInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    deleteProject: {
      input: {
        type: "DeleteProjectInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    deleteProjectCard: {
      input: {
        type: "DeleteProjectCardInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    deleteProjectColumn: {
      input: {
        type: "DeleteProjectColumnInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    deletePullRequestReview: {
      input: {
        type: "DeletePullRequestReviewInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    dismissPullRequestReview: {
      input: {
        type: "DismissPullRequestReviewInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    lockLockable: {
      input: {
        type: "LockLockableInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    moveProjectCard: {
      input: {
        type: "MoveProjectCardInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    moveProjectColumn: {
      input: {
        type: "MoveProjectColumnInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    removeOutsideCollaborator: {
      input: {
        type: "RemoveOutsideCollaboratorInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    removeReaction: {
      input: {
        type: "RemoveReactionInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    removeStar: {
      input: {
        type: "RemoveStarInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    requestReviews: {
      input: {
        type: "RequestReviewsInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    submitPullRequestReview: {
      input: {
        type: "SubmitPullRequestReviewInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    unlockLockable: {
      input: {
        type: "UnlockLockableInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    updateProject: {
      input: {
        type: "UpdateProjectInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    updateProjectCard: {
      input: {
        type: "UpdateProjectCardInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    updateProjectColumn: {
      input: {
        type: "UpdateProjectColumnInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    updatePullRequestReview: {
      input: {
        type: "UpdatePullRequestReviewInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    updatePullRequestReviewComment: {
      input: {
        type: "UpdatePullRequestReviewCommentInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    updateSubscription: {
      input: {
        type: "UpdateSubscriptionInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    updateTopics: {
      input: {
        type: "UpdateTopicsInput",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
  },
  OrderDirection: "enum",
  Organization: {
    avatarUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    members: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    pinnedRepositories: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    project: {
      number: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    projects: {
      search: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "ProjectState",
        array: true,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "ProjectOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repositories: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isFork: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repository: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    team: {
      slug: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    teams: {
      ldapMapped: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "TeamOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "TeamPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      role: {
        type: "TeamRole",
        array: false,
        arrayRequired: false,
        required: false,
      },
      userLogins: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      query: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      rootTeamsOnly: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  OrganizationIdentityProvider: {
    externalIdentities: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  OrganizationInvitationRole: "enum",
  OrganizationInvitationType: "enum",
  Project: {
    columns: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    pendingCards: {
      archivedStates: {
        type: "ProjectCardArchivedState",
        array: true,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  ProjectCardArchivedState: "enum",
  ProjectCardState: "enum",
  ProjectColumn: {
    cards: {
      archivedStates: {
        type: "ProjectCardArchivedState",
        array: true,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  ProjectColumnPurpose: "enum",
  ProjectOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "ProjectOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  ProjectOrderField: "enum",
  ProjectOwner: {
    projects: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "ProjectOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      search: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "ProjectState",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
    project: {
      number: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
  },
  ProjectState: "enum",
  ProtectedBranch: {
    pushAllowances: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    reviewDismissalAllowances: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  PullRequest: {
    assignees: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    comments: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    commits: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    labels: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    participants: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    projectCards: {
      archivedStates: {
        type: "ProjectCardArchivedState",
        array: true,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    reactions: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "ReactionOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      content: {
        type: "ReactionContent",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    reviewRequests: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    reviews: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      author: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "PullRequestReviewState",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
    timeline: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      since: {
        type: "DateTime",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    userContentEdits: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  PullRequestReview: {
    comments: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    userContentEdits: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  PullRequestReviewComment: {
    reactions: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      content: {
        type: "ReactionContent",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "ReactionOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    userContentEdits: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  PullRequestReviewEvent: "enum",
  PullRequestReviewState: "enum",
  PullRequestReviewThread: {
    comments: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  PullRequestState: "enum",
  Query: {
    codeOfConduct: {
      key: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    license: {
      key: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    marketplaceCategories: {
      excludeEmpty: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      excludeSubcategories: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      includeCategories: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
    marketplaceCategory: {
      slug: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
      useTopicAliases: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    marketplaceListing: {
      slug: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    marketplaceListings: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      categorySlug: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      organizationId: {
        type: "ID",
        array: false,
        arrayRequired: false,
        required: false,
      },
      primaryCategoryOnly: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      adminId: {
        type: "ID",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      withFreeTrialsOnly: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      slugs: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: false,
      },
      useTopicAliases: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      allStates: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      viewerCanAdmin: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    node: {
      id: {
        type: "ID",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    nodes: {
      ids: {
        type: "ID",
        array: true,
        arrayRequired: true,
        required: true,
      },
    },
    organization: {
      login: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    rateLimit: {
      dryRun: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repository: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
      owner: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    repositoryOwner: {
      login: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    resource: {
      url: {
        type: "URI",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    search: {
      query: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
      type: {
        type: "SearchType",
        array: false,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    topic: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    user: {
      login: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
  },
  Reactable: {
    reactions: {
      orderBy: {
        type: "ReactionOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      content: {
        type: "ReactionContent",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  ReactionContent: "enum",
  ReactionGroup: {
    users: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  ReactionOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "ReactionOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  ReactionOrderField: "enum",
  Ref: {
    associatedPullRequests: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      headRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      baseRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "PullRequestState",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
  },
  RefOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "RefOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  RefOrderField: "enum",
  Release: {
    releaseAssets: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  ReleaseOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "ReleaseOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  ReleaseOrderField: "enum",
  RemoveOutsideCollaboratorInput: {
    userId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    organizationId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  RemoveReactionInput: {
    subjectId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    content: {
      type: "ReactionContent",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  RemoveStarInput: {
    starrableId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  Repository: {
    assignableUsers: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    collaborators: {
      affiliation: {
        type: "CollaboratorAffiliation",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    commitComments: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    deployKeys: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    deployments: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      environments: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    forks: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    issue: {
      number: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    issueOrPullRequest: {
      number: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    issues: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "IssueState",
        array: true,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    label: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    labels: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      query: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    languages: {
      orderBy: {
        type: "LanguageOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    mentionableUsers: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    milestone: {
      number: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    milestones: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "MilestoneOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "MilestoneState",
        array: true,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    object: {
      expression: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      oid: {
        type: "GitObjectID",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    project: {
      number: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    projects: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "ProjectOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      search: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "ProjectState",
        array: true,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    protectedBranches: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    pullRequest: {
      number: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    pullRequests: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      baseRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      headRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "PullRequestState",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
    ref: {
      qualifiedName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    refs: {
      direction: {
        type: "OrderDirection",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RefOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      refPrefix: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    release: {
      tagName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    releases: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "ReleaseOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repositoryTopics: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    shortDescriptionHTML: {
      limit: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    stargazers: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "StarOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    watchers: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  RepositoryAffiliation: "enum",
  RepositoryContributionType: "enum",
  RepositoryInfo: {
    shortDescriptionHTML: {
      limit: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  RepositoryLockReason: "enum",
  RepositoryOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "RepositoryOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  RepositoryOrderField: "enum",
  RepositoryOwner: {
    pinnedRepositories: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repositories: {
      isFork: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repository: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    avatarUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  RepositoryPermission: "enum",
  RepositoryPrivacy: "enum",
  RequestReviewsInput: {
    teamIds: {
      type: "ID",
      array: true,
      arrayRequired: false,
      required: true,
    },
    union: {
      type: "Boolean",
      array: false,
      arrayRequired: false,
      required: false,
    },
    userIds: {
      type: "ID",
      array: true,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    pullRequestId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  SearchType: "enum",
  StarOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "StarOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  StarOrderField: "enum",
  Starrable: {
    stargazers: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "StarOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  Status: {
    context: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
  },
  StatusState: "enum",
  SubmitPullRequestReviewInput: {
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    event: {
      type: "PullRequestReviewEvent",
      array: false,
      arrayRequired: false,
      required: true,
    },
    pullRequestReviewId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  SubscriptionState: "enum",
  Team: {
    ancestors: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    avatarUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    childTeams: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      immediateOnly: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "TeamOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      userLogins: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
    },
    invitations: {
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    members: {
      membership: {
        type: "TeamMembershipType",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "TeamMemberOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      query: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      role: {
        type: "TeamMemberRole",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repositories: {
      orderBy: {
        type: "TeamRepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      query: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  TeamMemberOrder: {
    field: {
      type: "TeamMemberOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  TeamMemberOrderField: "enum",
  TeamMemberRole: "enum",
  TeamMembershipType: "enum",
  TeamOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "TeamOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  TeamOrderField: "enum",
  TeamPrivacy: "enum",
  TeamRepositoryOrder: {
    direction: {
      type: "OrderDirection",
      array: false,
      arrayRequired: false,
      required: true,
    },
    field: {
      type: "TeamRepositoryOrderField",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  TeamRepositoryOrderField: "enum",
  TeamRole: "enum",
  TopicSuggestionDeclineReason: "enum",
  UnlockLockableInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    lockableId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  UpdateProjectCardInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    isArchived: {
      type: "Boolean",
      array: false,
      arrayRequired: false,
      required: false,
    },
    note: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    projectCardId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  UpdateProjectColumnInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    name: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    projectColumnId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  UpdateProjectInput: {
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    name: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    projectId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    public: {
      type: "Boolean",
      array: false,
      arrayRequired: false,
      required: false,
    },
    state: {
      type: "ProjectState",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  UpdatePullRequestReviewCommentInput: {
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    pullRequestReviewCommentId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  UpdatePullRequestReviewInput: {
    body: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    pullRequestReviewId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  UpdateSubscriptionInput: {
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
    state: {
      type: "SubscriptionState",
      array: false,
      arrayRequired: false,
      required: true,
    },
    subscribableId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
  },
  UpdateTopicsInput: {
    repositoryId: {
      type: "ID",
      array: false,
      arrayRequired: false,
      required: true,
    },
    topicNames: {
      type: "String",
      array: true,
      arrayRequired: true,
      required: true,
    },
    clientMutationId: {
      type: "String",
      array: false,
      arrayRequired: false,
      required: false,
    },
  },
  URI: "String",
  User: {
    avatarUrl: {
      size: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    commitComments: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    followers: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    following: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    gist: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    gistComments: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    gists: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "GistOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "GistPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    issueComments: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    issues: {
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "IssueState",
        array: true,
        arrayRequired: false,
        required: true,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    organization: {
      login: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    organizations: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    pinnedRepositories: {
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    publicKeys: {
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    pullRequests: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      headRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      labels: {
        type: "String",
        array: true,
        arrayRequired: false,
        required: true,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      states: {
        type: "PullRequestState",
        array: true,
        arrayRequired: false,
        required: true,
      },
      baseRefName: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "IssueOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repositories: {
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isFork: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repositoriesContributedTo: {
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      contributionTypes: {
        type: "RepositoryContributionType",
        array: true,
        arrayRequired: false,
        required: false,
      },
      includeUserRepositories: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    repository: {
      name: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: true,
      },
    },
    starredRepositories: {
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "StarOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      ownedByViewer: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
    watching: {
      affiliations: {
        type: "RepositoryAffiliation",
        array: true,
        arrayRequired: false,
        required: false,
      },
      after: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      before: {
        type: "String",
        array: false,
        arrayRequired: false,
        required: false,
      },
      first: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      isLocked: {
        type: "Boolean",
        array: false,
        arrayRequired: false,
        required: false,
      },
      last: {
        type: "Int",
        array: false,
        arrayRequired: false,
        required: false,
      },
      orderBy: {
        type: "RepositoryOrder",
        array: false,
        arrayRequired: false,
        required: false,
      },
      privacy: {
        type: "RepositoryPrivacy",
        array: false,
        arrayRequired: false,
        required: false,
      },
    },
  },
  X509Certificate: "String",
};

export const ReturnTypes: Record<string, any> = {
  AcceptTopicSuggestionPayload: {
    clientMutationId: "String",
    topic: "Topic",
  },
  Actor: {
    "...on Bot": "Bot",
    "...on Organization": "Organization",
    "...on User": "User",
    login: "String",
    resourcePath: "URI",
    url: "URI",
    avatarUrl: "URI",
  },
  AddCommentPayload: {
    clientMutationId: "String",
    commentEdge: "IssueCommentEdge",
    subject: "Node",
    timelineEdge: "IssueTimelineItemEdge",
  },
  AddedToProjectEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
  },
  AddProjectCardPayload: {
    cardEdge: "ProjectCardEdge",
    clientMutationId: "String",
    projectColumn: "Project",
  },
  AddProjectColumnPayload: {
    clientMutationId: "String",
    columnEdge: "ProjectColumnEdge",
    project: "Project",
  },
  AddPullRequestReviewCommentPayload: {
    clientMutationId: "String",
    comment: "PullRequestReviewComment",
    commentEdge: "PullRequestReviewCommentEdge",
  },
  AddPullRequestReviewPayload: {
    clientMutationId: "String",
    pullRequestReview: "PullRequestReview",
    reviewEdge: "PullRequestReviewEdge",
  },
  AddReactionPayload: {
    clientMutationId: "String",
    reaction: "Reaction",
    subject: "Reactable",
  },
  AddStarPayload: {
    clientMutationId: "String",
    starrable: "Starrable",
  },
  App: {
    createdAt: "DateTime",
    databaseId: "Int",
    description: "String",
    id: "ID",
    logoBackgroundColor: "String",
    logoUrl: "URI",
    name: "String",
    slug: "String",
    updatedAt: "DateTime",
    url: "URI",
  },
  Assignable: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
    assignees: "UserConnection",
  },
  AssignedEvent: {
    actor: "Actor",
    assignable: "Assignable",
    createdAt: "DateTime",
    id: "ID",
    user: "User",
  },
  BaseRefChangedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
  },
  BaseRefForcePushedEvent: {
    actor: "Actor",
    afterCommit: "Commit",
    beforeCommit: "Commit",
    createdAt: "DateTime",
    id: "ID",
    pullRequest: "PullRequest",
    ref: "Ref",
  },
  Blame: {
    ranges: "BlameRange",
  },
  BlameRange: {
    age: "Int",
    commit: "Commit",
    endingLine: "Int",
    startingLine: "Int",
  },
  Blob: {
    abbreviatedOid: "String",
    byteSize: "Int",
    commitResourcePath: "URI",
    commitUrl: "URI",
    id: "ID",
    isBinary: "Boolean",
    isTruncated: "Boolean",
    oid: "GitObjectID",
    repository: "Repository",
    text: "String",
  },
  Bot: {
    avatarUrl: "URI",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
    login: "String",
    resourcePath: "URI",
    updatedAt: "DateTime",
    url: "URI",
  },
  Closable: {
    "...on Issue": "Issue",
    "...on Milestone": "Milestone",
    "...on Project": "Project",
    "...on PullRequest": "PullRequest",
    closedAt: "DateTime",
    closed: "Boolean",
  },
  ClosedEvent: {
    actor: "Actor",
    closable: "Closable",
    closer: "Closer",
    createdAt: "DateTime",
    id: "ID",
    resourcePath: "URI",
    url: "URI",
  },
  Closer: {
    "...on Commit": "Commit",
    "...on PullRequest": "PullRequest",
  },
  CodeOfConduct: {
    body: "String",
    key: "String",
    name: "String",
    url: "URI",
  },
  Comment: {
    "...on CommitComment": "CommitComment",
    "...on GistComment": "GistComment",
    "...on Issue": "Issue",
    "...on IssueComment": "IssueComment",
    "...on PullRequest": "PullRequest",
    "...on PullRequestReview": "PullRequestReview",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    createdAt: "DateTime",
    viewerDidAuthor: "Boolean",
    author: "Actor",
    lastEditedAt: "DateTime",
    updatedAt: "DateTime",
    bodyHTML: "HTML",
    publishedAt: "DateTime",
    body: "String",
    id: "ID",
    bodyText: "String",
    editor: "Actor",
    createdViaEmail: "Boolean",
    userContentEdits: "UserContentEditConnection",
    includesCreatedEdit: "Boolean",
    authorAssociation: "CommentAuthorAssociation",
  },
  CommentDeletedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
  },
  Commit: {
    abbreviatedOid: "String",
    additions: "Int",
    author: "GitActor",
    authoredByCommitter: "Boolean",
    authoredDate: "DateTime",
    blame: "Blame",
    changedFiles: "Int",
    comments: "CommitCommentConnection",
    commitResourcePath: "URI",
    commitUrl: "URI",
    committedDate: "DateTime",
    committedViaWeb: "Boolean",
    committer: "GitActor",
    deletions: "Int",
    history: "CommitHistoryConnection",
    id: "ID",
    message: "String",
    messageBody: "String",
    messageBodyHTML: "HTML",
    messageHeadline: "String",
    messageHeadlineHTML: "HTML",
    oid: "GitObjectID",
    parents: "CommitConnection",
    pushedDate: "DateTime",
    repository: "Repository",
    resourcePath: "URI",
    signature: "GitSignature",
    status: "Status",
    tarballUrl: "URI",
    tree: "Tree",
    treeResourcePath: "URI",
    treeUrl: "URI",
    url: "URI",
    viewerCanSubscribe: "Boolean",
    viewerSubscription: "SubscriptionState",
    zipballUrl: "URI",
  },
  CommitComment: {
    author: "Actor",
    authorAssociation: "CommentAuthorAssociation",
    body: "String",
    bodyHTML: "HTML",
    bodyText: "String",
    commit: "Commit",
    createdAt: "DateTime",
    createdViaEmail: "Boolean",
    databaseId: "Int",
    editor: "Actor",
    id: "ID",
    includesCreatedEdit: "Boolean",
    lastEditedAt: "DateTime",
    path: "String",
    position: "Int",
    publishedAt: "DateTime",
    reactionGroups: "ReactionGroup",
    reactions: "ReactionConnection",
    repository: "Repository",
    resourcePath: "URI",
    updatedAt: "DateTime",
    url: "URI",
    userContentEdits: "UserContentEditConnection",
    viewerCanDelete: "Boolean",
    viewerCanReact: "Boolean",
    viewerCanUpdate: "Boolean",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
    viewerDidAuthor: "Boolean",
  },
  CommitCommentConnection: {
    edges: "CommitCommentEdge",
    nodes: "CommitComment",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  CommitCommentEdge: {
    cursor: "String",
    node: "CommitComment",
  },
  CommitCommentThread: {
    comments: "CommitCommentConnection",
    commit: "Commit",
    id: "ID",
    path: "String",
    position: "Int",
    repository: "Repository",
  },
  CommitConnection: {
    edges: "CommitEdge",
    nodes: "Commit",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  CommitEdge: {
    cursor: "String",
    node: "Commit",
  },
  CommitHistoryConnection: {
    edges: "CommitEdge",
    nodes: "Commit",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ConvertedNoteToIssueEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
  },
  CreateProjectPayload: {
    clientMutationId: "String",
    project: "Project",
  },
  CrossReferencedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    isCrossRepository: "Boolean",
    referencedAt: "DateTime",
    resourcePath: "URI",
    source: "ReferencedSubject",
    target: "ReferencedSubject",
    url: "URI",
    willCloseTarget: "Boolean",
  },
  DeclineTopicSuggestionPayload: {
    clientMutationId: "String",
    topic: "Topic",
  },
  Deletable: {
    "...on CommitComment": "CommitComment",
    "...on GistComment": "GistComment",
    "...on IssueComment": "IssueComment",
    "...on PullRequestReview": "PullRequestReview",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    viewerCanDelete: "Boolean",
  },
  DeleteProjectCardPayload: {
    clientMutationId: "String",
    column: "ProjectColumn",
    deletedCardId: "ID",
  },
  DeleteProjectColumnPayload: {
    clientMutationId: "String",
    deletedColumnId: "ID",
    project: "Project",
  },
  DeleteProjectPayload: {
    clientMutationId: "String",
    owner: "ProjectOwner",
  },
  DeletePullRequestReviewPayload: {
    clientMutationId: "String",
    pullRequestReview: "PullRequestReview",
  },
  DemilestonedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    milestoneTitle: "String",
    subject: "MilestoneItem",
  },
  DeployedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    deployment: "Deployment",
    id: "ID",
    pullRequest: "PullRequest",
    ref: "Ref",
  },
  DeployKey: {
    createdAt: "DateTime",
    id: "ID",
    key: "String",
    readOnly: "Boolean",
    title: "String",
    verified: "Boolean",
  },
  DeployKeyConnection: {
    edges: "DeployKeyEdge",
    nodes: "DeployKey",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  DeployKeyEdge: {
    cursor: "String",
    node: "DeployKey",
  },
  Deployment: {
    commit: "Commit",
    createdAt: "DateTime",
    creator: "Actor",
    databaseId: "Int",
    description: "String",
    environment: "String",
    id: "ID",
    latestStatus: "DeploymentStatus",
    payload: "String",
    ref: "Ref",
    repository: "Repository",
    state: "DeploymentState",
    statuses: "DeploymentStatusConnection",
    task: "String",
    updatedAt: "DateTime",
  },
  DeploymentConnection: {
    edges: "DeploymentEdge",
    nodes: "Deployment",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  DeploymentEdge: {
    cursor: "String",
    node: "Deployment",
  },
  DeploymentEnvironmentChangedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    deploymentStatus: "DeploymentStatus",
    id: "ID",
    pullRequest: "PullRequest",
  },
  DeploymentStatus: {
    createdAt: "DateTime",
    creator: "Actor",
    deployment: "Deployment",
    description: "String",
    environmentUrl: "URI",
    id: "ID",
    logUrl: "URI",
    state: "DeploymentStatusState",
    updatedAt: "DateTime",
  },
  DeploymentStatusConnection: {
    edges: "DeploymentStatusEdge",
    nodes: "DeploymentStatus",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  DeploymentStatusEdge: {
    cursor: "String",
    node: "DeploymentStatus",
  },
  DismissPullRequestReviewPayload: {
    clientMutationId: "String",
    pullRequestReview: "PullRequestReview",
  },
  ExternalIdentity: {
    guid: "String",
    id: "ID",
    organizationInvitation: "OrganizationInvitation",
    samlIdentity: "ExternalIdentitySamlAttributes",
    scimIdentity: "ExternalIdentityScimAttributes",
    user: "User",
  },
  ExternalIdentityConnection: {
    edges: "ExternalIdentityEdge",
    nodes: "ExternalIdentity",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ExternalIdentityEdge: {
    cursor: "String",
    node: "ExternalIdentity",
  },
  ExternalIdentitySamlAttributes: {
    nameId: "String",
  },
  ExternalIdentityScimAttributes: {
    username: "String",
  },
  FollowerConnection: {
    edges: "UserEdge",
    nodes: "User",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  FollowingConnection: {
    edges: "UserEdge",
    nodes: "User",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  Gist: {
    comments: "GistCommentConnection",
    createdAt: "DateTime",
    description: "String",
    id: "ID",
    isPublic: "Boolean",
    name: "String",
    owner: "RepositoryOwner",
    pushedAt: "DateTime",
    stargazers: "StargazerConnection",
    updatedAt: "DateTime",
    viewerHasStarred: "Boolean",
  },
  GistComment: {
    author: "Actor",
    authorAssociation: "CommentAuthorAssociation",
    body: "String",
    bodyHTML: "HTML",
    bodyText: "String",
    createdAt: "DateTime",
    createdViaEmail: "Boolean",
    databaseId: "Int",
    editor: "Actor",
    gist: "Gist",
    id: "ID",
    includesCreatedEdit: "Boolean",
    lastEditedAt: "DateTime",
    publishedAt: "DateTime",
    updatedAt: "DateTime",
    userContentEdits: "UserContentEditConnection",
    viewerCanDelete: "Boolean",
    viewerCanUpdate: "Boolean",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
    viewerDidAuthor: "Boolean",
  },
  GistCommentConnection: {
    edges: "GistCommentEdge",
    nodes: "GistComment",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  GistCommentEdge: {
    cursor: "String",
    node: "GistComment",
  },
  GistConnection: {
    edges: "GistEdge",
    nodes: "Gist",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  GistEdge: {
    cursor: "String",
    node: "Gist",
  },
  GitActor: {
    avatarUrl: "URI",
    date: "GitTimestamp",
    email: "String",
    name: "String",
    user: "User",
  },
  GitHubMetadata: {
    gitHubServicesSha: "GitObjectID",
    gitIpAddresses: "String",
    hookIpAddresses: "String",
    importerIpAddresses: "String",
    isPasswordAuthenticationVerifiable: "Boolean",
    pagesIpAddresses: "String",
  },
  GitObject: {
    "...on Blob": "Blob",
    "...on Commit": "Commit",
    "...on Tag": "Tag",
    "...on Tree": "Tree",
    abbreviatedOid: "String",
    commitResourcePath: "URI",
    commitUrl: "URI",
    id: "ID",
    oid: "GitObjectID",
    repository: "Repository",
  },
  GitSignature: {
    "...on GpgSignature": "GpgSignature",
    "...on SmimeSignature": "SmimeSignature",
    "...on UnknownSignature": "UnknownSignature",
    signer: "User",
    state: "GitSignatureState",
    wasSignedByGitHub: "Boolean",
    email: "String",
    isValid: "Boolean",
    payload: "String",
    signature: "String",
  },
  GpgSignature: {
    email: "String",
    isValid: "Boolean",
    keyId: "String",
    payload: "String",
    signature: "String",
    signer: "User",
    state: "GitSignatureState",
    wasSignedByGitHub: "Boolean",
  },
  HeadRefDeletedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    headRef: "Ref",
    headRefName: "String",
    id: "ID",
    pullRequest: "PullRequest",
  },
  HeadRefForcePushedEvent: {
    actor: "Actor",
    afterCommit: "Commit",
    beforeCommit: "Commit",
    createdAt: "DateTime",
    id: "ID",
    pullRequest: "PullRequest",
    ref: "Ref",
  },
  HeadRefRestoredEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    pullRequest: "PullRequest",
  },
  Issue: {
    activeLockReason: "LockReason",
    assignees: "UserConnection",
    author: "Actor",
    authorAssociation: "CommentAuthorAssociation",
    body: "String",
    bodyHTML: "HTML",
    bodyText: "String",
    closed: "Boolean",
    closedAt: "DateTime",
    comments: "IssueCommentConnection",
    createdAt: "DateTime",
    createdViaEmail: "Boolean",
    databaseId: "Int",
    editor: "Actor",
    id: "ID",
    includesCreatedEdit: "Boolean",
    labels: "LabelConnection",
    lastEditedAt: "DateTime",
    locked: "Boolean",
    milestone: "Milestone",
    number: "Int",
    participants: "UserConnection",
    projectCards: "ProjectCardConnection",
    publishedAt: "DateTime",
    reactionGroups: "ReactionGroup",
    reactions: "ReactionConnection",
    repository: "Repository",
    resourcePath: "URI",
    state: "IssueState",
    timeline: "IssueTimelineConnection",
    title: "String",
    updatedAt: "DateTime",
    url: "URI",
    userContentEdits: "UserContentEditConnection",
    viewerCanReact: "Boolean",
    viewerCanSubscribe: "Boolean",
    viewerCanUpdate: "Boolean",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
    viewerDidAuthor: "Boolean",
    viewerSubscription: "SubscriptionState",
  },
  IssueComment: {
    author: "Actor",
    authorAssociation: "CommentAuthorAssociation",
    body: "String",
    bodyHTML: "HTML",
    bodyText: "String",
    createdAt: "DateTime",
    createdViaEmail: "Boolean",
    databaseId: "Int",
    editor: "Actor",
    id: "ID",
    includesCreatedEdit: "Boolean",
    issue: "Issue",
    lastEditedAt: "DateTime",
    publishedAt: "DateTime",
    pullRequest: "PullRequest",
    reactionGroups: "ReactionGroup",
    reactions: "ReactionConnection",
    repository: "Repository",
    resourcePath: "URI",
    updatedAt: "DateTime",
    url: "URI",
    userContentEdits: "UserContentEditConnection",
    viewerCanDelete: "Boolean",
    viewerCanReact: "Boolean",
    viewerCanUpdate: "Boolean",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
    viewerDidAuthor: "Boolean",
  },
  IssueCommentConnection: {
    edges: "IssueCommentEdge",
    nodes: "IssueComment",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  IssueCommentEdge: {
    cursor: "String",
    node: "IssueComment",
  },
  IssueConnection: {
    edges: "IssueEdge",
    nodes: "Issue",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  IssueEdge: {
    cursor: "String",
    node: "Issue",
  },
  IssueOrPullRequest: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
  },
  IssueTimelineConnection: {
    edges: "IssueTimelineItemEdge",
    nodes: "IssueTimelineItem",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  IssueTimelineItem: {
    "...on AssignedEvent": "AssignedEvent",
    "...on ClosedEvent": "ClosedEvent",
    "...on Commit": "Commit",
    "...on CrossReferencedEvent": "CrossReferencedEvent",
    "...on DemilestonedEvent": "DemilestonedEvent",
    "...on IssueComment": "IssueComment",
    "...on LabeledEvent": "LabeledEvent",
    "...on LockedEvent": "LockedEvent",
    "...on MilestonedEvent": "MilestonedEvent",
    "...on ReferencedEvent": "ReferencedEvent",
    "...on RenamedTitleEvent": "RenamedTitleEvent",
    "...on ReopenedEvent": "ReopenedEvent",
    "...on SubscribedEvent": "SubscribedEvent",
    "...on UnassignedEvent": "UnassignedEvent",
    "...on UnlabeledEvent": "UnlabeledEvent",
    "...on UnlockedEvent": "UnlockedEvent",
    "...on UnsubscribedEvent": "UnsubscribedEvent",
  },
  IssueTimelineItemEdge: {
    cursor: "String",
    node: "IssueTimelineItem",
  },
  Label: {
    color: "String",
    createdAt: "DateTime",
    description: "String",
    id: "ID",
    isDefault: "Boolean",
    issues: "IssueConnection",
    name: "String",
    pullRequests: "PullRequestConnection",
    repository: "Repository",
    resourcePath: "URI",
    updatedAt: "DateTime",
    url: "URI",
  },
  Labelable: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
    labels: "LabelConnection",
  },
  LabelConnection: {
    edges: "LabelEdge",
    nodes: "Label",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  LabeledEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    label: "Label",
    labelable: "Labelable",
  },
  LabelEdge: {
    cursor: "String",
    node: "Label",
  },
  Language: {
    color: "String",
    id: "ID",
    name: "String",
  },
  LanguageConnection: {
    edges: "LanguageEdge",
    nodes: "Language",
    pageInfo: "PageInfo",
    totalCount: "Int",
    totalSize: "Int",
  },
  LanguageEdge: {
    cursor: "String",
    node: "Language",
    size: "Int",
  },
  License: {
    body: "String",
    conditions: "LicenseRule",
    description: "String",
    featured: "Boolean",
    hidden: "Boolean",
    id: "ID",
    implementation: "String",
    key: "String",
    limitations: "LicenseRule",
    name: "String",
    nickname: "String",
    permissions: "LicenseRule",
    pseudoLicense: "Boolean",
    spdxId: "String",
    url: "URI",
  },
  LicenseRule: {
    description: "String",
    key: "String",
    label: "String",
  },
  Lockable: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
    activeLockReason: "LockReason",
    locked: "Boolean",
  },
  LockedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    lockReason: "LockReason",
    lockable: "Lockable",
  },
  LockLockablePayload: {
    clientMutationId: "String",
    lockedRecord: "Lockable",
  },
  MarketplaceCategory: {
    description: "String",
    howItWorks: "String",
    id: "ID",
    name: "String",
    primaryListingCount: "Int",
    resourcePath: "URI",
    secondaryListingCount: "Int",
    slug: "String",
    url: "URI",
  },
  MarketplaceListing: {
    app: "App",
    companyUrl: "URI",
    configurationResourcePath: "URI",
    configurationUrl: "URI",
    documentationUrl: "URI",
    extendedDescription: "String",
    extendedDescriptionHTML: "HTML",
    fullDescription: "String",
    fullDescriptionHTML: "HTML",
    hasApprovalBeenRequested: "Boolean",
    hasPublishedFreeTrialPlans: "Boolean",
    hasTermsOfService: "Boolean",
    howItWorks: "String",
    howItWorksHTML: "HTML",
    id: "ID",
    installationUrl: "URI",
    installedForViewer: "Boolean",
    isApproved: "Boolean",
    isDelisted: "Boolean",
    isDraft: "Boolean",
    isPaid: "Boolean",
    isRejected: "Boolean",
    logoBackgroundColor: "String",
    logoUrl: "URI",
    name: "String",
    normalizedShortDescription: "String",
    pricingUrl: "URI",
    primaryCategory: "MarketplaceCategory",
    privacyPolicyUrl: "URI",
    resourcePath: "URI",
    screenshotUrls: "String",
    secondaryCategory: "MarketplaceCategory",
    shortDescription: "String",
    slug: "String",
    statusUrl: "URI",
    supportEmail: "String",
    supportUrl: "URI",
    termsOfServiceUrl: "URI",
    url: "URI",
    viewerCanAddPlans: "Boolean",
    viewerCanApprove: "Boolean",
    viewerCanDelist: "Boolean",
    viewerCanEdit: "Boolean",
    viewerCanEditCategories: "Boolean",
    viewerCanEditPlans: "Boolean",
    viewerCanRedraft: "Boolean",
    viewerCanReject: "Boolean",
    viewerCanRequestApproval: "Boolean",
    viewerHasPurchased: "Boolean",
    viewerHasPurchasedForAllOrganizations: "Boolean",
    viewerIsListingAdmin: "Boolean",
  },
  MarketplaceListingConnection: {
    edges: "MarketplaceListingEdge",
    nodes: "MarketplaceListing",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  MarketplaceListingEdge: {
    cursor: "String",
    node: "MarketplaceListing",
  },
  MentionedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
  },
  MergedEvent: {
    actor: "Actor",
    commit: "Commit",
    createdAt: "DateTime",
    id: "ID",
    mergeRef: "Ref",
    mergeRefName: "String",
    pullRequest: "PullRequest",
    resourcePath: "URI",
    url: "URI",
  },
  Milestone: {
    closed: "Boolean",
    closedAt: "DateTime",
    createdAt: "DateTime",
    creator: "Actor",
    description: "String",
    dueOn: "DateTime",
    id: "ID",
    issues: "IssueConnection",
    number: "Int",
    pullRequests: "PullRequestConnection",
    repository: "Repository",
    resourcePath: "URI",
    state: "MilestoneState",
    title: "String",
    updatedAt: "DateTime",
    url: "URI",
  },
  MilestoneConnection: {
    edges: "MilestoneEdge",
    nodes: "Milestone",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  MilestonedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    milestoneTitle: "String",
    subject: "MilestoneItem",
  },
  MilestoneEdge: {
    cursor: "String",
    node: "Milestone",
  },
  MilestoneItem: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
  },
  MovedColumnsInProjectEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
  },
  MoveProjectCardPayload: {
    cardEdge: "ProjectCardEdge",
    clientMutationId: "String",
  },
  MoveProjectColumnPayload: {
    clientMutationId: "String",
    columnEdge: "ProjectColumnEdge",
  },
  Mutation: {
    acceptTopicSuggestion: "AcceptTopicSuggestionPayload",
    addComment: "AddCommentPayload",
    addProjectCard: "AddProjectCardPayload",
    addProjectColumn: "AddProjectColumnPayload",
    addPullRequestReview: "AddPullRequestReviewPayload",
    addPullRequestReviewComment: "AddPullRequestReviewCommentPayload",
    addReaction: "AddReactionPayload",
    addStar: "AddStarPayload",
    createProject: "CreateProjectPayload",
    declineTopicSuggestion: "DeclineTopicSuggestionPayload",
    deleteProject: "DeleteProjectPayload",
    deleteProjectCard: "DeleteProjectCardPayload",
    deleteProjectColumn: "DeleteProjectColumnPayload",
    deletePullRequestReview: "DeletePullRequestReviewPayload",
    dismissPullRequestReview: "DismissPullRequestReviewPayload",
    lockLockable: "LockLockablePayload",
    moveProjectCard: "MoveProjectCardPayload",
    moveProjectColumn: "MoveProjectColumnPayload",
    removeOutsideCollaborator: "RemoveOutsideCollaboratorPayload",
    removeReaction: "RemoveReactionPayload",
    removeStar: "RemoveStarPayload",
    requestReviews: "RequestReviewsPayload",
    submitPullRequestReview: "SubmitPullRequestReviewPayload",
    unlockLockable: "UnlockLockablePayload",
    updateProject: "UpdateProjectPayload",
    updateProjectCard: "UpdateProjectCardPayload",
    updateProjectColumn: "UpdateProjectColumnPayload",
    updatePullRequestReview: "UpdatePullRequestReviewPayload",
    updatePullRequestReviewComment: "UpdatePullRequestReviewCommentPayload",
    updateSubscription: "UpdateSubscriptionPayload",
    updateTopics: "UpdateTopicsPayload",
  },
  Node: {
    "...on AddedToProjectEvent": "AddedToProjectEvent",
    "...on App": "App",
    "...on AssignedEvent": "AssignedEvent",
    "...on BaseRefChangedEvent": "BaseRefChangedEvent",
    "...on BaseRefForcePushedEvent": "BaseRefForcePushedEvent",
    "...on Blob": "Blob",
    "...on Bot": "Bot",
    "...on ClosedEvent": "ClosedEvent",
    "...on CommentDeletedEvent": "CommentDeletedEvent",
    "...on Commit": "Commit",
    "...on CommitComment": "CommitComment",
    "...on CommitCommentThread": "CommitCommentThread",
    "...on ConvertedNoteToIssueEvent": "ConvertedNoteToIssueEvent",
    "...on CrossReferencedEvent": "CrossReferencedEvent",
    "...on DemilestonedEvent": "DemilestonedEvent",
    "...on DeployedEvent": "DeployedEvent",
    "...on DeployKey": "DeployKey",
    "...on Deployment": "Deployment",
    "...on DeploymentEnvironmentChangedEvent":
      "DeploymentEnvironmentChangedEvent",
    "...on DeploymentStatus": "DeploymentStatus",
    "...on ExternalIdentity": "ExternalIdentity",
    "...on Gist": "Gist",
    "...on GistComment": "GistComment",
    "...on HeadRefDeletedEvent": "HeadRefDeletedEvent",
    "...on HeadRefForcePushedEvent": "HeadRefForcePushedEvent",
    "...on HeadRefRestoredEvent": "HeadRefRestoredEvent",
    "...on Issue": "Issue",
    "...on IssueComment": "IssueComment",
    "...on Label": "Label",
    "...on LabeledEvent": "LabeledEvent",
    "...on Language": "Language",
    "...on License": "License",
    "...on LockedEvent": "LockedEvent",
    "...on MarketplaceCategory": "MarketplaceCategory",
    "...on MarketplaceListing": "MarketplaceListing",
    "...on MentionedEvent": "MentionedEvent",
    "...on MergedEvent": "MergedEvent",
    "...on Milestone": "Milestone",
    "...on MilestonedEvent": "MilestonedEvent",
    "...on MovedColumnsInProjectEvent": "MovedColumnsInProjectEvent",
    "...on Organization": "Organization",
    "...on OrganizationIdentityProvider": "OrganizationIdentityProvider",
    "...on OrganizationInvitation": "OrganizationInvitation",
    "...on Project": "Project",
    "...on ProjectCard": "ProjectCard",
    "...on ProjectColumn": "ProjectColumn",
    "...on ProtectedBranch": "ProtectedBranch",
    "...on PublicKey": "PublicKey",
    "...on PullRequest": "PullRequest",
    "...on PullRequestCommit": "PullRequestCommit",
    "...on PullRequestReview": "PullRequestReview",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    "...on PullRequestReviewThread": "PullRequestReviewThread",
    "...on PushAllowance": "PushAllowance",
    "...on Reaction": "Reaction",
    "...on Ref": "Ref",
    "...on ReferencedEvent": "ReferencedEvent",
    "...on Release": "Release",
    "...on ReleaseAsset": "ReleaseAsset",
    "...on RemovedFromProjectEvent": "RemovedFromProjectEvent",
    "...on RenamedTitleEvent": "RenamedTitleEvent",
    "...on ReopenedEvent": "ReopenedEvent",
    "...on Repository": "Repository",
    "...on RepositoryInvitation": "RepositoryInvitation",
    "...on RepositoryTopic": "RepositoryTopic",
    "...on ReviewDismissalAllowance": "ReviewDismissalAllowance",
    "...on ReviewDismissedEvent": "ReviewDismissedEvent",
    "...on ReviewRequest": "ReviewRequest",
    "...on ReviewRequestedEvent": "ReviewRequestedEvent",
    "...on ReviewRequestRemovedEvent": "ReviewRequestRemovedEvent",
    "...on Status": "Status",
    "...on StatusContext": "StatusContext",
    "...on SubscribedEvent": "SubscribedEvent",
    "...on Tag": "Tag",
    "...on Team": "Team",
    "...on Topic": "Topic",
    "...on Tree": "Tree",
    "...on UnassignedEvent": "UnassignedEvent",
    "...on UnlabeledEvent": "UnlabeledEvent",
    "...on UnlockedEvent": "UnlockedEvent",
    "...on UnsubscribedEvent": "UnsubscribedEvent",
    "...on User": "User",
    "...on UserContentEdit": "UserContentEdit",
    id: "ID",
  },
  Organization: {
    avatarUrl: "URI",
    databaseId: "Int",
    description: "String",
    email: "String",
    id: "ID",
    isVerified: "Boolean",
    location: "String",
    login: "String",
    members: "UserConnection",
    name: "String",
    newTeamResourcePath: "URI",
    newTeamUrl: "URI",
    organizationBillingEmail: "String",
    pinnedRepositories: "RepositoryConnection",
    project: "Project",
    projects: "ProjectConnection",
    projectsResourcePath: "URI",
    projectsUrl: "URI",
    repositories: "RepositoryConnection",
    repository: "Repository",
    requiresTwoFactorAuthentication: "Boolean",
    resourcePath: "URI",
    samlIdentityProvider: "OrganizationIdentityProvider",
    team: "Team",
    teams: "TeamConnection",
    teamsResourcePath: "URI",
    teamsUrl: "URI",
    url: "URI",
    viewerCanAdminister: "Boolean",
    viewerCanCreateProjects: "Boolean",
    viewerCanCreateRepositories: "Boolean",
    viewerCanCreateTeams: "Boolean",
    viewerIsAMember: "Boolean",
    websiteUrl: "URI",
  },
  OrganizationConnection: {
    edges: "OrganizationEdge",
    nodes: "Organization",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  OrganizationEdge: {
    cursor: "String",
    node: "Organization",
  },
  OrganizationIdentityProvider: {
    digestMethod: "URI",
    externalIdentities: "ExternalIdentityConnection",
    id: "ID",
    idpCertificate: "X509Certificate",
    issuer: "String",
    organization: "Organization",
    signatureMethod: "URI",
    ssoUrl: "URI",
  },
  OrganizationInvitation: {
    createdAt: "DateTime",
    email: "String",
    id: "ID",
    invitationType: "OrganizationInvitationType",
    invitee: "User",
    inviter: "User",
    organization: "Organization",
    role: "OrganizationInvitationRole",
  },
  OrganizationInvitationConnection: {
    edges: "OrganizationInvitationEdge",
    nodes: "OrganizationInvitation",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  OrganizationInvitationEdge: {
    cursor: "String",
    node: "OrganizationInvitation",
  },
  PageInfo: {
    endCursor: "String",
    hasNextPage: "Boolean",
    hasPreviousPage: "Boolean",
    startCursor: "String",
  },
  Project: {
    body: "String",
    bodyHTML: "HTML",
    closed: "Boolean",
    closedAt: "DateTime",
    columns: "ProjectColumnConnection",
    createdAt: "DateTime",
    creator: "Actor",
    databaseId: "Int",
    id: "ID",
    name: "String",
    number: "Int",
    owner: "ProjectOwner",
    pendingCards: "ProjectCardConnection",
    resourcePath: "URI",
    state: "ProjectState",
    updatedAt: "DateTime",
    url: "URI",
    viewerCanUpdate: "Boolean",
  },
  ProjectCard: {
    column: "ProjectColumn",
    content: "ProjectCardItem",
    createdAt: "DateTime",
    creator: "Actor",
    databaseId: "Int",
    id: "ID",
    isArchived: "Boolean",
    note: "String",
    project: "Project",
    resourcePath: "URI",
    state: "ProjectCardState",
    updatedAt: "DateTime",
    url: "URI",
  },
  ProjectCardConnection: {
    edges: "ProjectCardEdge",
    nodes: "ProjectCard",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ProjectCardEdge: {
    cursor: "String",
    node: "ProjectCard",
  },
  ProjectCardItem: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
  },
  ProjectColumn: {
    cards: "ProjectCardConnection",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
    name: "String",
    project: "Project",
    purpose: "ProjectColumnPurpose",
    resourcePath: "URI",
    updatedAt: "DateTime",
    url: "URI",
  },
  ProjectColumnConnection: {
    edges: "ProjectColumnEdge",
    nodes: "ProjectColumn",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ProjectColumnEdge: {
    cursor: "String",
    node: "ProjectColumn",
  },
  ProjectConnection: {
    edges: "ProjectEdge",
    nodes: "Project",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ProjectEdge: {
    cursor: "String",
    node: "Project",
  },
  ProjectOwner: {
    "...on Organization": "Organization",
    "...on Repository": "Repository",
    projects: "ProjectConnection",
    projectsResourcePath: "URI",
    projectsUrl: "URI",
    viewerCanCreateProjects: "Boolean",
    id: "ID",
    project: "Project",
  },
  ProtectedBranch: {
    creator: "Actor",
    hasDismissableStaleReviews: "Boolean",
    hasRequiredReviews: "Boolean",
    hasRequiredStatusChecks: "Boolean",
    hasRestrictedPushes: "Boolean",
    hasRestrictedReviewDismissals: "Boolean",
    hasStrictRequiredStatusChecks: "Boolean",
    id: "ID",
    isAdminEnforced: "Boolean",
    name: "String",
    pushAllowances: "PushAllowanceConnection",
    repository: "Repository",
    requiredStatusCheckContexts: "String",
    reviewDismissalAllowances: "ReviewDismissalAllowanceConnection",
  },
  ProtectedBranchConnection: {
    edges: "ProtectedBranchEdge",
    nodes: "ProtectedBranch",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ProtectedBranchEdge: {
    cursor: "String",
    node: "ProtectedBranch",
  },
  PublicKey: {
    id: "ID",
    key: "String",
  },
  PublicKeyConnection: {
    edges: "PublicKeyEdge",
    nodes: "PublicKey",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  PublicKeyEdge: {
    cursor: "String",
    node: "PublicKey",
  },
  PullRequest: {
    activeLockReason: "LockReason",
    additions: "Int",
    assignees: "UserConnection",
    author: "Actor",
    authorAssociation: "CommentAuthorAssociation",
    baseRef: "Ref",
    baseRefName: "String",
    baseRefOid: "GitObjectID",
    body: "String",
    bodyHTML: "HTML",
    bodyText: "String",
    changedFiles: "Int",
    closed: "Boolean",
    closedAt: "DateTime",
    comments: "IssueCommentConnection",
    commits: "PullRequestCommitConnection",
    createdAt: "DateTime",
    createdViaEmail: "Boolean",
    databaseId: "Int",
    deletions: "Int",
    editor: "Actor",
    headRef: "Ref",
    headRefName: "String",
    headRefOid: "GitObjectID",
    headRepository: "Repository",
    headRepositoryOwner: "RepositoryOwner",
    id: "ID",
    includesCreatedEdit: "Boolean",
    isCrossRepository: "Boolean",
    labels: "LabelConnection",
    lastEditedAt: "DateTime",
    locked: "Boolean",
    maintainerCanModify: "Boolean",
    mergeCommit: "Commit",
    mergeable: "MergeableState",
    merged: "Boolean",
    mergedAt: "DateTime",
    mergedBy: "Actor",
    milestone: "Milestone",
    number: "Int",
    participants: "UserConnection",
    permalink: "URI",
    potentialMergeCommit: "Commit",
    projectCards: "ProjectCardConnection",
    publishedAt: "DateTime",
    reactionGroups: "ReactionGroup",
    reactions: "ReactionConnection",
    repository: "Repository",
    resourcePath: "URI",
    revertResourcePath: "URI",
    revertUrl: "URI",
    reviewRequests: "ReviewRequestConnection",
    reviews: "PullRequestReviewConnection",
    state: "PullRequestState",
    suggestedReviewers: "SuggestedReviewer",
    timeline: "PullRequestTimelineConnection",
    title: "String",
    updatedAt: "DateTime",
    url: "URI",
    userContentEdits: "UserContentEditConnection",
    viewerCanApplySuggestion: "Boolean",
    viewerCanReact: "Boolean",
    viewerCanSubscribe: "Boolean",
    viewerCanUpdate: "Boolean",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
    viewerDidAuthor: "Boolean",
    viewerSubscription: "SubscriptionState",
  },
  PullRequestCommit: {
    commit: "Commit",
    id: "ID",
    pullRequest: "PullRequest",
    resourcePath: "URI",
    url: "URI",
  },
  PullRequestCommitConnection: {
    edges: "PullRequestCommitEdge",
    nodes: "PullRequestCommit",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  PullRequestCommitEdge: {
    cursor: "String",
    node: "PullRequestCommit",
  },
  PullRequestConnection: {
    edges: "PullRequestEdge",
    nodes: "PullRequest",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  PullRequestEdge: {
    cursor: "String",
    node: "PullRequest",
  },
  PullRequestReview: {
    author: "Actor",
    authorAssociation: "CommentAuthorAssociation",
    body: "String",
    bodyHTML: "HTML",
    bodyText: "String",
    comments: "PullRequestReviewCommentConnection",
    commit: "Commit",
    createdAt: "DateTime",
    createdViaEmail: "Boolean",
    databaseId: "Int",
    editor: "Actor",
    id: "ID",
    includesCreatedEdit: "Boolean",
    lastEditedAt: "DateTime",
    publishedAt: "DateTime",
    pullRequest: "PullRequest",
    repository: "Repository",
    resourcePath: "URI",
    state: "PullRequestReviewState",
    submittedAt: "DateTime",
    updatedAt: "DateTime",
    url: "URI",
    userContentEdits: "UserContentEditConnection",
    viewerCanDelete: "Boolean",
    viewerCanUpdate: "Boolean",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
    viewerDidAuthor: "Boolean",
  },
  PullRequestReviewComment: {
    author: "Actor",
    authorAssociation: "CommentAuthorAssociation",
    body: "String",
    bodyHTML: "HTML",
    bodyText: "String",
    commit: "Commit",
    createdAt: "DateTime",
    createdViaEmail: "Boolean",
    databaseId: "Int",
    diffHunk: "String",
    draftedAt: "DateTime",
    editor: "Actor",
    id: "ID",
    includesCreatedEdit: "Boolean",
    lastEditedAt: "DateTime",
    originalCommit: "Commit",
    originalPosition: "Int",
    path: "String",
    position: "Int",
    publishedAt: "DateTime",
    pullRequest: "PullRequest",
    pullRequestReview: "PullRequestReview",
    reactionGroups: "ReactionGroup",
    reactions: "ReactionConnection",
    replyTo: "PullRequestReviewComment",
    repository: "Repository",
    resourcePath: "URI",
    updatedAt: "DateTime",
    url: "URI",
    userContentEdits: "UserContentEditConnection",
    viewerCanDelete: "Boolean",
    viewerCanReact: "Boolean",
    viewerCanUpdate: "Boolean",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
    viewerDidAuthor: "Boolean",
  },
  PullRequestReviewCommentConnection: {
    edges: "PullRequestReviewCommentEdge",
    nodes: "PullRequestReviewComment",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  PullRequestReviewCommentEdge: {
    cursor: "String",
    node: "PullRequestReviewComment",
  },
  PullRequestReviewConnection: {
    edges: "PullRequestReviewEdge",
    nodes: "PullRequestReview",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  PullRequestReviewEdge: {
    cursor: "String",
    node: "PullRequestReview",
  },
  PullRequestReviewThread: {
    comments: "PullRequestReviewCommentConnection",
    id: "ID",
    pullRequest: "PullRequest",
    repository: "Repository",
  },
  PullRequestTimelineConnection: {
    edges: "PullRequestTimelineItemEdge",
    nodes: "PullRequestTimelineItem",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  PullRequestTimelineItem: {
    "...on AssignedEvent": "AssignedEvent",
    "...on BaseRefForcePushedEvent": "BaseRefForcePushedEvent",
    "...on ClosedEvent": "ClosedEvent",
    "...on Commit": "Commit",
    "...on CommitCommentThread": "CommitCommentThread",
    "...on CrossReferencedEvent": "CrossReferencedEvent",
    "...on DemilestonedEvent": "DemilestonedEvent",
    "...on DeployedEvent": "DeployedEvent",
    "...on DeploymentEnvironmentChangedEvent":
      "DeploymentEnvironmentChangedEvent",
    "...on HeadRefDeletedEvent": "HeadRefDeletedEvent",
    "...on HeadRefForcePushedEvent": "HeadRefForcePushedEvent",
    "...on HeadRefRestoredEvent": "HeadRefRestoredEvent",
    "...on IssueComment": "IssueComment",
    "...on LabeledEvent": "LabeledEvent",
    "...on LockedEvent": "LockedEvent",
    "...on MergedEvent": "MergedEvent",
    "...on MilestonedEvent": "MilestonedEvent",
    "...on PullRequestReview": "PullRequestReview",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    "...on PullRequestReviewThread": "PullRequestReviewThread",
    "...on ReferencedEvent": "ReferencedEvent",
    "...on RenamedTitleEvent": "RenamedTitleEvent",
    "...on ReopenedEvent": "ReopenedEvent",
    "...on ReviewDismissedEvent": "ReviewDismissedEvent",
    "...on ReviewRequestRemovedEvent": "ReviewRequestRemovedEvent",
    "...on ReviewRequestedEvent": "ReviewRequestedEvent",
    "...on SubscribedEvent": "SubscribedEvent",
    "...on UnassignedEvent": "UnassignedEvent",
    "...on UnlabeledEvent": "UnlabeledEvent",
    "...on UnlockedEvent": "UnlockedEvent",
    "...on UnsubscribedEvent": "UnsubscribedEvent",
  },
  PullRequestTimelineItemEdge: {
    cursor: "String",
    node: "PullRequestTimelineItem",
  },
  PushAllowance: {
    actor: "PushAllowanceActor",
    id: "ID",
    protectedBranch: "ProtectedBranch",
  },
  PushAllowanceActor: {
    "...on Team": "Team",
    "...on User": "User",
  },
  PushAllowanceConnection: {
    edges: "PushAllowanceEdge",
    nodes: "PushAllowance",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  PushAllowanceEdge: {
    cursor: "String",
    node: "PushAllowance",
  },
  Query: {
    codeOfConduct: "CodeOfConduct",
    codesOfConduct: "CodeOfConduct",
    license: "License",
    licenses: "License",
    marketplaceCategories: "MarketplaceCategory",
    marketplaceCategory: "MarketplaceCategory",
    marketplaceListing: "MarketplaceListing",
    marketplaceListings: "MarketplaceListingConnection",
    meta: "GitHubMetadata",
    node: "Node",
    nodes: "Node",
    organization: "Organization",
    rateLimit: "RateLimit",
    relay: "Query",
    repository: "Repository",
    repositoryOwner: "RepositoryOwner",
    resource: "UniformResourceLocatable",
    search: "SearchResultItemConnection",
    topic: "Topic",
    user: "User",
    viewer: "User",
  },
  RateLimit: {
    cost: "Int",
    limit: "Int",
    nodeCount: "Int",
    remaining: "Int",
    resetAt: "DateTime",
  },
  Reactable: {
    "...on CommitComment": "CommitComment",
    "...on Issue": "Issue",
    "...on IssueComment": "IssueComment",
    "...on PullRequest": "PullRequest",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    id: "ID",
    reactionGroups: "ReactionGroup",
    reactions: "ReactionConnection",
    viewerCanReact: "Boolean",
    databaseId: "Int",
  },
  ReactingUserConnection: {
    edges: "ReactingUserEdge",
    nodes: "User",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ReactingUserEdge: {
    cursor: "String",
    node: "User",
    reactedAt: "DateTime",
  },
  Reaction: {
    content: "ReactionContent",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
    reactable: "Reactable",
    user: "User",
  },
  ReactionConnection: {
    edges: "ReactionEdge",
    nodes: "Reaction",
    pageInfo: "PageInfo",
    totalCount: "Int",
    viewerHasReacted: "Boolean",
  },
  ReactionEdge: {
    cursor: "String",
    node: "Reaction",
  },
  ReactionGroup: {
    content: "ReactionContent",
    createdAt: "DateTime",
    subject: "Reactable",
    users: "ReactingUserConnection",
    viewerHasReacted: "Boolean",
  },
  Ref: {
    associatedPullRequests: "PullRequestConnection",
    id: "ID",
    name: "String",
    prefix: "String",
    repository: "Repository",
    target: "GitObject",
  },
  RefConnection: {
    edges: "RefEdge",
    nodes: "Ref",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  RefEdge: {
    cursor: "String",
    node: "Ref",
  },
  ReferencedEvent: {
    actor: "Actor",
    commit: "Commit",
    commitRepository: "Repository",
    createdAt: "DateTime",
    id: "ID",
    isCrossRepository: "Boolean",
    isDirectReference: "Boolean",
    subject: "ReferencedSubject",
  },
  ReferencedSubject: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
  },
  RegistryPackageOwner: {
    "...on Organization": "Organization",
    "...on Repository": "Repository",
    "...on User": "User",
    id: "ID",
  },
  RegistryPackageSearch: {
    "...on Organization": "Organization",
    "...on User": "User",
    id: "ID",
  },
  Release: {
    author: "User",
    createdAt: "DateTime",
    description: "String",
    id: "ID",
    isDraft: "Boolean",
    isPrerelease: "Boolean",
    name: "String",
    publishedAt: "DateTime",
    releaseAssets: "ReleaseAssetConnection",
    resourcePath: "URI",
    tag: "Ref",
    updatedAt: "DateTime",
    url: "URI",
  },
  ReleaseAsset: {
    contentType: "String",
    createdAt: "DateTime",
    downloadCount: "Int",
    downloadUrl: "URI",
    id: "ID",
    name: "String",
    release: "Release",
    size: "Int",
    updatedAt: "DateTime",
    uploadedBy: "User",
    url: "URI",
  },
  ReleaseAssetConnection: {
    edges: "ReleaseAssetEdge",
    nodes: "ReleaseAsset",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ReleaseAssetEdge: {
    cursor: "String",
    node: "ReleaseAsset",
  },
  ReleaseConnection: {
    edges: "ReleaseEdge",
    nodes: "Release",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ReleaseEdge: {
    cursor: "String",
    node: "Release",
  },
  RemovedFromProjectEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
  },
  RemoveOutsideCollaboratorPayload: {
    clientMutationId: "String",
    removedUser: "User",
  },
  RemoveReactionPayload: {
    clientMutationId: "String",
    reaction: "Reaction",
    subject: "Reactable",
  },
  RemoveStarPayload: {
    clientMutationId: "String",
    starrable: "Starrable",
  },
  RenamedTitleEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    currentTitle: "String",
    id: "ID",
    previousTitle: "String",
    subject: "RenamedTitleSubject",
  },
  RenamedTitleSubject: {
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
  },
  ReopenedEvent: {
    actor: "Actor",
    closable: "Closable",
    createdAt: "DateTime",
    id: "ID",
  },
  Repository: {
    assignableUsers: "UserConnection",
    codeOfConduct: "CodeOfConduct",
    collaborators: "RepositoryCollaboratorConnection",
    commitComments: "CommitCommentConnection",
    createdAt: "DateTime",
    databaseId: "Int",
    defaultBranchRef: "Ref",
    deployKeys: "DeployKeyConnection",
    deployments: "DeploymentConnection",
    description: "String",
    descriptionHTML: "HTML",
    diskUsage: "Int",
    forkCount: "Int",
    forks: "RepositoryConnection",
    hasIssuesEnabled: "Boolean",
    hasWikiEnabled: "Boolean",
    homepageUrl: "URI",
    id: "ID",
    isArchived: "Boolean",
    isFork: "Boolean",
    isLocked: "Boolean",
    isMirror: "Boolean",
    isPrivate: "Boolean",
    issue: "Issue",
    issueOrPullRequest: "IssueOrPullRequest",
    issues: "IssueConnection",
    label: "Label",
    labels: "LabelConnection",
    languages: "LanguageConnection",
    licenseInfo: "License",
    lockReason: "RepositoryLockReason",
    mentionableUsers: "UserConnection",
    mergeCommitAllowed: "Boolean",
    milestone: "Milestone",
    milestones: "MilestoneConnection",
    mirrorUrl: "URI",
    name: "String",
    nameWithOwner: "String",
    object: "GitObject",
    owner: "RepositoryOwner",
    parent: "Repository",
    primaryLanguage: "Language",
    project: "Project",
    projects: "ProjectConnection",
    projectsResourcePath: "URI",
    projectsUrl: "URI",
    protectedBranches: "ProtectedBranchConnection",
    pullRequest: "PullRequest",
    pullRequests: "PullRequestConnection",
    pushedAt: "DateTime",
    rebaseMergeAllowed: "Boolean",
    ref: "Ref",
    refs: "RefConnection",
    release: "Release",
    releases: "ReleaseConnection",
    repositoryTopics: "RepositoryTopicConnection",
    resourcePath: "URI",
    shortDescriptionHTML: "HTML",
    squashMergeAllowed: "Boolean",
    sshUrl: "GitSSHRemote",
    stargazers: "StargazerConnection",
    updatedAt: "DateTime",
    url: "URI",
    viewerCanAdminister: "Boolean",
    viewerCanCreateProjects: "Boolean",
    viewerCanSubscribe: "Boolean",
    viewerCanUpdateTopics: "Boolean",
    viewerHasStarred: "Boolean",
    viewerPermission: "RepositoryPermission",
    viewerSubscription: "SubscriptionState",
    watchers: "UserConnection",
  },
  RepositoryCollaboratorConnection: {
    edges: "RepositoryCollaboratorEdge",
    nodes: "User",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  RepositoryCollaboratorEdge: {
    cursor: "String",
    node: "User",
    permission: "RepositoryPermission",
  },
  RepositoryConnection: {
    edges: "RepositoryEdge",
    nodes: "Repository",
    pageInfo: "PageInfo",
    totalCount: "Int",
    totalDiskUsage: "Int",
  },
  RepositoryEdge: {
    cursor: "String",
    node: "Repository",
  },
  RepositoryInfo: {
    "...on Repository": "Repository",
    hasIssuesEnabled: "Boolean",
    resourcePath: "URI",
    url: "URI",
    createdAt: "DateTime",
    isLocked: "Boolean",
    description: "String",
    shortDescriptionHTML: "HTML",
    updatedAt: "DateTime",
    isMirror: "Boolean",
    isFork: "Boolean",
    pushedAt: "DateTime",
    name: "String",
    nameWithOwner: "String",
    descriptionHTML: "HTML",
    hasWikiEnabled: "Boolean",
    homepageUrl: "URI",
    owner: "RepositoryOwner",
    lockReason: "RepositoryLockReason",
    isPrivate: "Boolean",
    mirrorUrl: "URI",
    forkCount: "Int",
    isArchived: "Boolean",
    licenseInfo: "License",
  },
  RepositoryInvitation: {
    id: "ID",
    invitee: "User",
    inviter: "User",
    permission: "RepositoryPermission",
    repository: "RepositoryInfo",
  },
  RepositoryNode: {
    "...on CommitComment": "CommitComment",
    "...on CommitCommentThread": "CommitCommentThread",
    "...on Issue": "Issue",
    "...on IssueComment": "IssueComment",
    "...on PullRequest": "PullRequest",
    "...on PullRequestReview": "PullRequestReview",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    repository: "Repository",
  },
  RepositoryOwner: {
    "...on Organization": "Organization",
    "...on User": "User",
    login: "String",
    pinnedRepositories: "RepositoryConnection",
    repositories: "RepositoryConnection",
    repository: "Repository",
    resourcePath: "URI",
    url: "URI",
    avatarUrl: "URI",
    id: "ID",
  },
  RepositoryTopic: {
    id: "ID",
    resourcePath: "URI",
    topic: "Topic",
    url: "URI",
  },
  RepositoryTopicConnection: {
    edges: "RepositoryTopicEdge",
    nodes: "RepositoryTopic",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  RepositoryTopicEdge: {
    cursor: "String",
    node: "RepositoryTopic",
  },
  RequestedReviewer: {
    "...on Team": "Team",
    "...on User": "User",
  },
  RequestReviewsPayload: {
    clientMutationId: "String",
    pullRequest: "PullRequest",
    requestedReviewersEdge: "UserEdge",
  },
  ReviewDismissalAllowance: {
    actor: "ReviewDismissalAllowanceActor",
    id: "ID",
    protectedBranch: "ProtectedBranch",
  },
  ReviewDismissalAllowanceActor: {
    "...on Team": "Team",
    "...on User": "User",
  },
  ReviewDismissalAllowanceConnection: {
    edges: "ReviewDismissalAllowanceEdge",
    nodes: "ReviewDismissalAllowance",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ReviewDismissalAllowanceEdge: {
    cursor: "String",
    node: "ReviewDismissalAllowance",
  },
  ReviewDismissedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    databaseId: "Int",
    id: "ID",
    message: "String",
    messageHtml: "HTML",
    previousReviewState: "PullRequestReviewState",
    pullRequest: "PullRequest",
    pullRequestCommit: "PullRequestCommit",
    resourcePath: "URI",
    review: "PullRequestReview",
    url: "URI",
  },
  ReviewRequest: {
    databaseId: "Int",
    id: "ID",
    pullRequest: "PullRequest",
    requestedReviewer: "RequestedReviewer",
  },
  ReviewRequestConnection: {
    edges: "ReviewRequestEdge",
    nodes: "ReviewRequest",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  ReviewRequestedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    pullRequest: "PullRequest",
    requestedReviewer: "RequestedReviewer",
  },
  ReviewRequestEdge: {
    cursor: "String",
    node: "ReviewRequest",
  },
  ReviewRequestRemovedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    pullRequest: "PullRequest",
    requestedReviewer: "RequestedReviewer",
  },
  SearchResultItem: {
    "...on Issue": "Issue",
    "...on MarketplaceListing": "MarketplaceListing",
    "...on Organization": "Organization",
    "...on PullRequest": "PullRequest",
    "...on Repository": "Repository",
    "...on User": "User",
  },
  SearchResultItemConnection: {
    codeCount: "Int",
    edges: "SearchResultItemEdge",
    issueCount: "Int",
    nodes: "SearchResultItem",
    pageInfo: "PageInfo",
    repositoryCount: "Int",
    userCount: "Int",
    wikiCount: "Int",
  },
  SearchResultItemEdge: {
    cursor: "String",
    node: "SearchResultItem",
    textMatches: "TextMatch",
  },
  SmimeSignature: {
    email: "String",
    isValid: "Boolean",
    payload: "String",
    signature: "String",
    signer: "User",
    state: "GitSignatureState",
    wasSignedByGitHub: "Boolean",
  },
  StargazerConnection: {
    edges: "StargazerEdge",
    nodes: "User",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  StargazerEdge: {
    cursor: "String",
    node: "User",
    starredAt: "DateTime",
  },
  Starrable: {
    "...on Gist": "Gist",
    "...on Repository": "Repository",
    id: "ID",
    stargazers: "StargazerConnection",
    viewerHasStarred: "Boolean",
  },
  StarredRepositoryConnection: {
    edges: "StarredRepositoryEdge",
    nodes: "Repository",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  StarredRepositoryEdge: {
    cursor: "String",
    node: "Repository",
    starredAt: "DateTime",
  },
  Status: {
    commit: "Commit",
    context: "StatusContext",
    contexts: "StatusContext",
    id: "ID",
    state: "StatusState",
  },
  StatusContext: {
    commit: "Commit",
    context: "String",
    createdAt: "DateTime",
    creator: "Actor",
    description: "String",
    id: "ID",
    state: "StatusState",
    targetUrl: "URI",
  },
  SubmitPullRequestReviewPayload: {
    clientMutationId: "String",
    pullRequestReview: "PullRequestReview",
  },
  Subscribable: {
    "...on Commit": "Commit",
    "...on Issue": "Issue",
    "...on PullRequest": "PullRequest",
    "...on Repository": "Repository",
    "...on Team": "Team",
    viewerCanSubscribe: "Boolean",
    viewerSubscription: "SubscriptionState",
    id: "ID",
  },
  SubscribedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    subscribable: "Subscribable",
  },
  SuggestedReviewer: {
    isAuthor: "Boolean",
    isCommenter: "Boolean",
    reviewer: "User",
  },
  Tag: {
    abbreviatedOid: "String",
    commitResourcePath: "URI",
    commitUrl: "URI",
    id: "ID",
    message: "String",
    name: "String",
    oid: "GitObjectID",
    repository: "Repository",
    tagger: "GitActor",
    target: "GitObject",
  },
  Team: {
    ancestors: "TeamConnection",
    avatarUrl: "URI",
    childTeams: "TeamConnection",
    combinedSlug: "String",
    createdAt: "DateTime",
    description: "String",
    editTeamResourcePath: "URI",
    editTeamUrl: "URI",
    id: "ID",
    invitations: "OrganizationInvitationConnection",
    members: "TeamMemberConnection",
    membersResourcePath: "URI",
    membersUrl: "URI",
    name: "String",
    newTeamResourcePath: "URI",
    newTeamUrl: "URI",
    organization: "Organization",
    parentTeam: "Team",
    privacy: "TeamPrivacy",
    repositories: "TeamRepositoryConnection",
    repositoriesResourcePath: "URI",
    repositoriesUrl: "URI",
    resourcePath: "URI",
    slug: "String",
    teamsResourcePath: "URI",
    teamsUrl: "URI",
    updatedAt: "DateTime",
    url: "URI",
    viewerCanAdminister: "Boolean",
    viewerCanSubscribe: "Boolean",
    viewerSubscription: "SubscriptionState",
  },
  TeamConnection: {
    edges: "TeamEdge",
    nodes: "Team",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  TeamEdge: {
    cursor: "String",
    node: "Team",
  },
  TeamMemberConnection: {
    edges: "TeamMemberEdge",
    nodes: "User",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  TeamMemberEdge: {
    cursor: "String",
    memberAccessResourcePath: "URI",
    memberAccessUrl: "URI",
    node: "User",
    role: "TeamMemberRole",
  },
  TeamRepositoryConnection: {
    edges: "TeamRepositoryEdge",
    nodes: "Repository",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  TeamRepositoryEdge: {
    cursor: "String",
    node: "Repository",
    permission: "RepositoryPermission",
  },
  TextMatch: {
    fragment: "String",
    highlights: "TextMatchHighlight",
    property: "String",
  },
  TextMatchHighlight: {
    beginIndice: "Int",
    endIndice: "Int",
    text: "String",
  },
  Topic: {
    id: "ID",
    name: "String",
    relatedTopics: "Topic",
  },
  Tree: {
    abbreviatedOid: "String",
    commitResourcePath: "URI",
    commitUrl: "URI",
    entries: "TreeEntry",
    id: "ID",
    oid: "GitObjectID",
    repository: "Repository",
  },
  TreeEntry: {
    mode: "Int",
    name: "String",
    object: "GitObject",
    oid: "GitObjectID",
    repository: "Repository",
    type: "String",
  },
  UnassignedEvent: {
    actor: "Actor",
    assignable: "Assignable",
    createdAt: "DateTime",
    id: "ID",
    user: "User",
  },
  UniformResourceLocatable: {
    "...on Bot": "Bot",
    "...on ClosedEvent": "ClosedEvent",
    "...on CrossReferencedEvent": "CrossReferencedEvent",
    "...on Issue": "Issue",
    "...on MergedEvent": "MergedEvent",
    "...on Milestone": "Milestone",
    "...on Organization": "Organization",
    "...on PullRequest": "PullRequest",
    "...on PullRequestCommit": "PullRequestCommit",
    "...on Release": "Release",
    "...on Repository": "Repository",
    "...on RepositoryTopic": "RepositoryTopic",
    "...on ReviewDismissedEvent": "ReviewDismissedEvent",
    "...on User": "User",
    resourcePath: "URI",
    url: "URI",
  },
  UnknownSignature: {
    email: "String",
    isValid: "Boolean",
    payload: "String",
    signature: "String",
    signer: "User",
    state: "GitSignatureState",
    wasSignedByGitHub: "Boolean",
  },
  UnlabeledEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    label: "Label",
    labelable: "Labelable",
  },
  UnlockedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    lockable: "Lockable",
  },
  UnlockLockablePayload: {
    clientMutationId: "String",
    unlockedRecord: "Lockable",
  },
  UnsubscribedEvent: {
    actor: "Actor",
    createdAt: "DateTime",
    id: "ID",
    subscribable: "Subscribable",
  },
  Updatable: {
    "...on CommitComment": "CommitComment",
    "...on GistComment": "GistComment",
    "...on Issue": "Issue",
    "...on IssueComment": "IssueComment",
    "...on Project": "Project",
    "...on PullRequest": "PullRequest",
    "...on PullRequestReview": "PullRequestReview",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    viewerCanUpdate: "Boolean",
  },
  UpdatableComment: {
    "...on CommitComment": "CommitComment",
    "...on GistComment": "GistComment",
    "...on Issue": "Issue",
    "...on IssueComment": "IssueComment",
    "...on PullRequest": "PullRequest",
    "...on PullRequestReview": "PullRequestReview",
    "...on PullRequestReviewComment": "PullRequestReviewComment",
    viewerCannotUpdateReasons: "CommentCannotUpdateReason",
  },
  UpdateProjectCardPayload: {
    clientMutationId: "String",
    projectCard: "ProjectCard",
  },
  UpdateProjectColumnPayload: {
    clientMutationId: "String",
    projectColumn: "ProjectColumn",
  },
  UpdateProjectPayload: {
    clientMutationId: "String",
    project: "Project",
  },
  UpdatePullRequestReviewCommentPayload: {
    clientMutationId: "String",
    pullRequestReviewComment: "PullRequestReviewComment",
  },
  UpdatePullRequestReviewPayload: {
    clientMutationId: "String",
    pullRequestReview: "PullRequestReview",
  },
  UpdateSubscriptionPayload: {
    clientMutationId: "String",
    subscribable: "Subscribable",
  },
  UpdateTopicsPayload: {
    clientMutationId: "String",
    invalidTopicNames: "String",
    repository: "Repository",
  },
  User: {
    avatarUrl: "URI",
    bio: "String",
    bioHTML: "HTML",
    commitComments: "CommitCommentConnection",
    company: "String",
    companyHTML: "HTML",
    createdAt: "DateTime",
    databaseId: "Int",
    email: "String",
    followers: "FollowerConnection",
    following: "FollowingConnection",
    gist: "Gist",
    gistComments: "GistCommentConnection",
    gists: "GistConnection",
    id: "ID",
    isBountyHunter: "Boolean",
    isCampusExpert: "Boolean",
    isDeveloperProgramMember: "Boolean",
    isEmployee: "Boolean",
    isHireable: "Boolean",
    isSiteAdmin: "Boolean",
    isViewer: "Boolean",
    issueComments: "IssueCommentConnection",
    issues: "IssueConnection",
    location: "String",
    login: "String",
    name: "String",
    organization: "Organization",
    organizations: "OrganizationConnection",
    pinnedRepositories: "RepositoryConnection",
    publicKeys: "PublicKeyConnection",
    pullRequests: "PullRequestConnection",
    repositories: "RepositoryConnection",
    repositoriesContributedTo: "RepositoryConnection",
    repository: "Repository",
    resourcePath: "URI",
    starredRepositories: "StarredRepositoryConnection",
    updatedAt: "DateTime",
    url: "URI",
    viewerCanFollow: "Boolean",
    viewerIsFollowing: "Boolean",
    watching: "RepositoryConnection",
    websiteUrl: "URI",
  },
  UserConnection: {
    edges: "UserEdge",
    nodes: "User",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  UserContentEdit: {
    createdAt: "DateTime",
    deletedAt: "DateTime",
    deletedBy: "Actor",
    diff: "String",
    editedAt: "DateTime",
    editor: "Actor",
    id: "ID",
    updatedAt: "DateTime",
  },
  UserContentEditConnection: {
    edges: "UserContentEditEdge",
    nodes: "UserContentEdit",
    pageInfo: "PageInfo",
    totalCount: "Int",
  },
  UserContentEditEdge: {
    cursor: "String",
    node: "UserContentEdit",
  },
  UserEdge: {
    cursor: "String",
    node: "User",
  },
};

export class GraphQLError extends Error {
  constructor(public response: GraphQLResponse) {
    super("");
    console.error(response);
  }
  toString() {
    return "GraphQL Response Error";
  }
}

type Func<P extends any[], R> = (...args: P) => R;
type AnyFunc = Func<any, any>;

type WithTypeNameValue<T> = T & {
  __typename?: true;
};

type AliasType<T> = WithTypeNameValue<T> & {
  __alias?: Record<string, WithTypeNameValue<T>>;
};

type NotUndefined<T> = T extends undefined ? never : T;

export type ResolverType<F> = NotUndefined<
  F extends [infer ARGS, any] ? ARGS : undefined
>;

export type ArgsType<F extends AnyFunc> = F extends Func<infer P, any>
  ? P
  : never;

interface GraphQLResponse {
  data?: Record<string, any>;
  errors?: Array<{
    message: string;
  }>;
}
export type MapInterface<SRC, DST> = SRC extends {
  __interface: infer INTERFACE;
  __resolve: infer IMPLEMENTORS;
}
  ? ObjectToUnion<
      Omit<
        {
          [Key in keyof Omit<
            DST,
            keyof INTERFACE | "__typename"
          >]: Key extends keyof IMPLEMENTORS
            ? MapType<IMPLEMENTORS[Key], DST[Key]> &
                Omit<
                  {
                    [Key in keyof Omit<
                      DST,
                      keyof IMPLEMENTORS | "__typename"
                    >]: Key extends keyof INTERFACE
                      ? LastMapTypeSRCResolver<INTERFACE[Key], DST[Key]>
                      : never;
                  },
                  keyof IMPLEMENTORS
                > &
                (DST extends { __typename: any }
                  ? MapType<IMPLEMENTORS[Key], { __typename: true }>
                  : {})
            : never;
        },
        keyof INTERFACE | "__typename"
      >
    >
  : never;

export type ValueToUnion<T> = T extends {
  __typename: infer R;
}
  ? {
      [P in keyof Omit<T, "__typename">]: T[P] & {
        __typename: R;
      };
    }
  : T;

export type ObjectToUnion<T> = {
  [P in keyof T]: T[P];
}[keyof T];

type Anify<T> = { [P in keyof T]?: any };

type LastMapTypeSRCResolver<SRC, DST> = SRC extends undefined
  ? undefined
  : SRC extends Array<infer AR>
  ? LastMapTypeSRCResolver<AR, DST>[]
  : SRC extends { __interface: any; __resolve: any }
  ? MapInterface<SRC, DST>
  : SRC extends { __union: any; __resolve: infer RESOLVE }
  ? ObjectToUnion<MapType<RESOLVE, ValueToUnion<DST>>>
  : DST extends boolean
  ? SRC
  : MapType<SRC, DST>;

type MapType<SRC extends Anify<DST>, DST> = DST extends boolean
  ? SRC
  : DST extends {
      __alias: any;
    }
  ? {
      [A in keyof DST["__alias"]]: Required<SRC> extends Anify<
        DST["__alias"][A]
      >
        ? MapType<Required<SRC>, DST["__alias"][A]>
        : never;
    } &
      {
        [Key in keyof Omit<DST, "__alias">]: DST[Key] extends [
          any,
          infer PAYLOAD
        ]
          ? LastMapTypeSRCResolver<SRC[Key], PAYLOAD>
          : LastMapTypeSRCResolver<SRC[Key], DST[Key]>;
      }
  : {
      [Key in keyof DST]: DST[Key] extends [any, infer PAYLOAD]
        ? LastMapTypeSRCResolver<SRC[Key], PAYLOAD>
        : LastMapTypeSRCResolver<SRC[Key], DST[Key]>;
    };

type OperationToGraphQL<V, T> = <Z extends V>(
  o: Z | V,
  variables?: Record<string, any>
) => Promise<MapType<T, Z>>;

type CastToGraphQL<V, T> = (
  resultOfYourQuery: any
) => <Z extends V>(o: Z | V) => MapType<T, Z>;

type fetchOptions = ArgsType<typeof fetch>;

export type SelectionFunction<V> = <T>(t: T | V) => T;
type FetchFunction = (query: string, variables?: Record<string, any>) => any;

export const ZeusSelect = <T>() => ((t: any) => t) as SelectionFunction<T>;
export const ScalarResolver = (scalar: string, value: any) => {
  switch (scalar) {
    case "String":
      return `"${value.replace(/"/g, '\\"')}"`;
    case "Int":
      return `${value}`;
    case "Float":
      return `${value}`;
    case "Boolean":
      return `${value}`;
    case "ID":
      return `"${value}"`;
    case "enum":
      return `${value}`;
    case "scalar":
      return `${value}`;
    default:
      return false;
  }
};

export const TypesPropsResolver = ({
  value,
  type,
  name,
  key,
  blockArrays,
}: {
  value: any;
  type: string;
  name: string;
  key?: string;
  blockArrays?: boolean;
}): string => {
  if (value === null) {
    return `null`;
  }
  let resolvedValue = AllTypesProps[type][name];
  if (key) {
    resolvedValue = resolvedValue[key];
  }
  if (!resolvedValue) {
    throw new Error(`Cannot resolve ${type} ${name}${key ? ` ${key}` : ""}`);
  }
  const typeResolved = resolvedValue.type;
  const isArray: boolean = resolvedValue.array;
  if (typeof value === "string" && value.startsWith(`ZEUS_VAR$`)) {
    const isRequired = resolvedValue.required ? "!" : "";
    return `\$${
      value.split(`ZEUS_VAR$`)[1]
    }__ZEUS_VAR__${typeResolved}${isRequired}`;
  }
  if (isArray && !blockArrays) {
    return `[${value
      .map((v: any) =>
        TypesPropsResolver({ value: v, type, name, key, blockArrays: true })
      )
      .join(",")}]`;
  }
  const reslovedScalar = ScalarResolver(typeResolved, value);
  if (!reslovedScalar) {
    const resolvedType = AllTypesProps[typeResolved];
    if (typeof resolvedType === "object") {
      const argsKeys = Object.keys(resolvedType);
      return `{${argsKeys
        .filter((ak) => value[ak] !== undefined)
        .map(
          (ak) =>
            `${ak}:${TypesPropsResolver({
              value: value[ak],
              type: typeResolved,
              name: ak,
            })}`
        )}}`;
    }
    return ScalarResolver(AllTypesProps[typeResolved], value) as string;
  }
  return reslovedScalar;
};

const isArrayFunction = (parent: string[], a: any[]) => {
  const [values, r] = a;
  const [mainKey, key, ...keys] = parent;
  const keyValues = Object.keys(values);

  if (!keys.length) {
    return keyValues.length > 0
      ? `(${keyValues
          .map(
            (v) =>
              `${v}:${TypesPropsResolver({
                value: values[v],
                type: mainKey,
                name: key,
                key: v,
              })}`
          )
          .join(",")})${r ? traverseToSeekArrays(parent, r) : ""}`
      : traverseToSeekArrays(parent, r);
  }

  const [typeResolverKey] = keys.splice(keys.length - 1, 1);
  let valueToResolve = ReturnTypes[mainKey][key];
  for (const k of keys) {
    valueToResolve = ReturnTypes[valueToResolve][k];
  }

  const argumentString =
    keyValues.length > 0
      ? `(${keyValues
          .map(
            (v) =>
              `${v}:${TypesPropsResolver({
                value: values[v],
                type: valueToResolve,
                name: typeResolverKey,
                key: v,
              })}`
          )
          .join(",")})${r ? traverseToSeekArrays(parent, r) : ""}`
      : traverseToSeekArrays(parent, r);
  return argumentString;
};

const resolveKV = (
  k: string,
  v: boolean | string | { [x: string]: boolean | string }
) =>
  typeof v === "boolean"
    ? k
    : typeof v === "object"
    ? `${k}{${objectToTree(v)}}`
    : `${k}${v}`;

const objectToTree = (o: { [x: string]: boolean | string }): string =>
  `{${Object.keys(o)
    .map((k) => `${resolveKV(k, o[k])}`)
    .join(" ")}}`;

const traverseToSeekArrays = (parent: string[], a?: any): string => {
  if (!a) return "";
  if (Object.keys(a).length === 0) {
    return "";
  }
  let b: Record<string, any> = {};
  if (Array.isArray(a)) {
    return isArrayFunction([...parent], a);
  } else {
    if (typeof a === "object") {
      Object.keys(a).map((k) => {
        if (k === "__alias") {
          Object.keys(a[k]).map((aliasKey) => {
            const aliasOperations = a[k][aliasKey];
            const aliasOperationName = Object.keys(aliasOperations)[0];
            const aliasOperation = aliasOperations[aliasOperationName];
            b[
              `${aliasOperationName}__alias__${aliasKey}: ${aliasOperationName}`
            ] = traverseToSeekArrays(
              [...parent, aliasOperationName],
              aliasOperation
            );
          });
        } else {
          b[k] = traverseToSeekArrays([...parent, k], a[k]);
        }
      });
    } else {
      return "";
    }
  }
  return objectToTree(b);
};

const buildQuery = (type: string, a?: Record<any, any>) =>
  traverseToSeekArrays([type], a);

const inspectVariables = (query: string) => {
  const regex = /\$\b\w*ZEUS_VAR\w*\b[!]?/g;
  let result;
  const AllVariables = [];
  while ((result = regex.exec(query))) {
    AllVariables.push(result[0]);
  }
  if (!AllVariables.length) {
    return query;
  }
  let filteredQuery = query;
  AllVariables.forEach((variable) => {
    filteredQuery = filteredQuery.replace(
      variable,
      variable.split("__ZEUS_VAR__")[0]
    );
  });
  return `(${AllVariables.map((a) => a.split("__ZEUS_VAR__"))
    .map(([variableName, variableType]) => `${variableName}:${variableType}`)
    .join(", ")})${filteredQuery}`;
};

const queryConstruct = (
  t: "query" | "mutation" | "subscription",
  tName: string
) => (o: Record<any, any>) =>
  `${t.toLowerCase()}${inspectVariables(buildQuery(tName, o))}`;

const fullChainConstruct = (fn: FetchFunction) => (
  t: "query" | "mutation" | "subscription",
  tName: string
) => (o: Record<any, any>, variables?: Record<string, any>) =>
  fn(queryConstruct(t, tName)(o), variables);

const seekForAliases = (o: any) => {
  if (typeof o === "object" && o) {
    const keys = Object.keys(o);
    if (keys.length < 1) {
      return;
    }
    keys.forEach((k) => {
      const value = o[k];
      if (k.indexOf("__alias__") !== -1) {
        const [operation, alias] = k.split("__alias__");
        o[alias] = {
          [operation]: value,
        };
        delete o[k];
      } else {
        if (Array.isArray(value)) {
          value.forEach(seekForAliases);
        } else {
          if (typeof value === "object") {
            seekForAliases(value);
          }
        }
      }
    });
  }
};

export const $ = (t: TemplateStringsArray): any => `ZEUS_VAR$${t.join("")}`;

const handleFetchResponse = (
  response: Parameters<
    Extract<Parameters<ReturnType<typeof fetch>["then"]>[0], Function>
  >[0]
): Promise<GraphQLResponse> => {
  if (!response.ok) {
    return new Promise((resolve, reject) => {
      response
        .text()
        .then((text) => {
          try {
            reject(JSON.parse(text));
          } catch (err) {
            reject(text);
          }
        })
        .catch(reject);
    });
  }
  return response.json();
};

const apiFetch = (options: fetchOptions) => (
  query: string,
  variables: Record<string, any> = {}
) => {
  let fetchFunction = fetch;
  let queryString = query;
  let fetchOptions = options[1] || {};
  if (fetchOptions.method && fetchOptions.method === "GET") {
    queryString = encodeURIComponent(query);
    return fetchFunction(`${options[0]}?query=${queryString}`, fetchOptions)
      .then(handleFetchResponse)
      .then((response: GraphQLResponse) => {
        if (response.errors) {
          throw new GraphQLError(response);
        }
        seekForAliases(response.data);
        return response.data;
      });
  }
  return fetchFunction(`${options[0]}`, {
    body: JSON.stringify({ query: queryString, variables }),
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    ...fetchOptions,
  })
    .then(handleFetchResponse)
    .then((response: GraphQLResponse) => {
      if (response.errors) {
        throw new GraphQLError(response);
      }
      seekForAliases(response.data);
      return response.data;
    });
};

export const Thunder = (fn: FetchFunction) => ({
  query: ((o: any, variables) =>
    fullChainConstruct(fn)("query", "Query")(o, variables).then(
      (response: any) => response
    )) as OperationToGraphQL<ValueTypes["Query"], Query>,
  mutation: ((o: any, variables) =>
    fullChainConstruct(fn)("mutation", "Mutation")(o, variables).then(
      (response: any) => response
    )) as OperationToGraphQL<ValueTypes["Mutation"], Mutation>,
});

export const Chain = (...options: fetchOptions) => ({
  query: ((o: any, variables) =>
    fullChainConstruct(apiFetch(options))("query", "Query")(o, variables).then(
      (response: any) => response
    )) as OperationToGraphQL<ValueTypes["Query"], Query>,
  mutation: ((o: any, variables) =>
    fullChainConstruct(apiFetch(options))("mutation", "Mutation")(
      o,
      variables
    ).then((response: any) => response)) as OperationToGraphQL<
    ValueTypes["Mutation"],
    Mutation
  >,
});
export const Zeus = {
  query: (o: ValueTypes["Query"]) => queryConstruct("query", "Query")(o),
  mutation: (o: ValueTypes["Mutation"]) =>
    queryConstruct("mutation", "Mutation")(o),
};
export const Cast = {
  query: ((o: any) => (b: any) => o) as CastToGraphQL<
    ValueTypes["Query"],
    Query
  >,
  mutation: ((o: any) => (b: any) => o) as CastToGraphQL<
    ValueTypes["Mutation"],
    Mutation
  >,
};
export const Selectors = {
  query: ZeusSelect<ValueTypes["Query"]>(),
  mutation: ZeusSelect<ValueTypes["Mutation"]>(),
};

export const Gql = Chain("https://api.github.com/graphql");
